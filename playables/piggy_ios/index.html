<div style='min-height:1px; width: 100%; overflow:auto; overflow-x: hidden; border: 1px solid #777;-webkit-overflow-scrolling:touch;'>
    <script type="text/javascript">window.NREUM || (NREUM = {}), __nr_require = function(e, t, n) {
        function r(n) {
            if(!t[n]) {
                var o = t[n] = {exports: {}};
                e[n][0].call(o.exports, function(t) {
                    var o = e[n][1][t];
                    return r(o || t)
                }, o, o.exports)
            }
            return t[n].exports
        }

        if("function" == typeof __nr_require)return __nr_require;
        for(var o = 0; o < n.length; o++)r(n[o]);
        return r
    }({
        1: [function(e, t, n) {
            function r() {
            }

            function o(e, t, n) {
                return function() {
                    return i(e, [(new Date).getTime()].concat(u(arguments)), t ? null : this, n), t ? void 0 : this
                }
            }

            var i = e("handle"), a = e(2), u = e(3), c = e("ee").get("tracer"), f = NREUM;
            "undefined" == typeof window.newrelic && (newrelic = f);
            var s = ["setPageViewName", "setCustomAttribute", "setErrorHandler", "finished", "addToTrace", "inlineHit"],
                l = "api-", p = l + "ixn-";
            a(s, function(e, t) {
                f[t] = o(l + t, !0, "api")
            }), f.addPageAction = o(l + "addPageAction", !0), f.setCurrentRouteName = o(l + "routeName", !0), t.exports = newrelic, f.interaction = function() {
                return (new r).get()
            };
            var d = r.prototype = {
                createTracer: function(e, t) {
                    var n = {}, r = this, o = "function" == typeof t;
                    return i(p + "tracer", [Date.now(), e, n], r), function() {
                        if(c.emit((o ? "" : "no-") + "fn-start", [Date.now(), r, o], n), o)try {
                            return t.apply(this, arguments)
                        } finally {
                            c.emit("fn-end", [Date.now()], n)
                        }
                    }
                }
            };
            a("setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","), function(e, t) {
                d[t] = o(p + t)
            }), newrelic.noticeError = function(e) {
                "string" == typeof e && (e = new Error(e)), i("err", [e, (new Date).getTime()])
            }
        }, {}], 2: [function(e, t, n) {
            function r(e, t) {
                var n = [], r = "", i = 0;
                for(r in e)o.call(e, r) && (n[i] = t(r, e[r]), i += 1);
                return n
            }

            var o = Object.prototype.hasOwnProperty;
            t.exports = r
        }, {}], 3: [function(e, t, n) {
            function r(e, t, n) {
                t || (t = 0), "undefined" == typeof n && (n = e ? e.length : 0);
                for(var r = -1, o = n - t || 0, i = Array(o < 0 ? 0 : o); ++r < o;)i[r] = e[t + r];
                return i
            }

            t.exports = r
        }, {}], ee: [function(e, t, n) {
            function r() {
            }

            function o(e) {
                function t(e) {
                    return e && e instanceof r ? e : e ? c(e, u, i) : i()
                }

                function n(n, r, o) {
                    if(!p.aborted) {
                        e && e(n, r, o);
                        for(var i = t(o), a = v(n), u = a.length, c = 0; c < u; c++)a[c].apply(i, r);
                        var f = s[w[n]];
                        return f && f.push([y, n, r, i]), i
                    }
                }

                function d(e, t) {
                    b[e] = v(e).concat(t)
                }

                function v(e) {
                    return b[e] || []
                }

                function g(e) {
                    return l[e] = l[e] || o(n)
                }

                function m(e, t) {
                    f(e, function(e, n) {
                        t = t || "feature", w[n] = t, t in s || (s[t] = [])
                    })
                }

                var b = {}, w = {},
                    y = {on: d, emit: n, get: g, listeners: v, context: t, buffer: m, abort: a, aborted: !1};
                return y
            }

            function i() {
                return new r
            }

            function a() {
                (s.api || s.feature) && (p.aborted = !0, s = p.backlog = {})
            }

            var u = "nr@context", c = e("gos"), f = e(2), s = {}, l = {}, p = t.exports = o();
            p.backlog = s
        }, {}], gos: [function(e, t, n) {
            function r(e, t, n) {
                if(o.call(e, t))return e[t];
                var r = n();
                if(Object.defineProperty && Object.keys)try {
                    return Object.defineProperty(e, t, {value: r, writable: !0, enumerable: !1}), r
                } catch(i) {
                }
                return e[t] = r, r
            }

            var o = Object.prototype.hasOwnProperty;
            t.exports = r
        }, {}], handle: [function(e, t, n) {
            function r(e, t, n, r) {
                o.buffer([e], r), o.emit(e, t, n)
            }

            var o = e("ee").get("handle");
            t.exports = r, r.ee = o
        }, {}], id: [function(e, t, n) {
            function r(e) {
                var t = typeof e;
                return !e || "object" !== t && "function" !== t ? -1 : e === window ? 0 : a(e, i, function() {
                    return o++
                })
            }

            var o = 1, i = "nr@id", a = e("gos");
            t.exports = r
        }, {}], loader: [function(e, t, n) {
            function r() {
                if(!h++) {
                    var e = y.info = NREUM.info, t = l.getElementsByTagName("script")[0];
                    if(setTimeout(f.abort, 3e4), !(e && e.licenseKey && e.applicationID && t))return f.abort();
                    c(b, function(t, n) {
                        e[t] || (e[t] = n)
                    }), u("mark", ["onload", a()], null, "api");
                    var n = l.createElement("script");
                    n.src = "https://" + e.agent, t.parentNode.insertBefore(n, t)
                }
            }

            function o() {
                "complete" === l.readyState && i()
            }

            function i() {
                u("mark", ["domContent", a()], null, "api")
            }

            function a() {
                return (new Date).getTime()
            }

            var u = e("handle"), c = e(2), f = e("ee"), s = window, l = s.document, p = "addEventListener",
                d = "attachEvent", v = s.XMLHttpRequest, g = v && v.prototype;
            NREUM.o = {
                ST: setTimeout,
                CT: clearTimeout,
                XHR: v,
                REQ: s.Request,
                EV: s.Event,
                PR: s.Promise,
                MO: s.MutationObserver
            }, e(1);
            var m = "" + location, b = {
                    beacon: "bam.nr-data.net",
                    errorBeacon: "bam.nr-data.net",
                    agent: "js-agent.newrelic.com/nr-998.min.js"
                }, w = v && g && g[p] && !/CriOS/.test(navigator.userAgent),
                y = t.exports = {offset: a(), origin: m, features: {}, xhrWrappable: w};
            l[p] ? (l[p]("DOMContentLoaded", i, !1), s[p]("load", r, !1)) : (l[d]("onreadystatechange", o), s[d]("onload", r)), u("mark", ["firstbyte", a()], null, "api");
            var h = 0
        }, {}]
    }, {}, ["loader"]);</script>

    <script src="mraid.js"></script>
    <style>
        /* vietnamese */
        @font-face {
            font-family: 'Muli';
            font-style: normal;
            font-weight: 300;
            src: local('Muli Light'), local('Muli-Light'), url(https://fonts.gstatic.com/s/muli/v10/F1xemzW-ll-DS_cw7XzYlFKPGs1ZzpMvnHX-7fPOuAc.woff2) format('woff2');
            unicode-range: U+0102-0103, U+1EA0-1EF9, U+20AB;
        }

        /* latin-ext */
        @font-face {
            font-family: 'Muli';
            font-style: normal;
            font-weight: 300;
            src: local('Muli Light'), local('Muli-Light'), url(https://fonts.gstatic.com/s/muli/v10/849cjs-cyAZl3ZpQj1JaJlKPGs1ZzpMvnHX-7fPOuAc.woff2) format('woff2');
            unicode-range: U+0100-024F, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
        }

        /* latin */
        @font-face {
            font-family: 'Muli';
            font-style: normal;
            font-weight: 300;
            src: local('Muli Light'), local('Muli-Light'), url(https://fonts.gstatic.com/s/muli/v10/mls_29xz6YyJHsylG8hcCgLUuEpTyoUstqEm5AMlJo4.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
        }

    </style>
    <style>#creative, body, html {
        height: 100%;
        width: 100%
    }

    #btn-gettheapp, #splash, body {
        overflow: hidden
    }

    #ad_header, #btn-gettheapp, #splash {
        text-align: center
    }

    #ad_header, #creative, #splash, body, html {
        width: 100%
    }

    #ad_title, #splash_wait {
        font-family: Muli, Arial, Helvetica, sans-serif;
        color: #fff
    }

    body {
        margin: 0 0 1px;
        padding: 0;
        background: #000;
        -webkit-user-select: none
    }

    iframe {
        display: block;
        margin: 0 auto
    }

    #creative {
        z-index: -999
    }

    #splash {
        height: 2000px;
        background: #222
    }

    .bg-shadow {
        position: fixed !important;
        display: block
    }

    #splash img, #splash_icon, #splash_loading, #splash_wait, .close-button {
        position: relative
    }

    #splash img {
        z-index: 3;
        max-width: 145px;
        -webkit-filter: drop-shadow(0 0 20px rgba(255, 255, 255, .4))
    }

    #splash_icon {
        margin: 32px 0 15px;
        z-index: 100;
        border-radius: 4px
    }

    #splash_wait {
        z-index: 3;
        margin: 20px 0 4px;
        font-size: 1.1em
    }

    #splash_loading {
        z-index: 3;
        margin: 0 auto;
        width: 135px;
        height: 41px
    }

    #splash_loading_bar {
        position: absolute;
        top: 16px;
        left: 0;
        height: 12px;
        border-radius: 5px;
        background-color: #81BF00
    }

    #splash_loading_bar_full {
        position: absolute;
        top: 14px;
        left: 0;
        width: 129px;
        height: 10px;
        border-radius: 8px;
        background-color: none;
        border: 3px solid #FA9500
    }

    #splash_loading_bar_full img {
        width: 0
    }

    #ad_header {
        height: 26px;
        background: #0b0d12;
        border-top: 1px solid #FA9500;
        border-bottom: 1px solid #81BF00;
        position: fixed;
        top: 0;
        background-color: rgba(11, 13, 18, .82)
    }

    #ad_header_logo {
        width: 95px;
        height: 26px;
        background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE5LjIuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA3NzQgMjA1LjUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc3NCAyMDUuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiID4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkZGRkZGO30KCS5zdDF7ZGlzcGxheTpub25lO30KCS5zdDJ7ZGlzcGxheTppbmxpbmU7fQoJLnN0M3tmaWxsOiM4MkJDMDA7fQoJLnN0NHtmaWxsOiNGRTdDMjE7fQo8L3N0eWxlPgo8Zz4KCTxnPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MjkuNCwxNDguNGgtOS43VjYxLjZoOS43VjE0OC40eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00NTYuNCw2MS42aDI0LjFsNC45LDQuOHY4Mi4xaC05LjdWNzEuMmgtOS43djc3LjJoLTkuN1Y2MS42eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01MzEuOCwxMDAuMVY3MS4yaC05Ljd2MzguNWgxNi44bDIuNSwyLjVWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40di0xNi45aDkuN3Y5LjdoOS43di0xOS4zaC0xNi45CgkJCWwtMi40LTIuNFY2NGwyLjQtMi40aDI0LjFsMi41LDIuNHYzNi4xSDUzMS44eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01OTcuMyw2MS42djkuN2gtOS43djc3LjJINTc4VjcxLjJoLTkuN3YtOS43SDU5Ny4zeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik02NTMuNCw2NHY4NC40aC05Ljd2LTI5aC05Ljd2MjloLTkuN1Y2NGwyLjQtMi40aDI0LjFMNjUzLjQsNjR6IE02NDMuOCw3MS4yaC05Ljd2MzguNWg5LjdWNzEuMnoiLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNNzA5LjUsMTM4Ljd2OS43aC0yOVY2MS42aDkuN3Y3Ny4ySDcwOS41eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik03NjUuNSwxMzguN3Y5LjdoLTI5VjYxLjZoOS43djc3LjJINzY1LjV6Ii8+Cgk8L2c+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzguNiwxMDkuOVY3MS4zaC05Ljd2NjcuNWg5Ljd2LTE5LjNoOS43VjE0NmwtMi41LDIuNUgyMS43bC0yLjQtMi41VjY0LjFsMi40LTIuNGgyNC4xbDIuNSwyLjR2NDUuOEgzOC42eiIKCQkJLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTA0LjMsMTA5LjhsLTQuOSw0LjlsNC45LDQuOHYyOWgtOS43di0yOWgtOS43djI5aC05LjdWNjEuNmgyNi41bDIuNSwyLjRWMTA5Ljh6IE05NC42LDcxLjJoLTkuN3YzOC41aDkuNwoJCQlWNzEuMnoiLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTYwLjMsNjRWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40VjY0bDIuNC0yLjRoMjQuMUwxNjAuMyw2NHogTTE1MC42LDcxLjJoLTkuN3Y2Ny41aDkuN1Y3MS4yeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMDYuNiwxMDAuMVY3MS4yaC05Ljd2MzguNWgxNi44bDIuNSwyLjVWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40di0xNi45aDkuN3Y5LjdoOS43di0xOS4zaC0xNi45CgkJCWwtMi40LTIuNFY2NGwyLjQtMi40aDI0LjFsMi41LDIuNHYzNi4xSDIwNi42eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yNjIuNiwxMDAuMVY3MS4ySDI1M3YzOC41aDE2LjhsMi41LDIuNVYxNDZsLTIuNSwyLjRoLTI0LjFsLTIuNC0yLjR2LTE2LjloOS43djkuN2g5Ljd2LTE5LjNoLTE2LjkKCQkJbC0yLjQtMi40VjY0bDIuNC0yLjRoMjQuMWwyLjUsMi40djM2LjFIMjYyLjZ6Ii8+Cgk8L2c+Cgk8ZyBjbGFzcz0ic3QxIj4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNDI0LjYsMTYyLjJsMS43LTEyLjFoMC4ybDQuOSwxMGw0LjktMTBoMC4ybDEuNywxMi4xaC0xLjJsLTEuMi04LjdsLTQuMyw4LjdoLTAuM2wtNC4zLTguN2wtMS4yLDguN0g0MjQuNnoKCQkJIi8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ0OCwxNDkuOGMxLjgsMCwzLjQsMC42LDQuNiwxLjhjMS4yLDEuMiwxLjksMi43LDEuOSw0LjVjMCwxLjgtMC42LDMuMy0xLjksNC41Yy0xLjIsMS4yLTIuNywxLjktNC41LDEuOQoJCQljLTEuOCwwLTMuMy0wLjYtNC42LTEuOGMtMS4yLTEuMi0xLjktMi43LTEuOS00LjVjMC0xLjIsMC4zLTIuMiwwLjgtMy4yYzAuNi0xLDEuMy0xLjgsMi4zLTIuM0M0NDUuOCwxNTAsNDQ2LjksMTQ5LjgsNDQ4LDE0OS44egoJCQkgTTQ0OC4xLDE1MC45Yy0wLjksMC0xLjcsMC4yLTIuNiwwLjdjLTAuOCwwLjUtMS40LDEuMS0xLjksMS45Yy0wLjUsMC44LTAuNywxLjctMC43LDIuNmMwLDEuNCwwLjUsMi43LDEuNSwzLjcKCQkJYzEsMSwyLjIsMS41LDMuNiwxLjVjMC45LDAsMS44LTAuMiwyLjYtMC43YzAuOC0wLjUsMS40LTEuMSwxLjktMS45YzAuNC0wLjgsMC43LTEuNywwLjctMi42YzAtMS0wLjItMS44LTAuNy0yLjYKCQkJYy0wLjQtMC44LTEuMS0xLjQtMS45LTEuOUM0NDkuOCwxNTEuMiw0NDksMTUwLjksNDQ4LjEsMTUwLjl6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ1OC41LDE1MC4xaDIuNGMxLDAsMS43LDAuMSwyLjIsMC4zYzAuNSwwLjIsMC45LDAuNiwxLjIsMS4xYzAuMywwLjUsMC40LDEsMC40LDEuNmMwLDAuNS0wLjEsMS0wLjQsMS41CgkJCWMtMC4zLDAuNC0wLjYsMC44LTEuMiwxLjFjMC42LDAuMiwxLjEsMC41LDEuNSwwLjhjMC4zLDAuMywwLjYsMC42LDAuOCwxYzAuMiwwLjQsMC4zLDAuOSwwLjMsMS4zYzAsMS0wLjQsMS44LTEuMSwyLjUKCQkJYy0wLjcsMC43LTEuNywxLTIuOSwxaC0zLjNWMTUwLjF6IE00NTkuNiwxNTEuM3YzLjloMC43YzAuOCwwLDEuNS0wLjEsMS45LTAuMmMwLjQtMC4yLDAuNy0wLjQsMC45LTAuN2MwLjItMC4zLDAuMy0wLjcsMC4zLTEuMQoJCQljMC0wLjYtMC4yLTEtMC42LTEuM2MtMC40LTAuMy0xLTAuNS0xLjktMC41SDQ1OS42eiBNNDU5LjYsMTU2LjR2NC43aDEuNWMwLjksMCwxLjUtMC4xLDEuOS0wLjNjMC40LTAuMiwwLjctMC40LDEtMC44CgkJCWMwLjMtMC40LDAuNC0wLjgsMC40LTEuMmMwLTAuNS0wLjItMS0wLjUtMS40Yy0wLjQtMC40LTAuOC0wLjctMS41LTAuOGMtMC40LTAuMS0xLjEtMC4xLTIuMi0wLjFINDU5LjZ6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ2OS41LDE1MC4xaDEuMnYxMi4xaC0xLjJWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3NSwxNTAuMWgxLjJ2MTFoNC43djEuMkg0NzVWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ4NC4zLDE1MC4xaDd2MS4yaC01Ljd2My44aDUuN3YxLjJoLTUuN3Y0LjhoNS43djEuMmgtNi45VjE1MC4xeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik00OTUuOSwxNjAuNGMwLjMsMCwwLjUsMC4xLDAuNywwLjNjMC4yLDAuMiwwLjMsMC40LDAuMywwLjdjMCwwLjMtMC4xLDAuNS0wLjMsMC43Yy0wLjIsMC4yLTAuNCwwLjMtMC43LDAuMwoJCQljLTAuMywwLTAuNS0wLjEtMC43LTAuM2MtMC4yLTAuMi0wLjMtMC40LTAuMy0wLjdjMC0wLjMsMC4xLTAuNSwwLjMtMC43QzQ5NS40LDE2MC41LDQ5NS43LDE2MC40LDQ5NS45LDE2MC40eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik01MDYsMTU5LjlsMS0wLjZjMC43LDEuMywxLjYsMiwyLjUsMmMwLjQsMCwwLjgtMC4xLDEuMS0wLjNjMC40LTAuMiwwLjYtMC40LDAuOC0wLjhjMC4yLTAuMywwLjMtMC43LDAuMy0xCgkJCWMwLTAuNC0wLjEtMC44LTAuNC0xLjJjLTAuNC0wLjUtMS4xLTEuMi0yLjEtMS45Yy0xLTAuOC0xLjYtMS4zLTEuOS0xLjdjLTAuNC0wLjYtMC42LTEuMi0wLjYtMS45YzAtMC41LDAuMS0xLDAuNC0xLjQKCQkJYzAuMy0wLjQsMC42LTAuOCwxLjEtMWMwLjUtMC4yLDEtMC40LDEuNS0wLjRjMC42LDAsMS4xLDAuMSwxLjYsMC40YzAuNSwwLjMsMSwwLjgsMS42LDEuNmwtMSwwLjdjLTAuNS0wLjYtMC44LTEtMS4yLTEuMgoJCQljLTAuMy0wLjItMC43LTAuMy0xLjEtMC4zYy0wLjUsMC0wLjksMC4xLTEuMiwwLjRjLTAuMywwLjMtMC41LDAuNy0wLjUsMS4xYzAsMC4zLDAuMSwwLjUsMC4yLDAuOGMwLjEsMC4yLDAuMywwLjUsMC42LDAuOAoJCQljMC4yLDAuMiwwLjcsMC42LDEuNiwxLjJjMSwwLjgsMS44LDEuNSwyLjIsMi4xYzAuNCwwLjYsMC42LDEuMiwwLjYsMS44YzAsMC45LTAuMywxLjYtMSwyLjNjLTAuNywwLjYtMS41LDEtMi40LDEKCQkJYy0wLjcsMC0xLjQtMC4yLTItMC42QzUwNy4xLDE2MS41LDUwNi41LDE2MC45LDUwNiwxNTkuOXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTE3LDE1MC4xaDEuMnYxMi4xSDUxN1YxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTIyLDE2Mi4ybDEuNy0xMi4xaDAuMmw0LjksMTBsNC45LTEwaDAuMmwxLjcsMTIuMWgtMS4ybC0xLjItOC43bC00LjMsOC43aC0wLjNsLTQuMy04LjdsLTEuMiw4LjdINTIyeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik01MzkuNSwxNTAuMWgyLjRjMS40LDAsMi4zLDAuMSwyLjgsMC4yYzAuNywwLjIsMS4zLDAuNSwxLjcsMWMwLjQsMC41LDAuNywxLjIsMC43LDJjMCwwLjgtMC4yLDEuNS0wLjYsMgoJCQljLTAuNCwwLjUtMSwwLjktMS44LDEuMWMtMC41LDAuMS0xLjYsMC4yLTMuMSwwLjJoLTAuOXY1LjZoLTEuMlYxNTAuMXogTTU0MC44LDE1MS4zdjQuMWwyLjEsMGMwLjgsMCwxLjQtMC4xLDEuOC0wLjIKCQkJYzAuNC0wLjIsMC43LTAuNCwwLjktMC43YzAuMi0wLjMsMC4zLTAuNywwLjMtMS4xYzAtMC40LTAuMS0wLjgtMC4zLTEuMWMtMC4yLTAuMy0wLjUtMC42LTAuOS0wLjdjLTAuNC0wLjEtMS0wLjItMS44LTAuMkg1NDAuOHoKCQkJIi8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU1MS4xLDE1MC4xaDEuMnYxMWg0Ljd2MS4yaC01LjlWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU2MC4yLDE1MC4xaDEuMnYxMi4xaC0xLjJWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU2NS43LDE1MC4xaDYuMXYxLjJoLTQuOXYzLjhoNC45djEuMmgtNC45djZoLTEuMlYxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTc1LjMsMTUwLjFoMS4ydjEyLjFoLTEuMlYxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTgwLjgsMTUwLjFoNi45djEuMkg1ODJ2My44aDUuN3YxLjJINTgydjQuOGg1Ljd2MS4yaC02LjlWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU5MS4zLDE2Mi4ydi0xMi4xaDIuNWMxLjgsMCwzLjEsMC4xLDMuOSwwLjRjMS4yLDAuNCwyLjEsMS4xLDIuOCwyLjFjMC43LDEsMSwyLjIsMSwzLjYKCQkJYzAsMS4yLTAuMywyLjMtMC44LDMuMmMtMC41LDAuOS0xLjIsMS42LTIsMmMtMC44LDAuNC0yLDAuNy0zLjUsMC43SDU5MS4zeiBNNTkyLjUsMTYxaDEuNGMxLjcsMCwyLjgtMC4xLDMuNS0wLjMKCQkJYzAuOS0wLjMsMS42LTAuOCwyLjItMS42YzAuNS0wLjgsMC44LTEuNywwLjgtMi44YzAtMS4yLTAuMy0yLjItMC44LTNjLTAuNi0wLjgtMS40LTEuNC0yLjQtMS43Yy0wLjgtMC4yLTItMC4zLTMuOC0wLjNoLTAuOVYxNjEKCQkJeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik02MDYuNSwxNjAuNGMwLjMsMCwwLjUsMC4xLDAuNywwLjNjMC4yLDAuMiwwLjMsMC40LDAuMywwLjdjMCwwLjMtMC4xLDAuNS0wLjMsMC43Yy0wLjIsMC4yLTAuNCwwLjMtMC43LDAuMwoJCQljLTAuMywwLTAuNS0wLjEtMC43LTAuM2MtMC4yLTAuMi0wLjMtMC40LTAuMy0wLjdjMC0wLjMsMC4xLTAuNSwwLjMtMC43QzYwNiwxNjAuNSw2MDYuMiwxNjAuNCw2MDYuNSwxNjAuNHoiLz4KCTwvZz4KCTxnPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMzM4LjEsMTA1LjIgMzIyLjcsMTE4LjkgMjQyLjgsMTk2LjQgMjY5LjUsMTk2LjQgMzM3LjksMTMwLjYgNDA3LjEsMTk2LjQgNDMyLjgsMTk1LjQgMzUzLjMsMTE4LjgKCQkJMzM4LjEsMTA1LjIgCQkiLz4KCQk8Zz4KCQkJPHBhdGggY2xhc3M9InN0MyIgZD0iTTMzOC4xLDEwNS43bDEzLjQsMTNsNzksNzYuMmgtMjMuNGwtNjcuNS02NWwtMS44LTEuN2wtMS44LDEuN2wtNjcuNyw2NWgtMjMuNGw3OS4zLTc2LjFMMzM4LjEsMTA1LjcKCQkJCSBNMzM4LjEsMTAyLjJsLTE1LjQsMTQuOGwtODMuOSw4MC40aDMwLjdsNjguNC02NS43bDY4LjIsNjUuN2gzMC43bC04My41LTgwLjVMMzM4LjEsMTAyLjJMMzM4LjEsMTAyLjJ6Ii8+CgkJPC9nPgoJCTxnPgoJCQk8Zz4KCQkJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MzAuNSw5LjhsLTc5LDc2LjJsLTEzLjQsMTNsLTEzLjYtMTMuMUwyNDUuMSw5LjhoMjMuNGw2Ny43LDY1bDAuMiwwLjJjMC45LDAuOCwyLjIsMC44LDMuMSwwbDAuMi0wLjIKCQkJCQlsNjcuNS02NUg0MzAuNSBNMzIyLjcsODcuNyBNMzUzLjMsODcuNyIvPgoJCQk8L2c+CgkJCTxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik00MzAuNSw5LjhsLTc5LDc2LjJsLTEzLjQsMTNsLTEzLjYtMTMuMUwyNDUuMSw5LjhoMjMuNGw2Ny43LDY1bDAuMiwwLjJjMC45LDAuOCwyLjIsMC44LDMuMSwwbDAuMi0wLjIKCQkJCWw2Ny41LTY1SDQzMC41IE00MzYuOCw3LjJoLTMwLjdMMzM3LjksNzNMMjY5LjUsNy4yaC0zMC43bDgzLjksODAuNGwxNS40LDE0LjhsMTUuMi0xNC43TDQzNi44LDcuMkw0MzYuOCw3LjJ6Ii8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="), linear-gradient(transparent, transparent)
    }

    .ad_header_logo_left {
        position: absolute;
        top: 1px;
        left: 4px
    }

    .ad_header_logo_right {
        position: absolute;
        top: 1px;
        right: 4px
    }

    #ad_title {
        padding-top: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 50%;
        height: 80%;
        font-size: 1em;
        font-weight: 700;
        cursor: pointer
    }

    #ad_title a {
        text-decoration: none;
        color: #fff
    }

    #close_zone {
        z-index: 100;
        cursor: pointer;
        font-size: 25%
    }

    .close_zone_left {
        position: absolute;
        top: 2px;
        left: 2px
    }

    .close_zone_right {
        position: absolute;
        top: 2px;
        right: 2px
    }

    #close_timer {
        color: #fff;
        font: 400 1em/normal Arial, Helvetica, sans-serif
    }

    .close_timer_left {
        position: absolute;
        top: 6px;
        left: 10px
    }

    .close_timer_right {
        position: absolute;
        top: 6px;
        right: 10px
    }

    .close-button {
        display: inline-block;
        -webkit-box-sizing: content-box;
        -moz-box-sizing: content-box;
        box-sizing: content-box;
        width: .75em;
        height: .75em;
        border: none;
        -webkit-border-radius: 1em;
        border-radius: 1em;
        font: 400 8em/normal Arial, Helvetica, sans-serif;
        color: rgba(0, 0, 0, 1);
        -o-text-overflow: clip;
        text-overflow: clip;
        background: #111;
        top: -1px
    }

    .close-button::after, .close-button::before {
        display: inline-block;
        width: .45em;
        height: .1em;
        content: "";
        top: .33em;
        left: .155em;
        border: none;
        font: 400 100%/normal Arial, Helvetica, sans-serif;
        color: rgba(0, 0, 0, 1);
        -o-text-overflow: clip;
        text-overflow: clip;
        background: #fff;
        text-shadow: none;
        position: absolute
    }

    .close-button::before {
        -webkit-box-sizing: content-box;
        -moz-box-sizing: content-box;
        box-sizing: content-box;
        -webkit-transform: rotateZ(45deg);
        transform: rotateZ(45deg)
    }

    .close-button::after {
        -webkit-box-sizing: content-box;
        -moz-box-sizing: content-box;
        box-sizing: content-box;
        -webkit-transform: rotateZ(-45deg);
        transform: rotateZ(-45deg)
    }

    #splash_footer {
        width: 100%;
        height: 45px;
        z-index: 3;
        position: absolute;
        bottom: 0;
        left: 0
    }

    #splash_footer_logo {
        margin: 0 auto;
        width: 104px;
        height: 33px;
        background: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE5LjIuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA3NzQgMjA1LjUiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDc3NCAyMDUuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiID4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkZGRkZGO30KCS5zdDF7ZGlzcGxheTpub25lO30KCS5zdDJ7ZGlzcGxheTppbmxpbmU7fQoJLnN0M3tmaWxsOiM4MkJDMDA7fQoJLnN0NHtmaWxsOiNGRTdDMjE7fQo8L3N0eWxlPgo8Zz4KCTxnPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MjkuNCwxNDguNGgtOS43VjYxLjZoOS43VjE0OC40eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00NTYuNCw2MS42aDI0LjFsNC45LDQuOHY4Mi4xaC05LjdWNzEuMmgtOS43djc3LjJoLTkuN1Y2MS42eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01MzEuOCwxMDAuMVY3MS4yaC05Ljd2MzguNWgxNi44bDIuNSwyLjVWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40di0xNi45aDkuN3Y5LjdoOS43di0xOS4zaC0xNi45CgkJCWwtMi40LTIuNFY2NGwyLjQtMi40aDI0LjFsMi41LDIuNHYzNi4xSDUzMS44eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01OTcuMyw2MS42djkuN2gtOS43djc3LjJINTc4VjcxLjJoLTkuN3YtOS43SDU5Ny4zeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik02NTMuNCw2NHY4NC40aC05Ljd2LTI5aC05Ljd2MjloLTkuN1Y2NGwyLjQtMi40aDI0LjFMNjUzLjQsNjR6IE02NDMuOCw3MS4yaC05Ljd2MzguNWg5LjdWNzEuMnoiLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNNzA5LjUsMTM4Ljd2OS43aC0yOVY2MS42aDkuN3Y3Ny4ySDcwOS41eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik03NjUuNSwxMzguN3Y5LjdoLTI5VjYxLjZoOS43djc3LjJINzY1LjV6Ii8+Cgk8L2c+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzguNiwxMDkuOVY3MS4zaC05Ljd2NjcuNWg5Ljd2LTE5LjNoOS43VjE0NmwtMi41LDIuNUgyMS43bC0yLjQtMi41VjY0LjFsMi40LTIuNGgyNC4xbDIuNSwyLjR2NDUuOEgzOC42eiIKCQkJLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTA0LjMsMTA5LjhsLTQuOSw0LjlsNC45LDQuOHYyOWgtOS43di0yOWgtOS43djI5aC05LjdWNjEuNmgyNi41bDIuNSwyLjRWMTA5Ljh6IE05NC42LDcxLjJoLTkuN3YzOC41aDkuNwoJCQlWNzEuMnoiLz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMTYwLjMsNjRWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40VjY0bDIuNC0yLjRoMjQuMUwxNjAuMyw2NHogTTE1MC42LDcxLjJoLTkuN3Y2Ny41aDkuN1Y3MS4yeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMDYuNiwxMDAuMVY3MS4yaC05Ljd2MzguNWgxNi44bDIuNSwyLjVWMTQ2bC0yLjUsMi40aC0yNC4xbC0yLjQtMi40di0xNi45aDkuN3Y5LjdoOS43di0xOS4zaC0xNi45CgkJCWwtMi40LTIuNFY2NGwyLjQtMi40aDI0LjFsMi41LDIuNHYzNi4xSDIwNi42eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yNjIuNiwxMDAuMVY3MS4ySDI1M3YzOC41aDE2LjhsMi41LDIuNVYxNDZsLTIuNSwyLjRoLTI0LjFsLTIuNC0yLjR2LTE2LjloOS43djkuN2g5Ljd2LTE5LjNoLTE2LjkKCQkJbC0yLjQtMi40VjY0bDIuNC0yLjRoMjQuMWwyLjUsMi40djM2LjFIMjYyLjZ6Ii8+Cgk8L2c+Cgk8ZyBjbGFzcz0ic3QxIj4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNDI0LjYsMTYyLjJsMS43LTEyLjFoMC4ybDQuOSwxMGw0LjktMTBoMC4ybDEuNywxMi4xaC0xLjJsLTEuMi04LjdsLTQuMyw4LjdoLTAuM2wtNC4zLTguN2wtMS4yLDguN0g0MjQuNnoKCQkJIi8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ0OCwxNDkuOGMxLjgsMCwzLjQsMC42LDQuNiwxLjhjMS4yLDEuMiwxLjksMi43LDEuOSw0LjVjMCwxLjgtMC42LDMuMy0xLjksNC41Yy0xLjIsMS4yLTIuNywxLjktNC41LDEuOQoJCQljLTEuOCwwLTMuMy0wLjYtNC42LTEuOGMtMS4yLTEuMi0xLjktMi43LTEuOS00LjVjMC0xLjIsMC4zLTIuMiwwLjgtMy4yYzAuNi0xLDEuMy0xLjgsMi4zLTIuM0M0NDUuOCwxNTAsNDQ2LjksMTQ5LjgsNDQ4LDE0OS44egoJCQkgTTQ0OC4xLDE1MC45Yy0wLjksMC0xLjcsMC4yLTIuNiwwLjdjLTAuOCwwLjUtMS40LDEuMS0xLjksMS45Yy0wLjUsMC44LTAuNywxLjctMC43LDIuNmMwLDEuNCwwLjUsMi43LDEuNSwzLjcKCQkJYzEsMSwyLjIsMS41LDMuNiwxLjVjMC45LDAsMS44LTAuMiwyLjYtMC43YzAuOC0wLjUsMS40LTEuMSwxLjktMS45YzAuNC0wLjgsMC43LTEuNywwLjctMi42YzAtMS0wLjItMS44LTAuNy0yLjYKCQkJYy0wLjQtMC44LTEuMS0xLjQtMS45LTEuOUM0NDkuOCwxNTEuMiw0NDksMTUwLjksNDQ4LjEsMTUwLjl6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ1OC41LDE1MC4xaDIuNGMxLDAsMS43LDAuMSwyLjIsMC4zYzAuNSwwLjIsMC45LDAuNiwxLjIsMS4xYzAuMywwLjUsMC40LDEsMC40LDEuNmMwLDAuNS0wLjEsMS0wLjQsMS41CgkJCWMtMC4zLDAuNC0wLjYsMC44LTEuMiwxLjFjMC42LDAuMiwxLjEsMC41LDEuNSwwLjhjMC4zLDAuMywwLjYsMC42LDAuOCwxYzAuMiwwLjQsMC4zLDAuOSwwLjMsMS4zYzAsMS0wLjQsMS44LTEuMSwyLjUKCQkJYy0wLjcsMC43LTEuNywxLTIuOSwxaC0zLjNWMTUwLjF6IE00NTkuNiwxNTEuM3YzLjloMC43YzAuOCwwLDEuNS0wLjEsMS45LTAuMmMwLjQtMC4yLDAuNy0wLjQsMC45LTAuN2MwLjItMC4zLDAuMy0wLjcsMC4zLTEuMQoJCQljMC0wLjYtMC4yLTEtMC42LTEuM2MtMC40LTAuMy0xLTAuNS0xLjktMC41SDQ1OS42eiBNNDU5LjYsMTU2LjR2NC43aDEuNWMwLjksMCwxLjUtMC4xLDEuOS0wLjNjMC40LTAuMiwwLjctMC40LDEtMC44CgkJCWMwLjMtMC40LDAuNC0wLjgsMC40LTEuMmMwLTAuNS0wLjItMS0wLjUtMS40Yy0wLjQtMC40LTAuOC0wLjctMS41LTAuOGMtMC40LTAuMS0xLjEtMC4xLTIuMi0wLjFINDU5LjZ6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ2OS41LDE1MC4xaDEuMnYxMi4xaC0xLjJWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3NSwxNTAuMWgxLjJ2MTFoNC43djEuMkg0NzVWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTQ4NC4zLDE1MC4xaDd2MS4yaC01Ljd2My44aDUuN3YxLjJoLTUuN3Y0LjhoNS43djEuMmgtNi45VjE1MC4xeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik00OTUuOSwxNjAuNGMwLjMsMCwwLjUsMC4xLDAuNywwLjNjMC4yLDAuMiwwLjMsMC40LDAuMywwLjdjMCwwLjMtMC4xLDAuNS0wLjMsMC43Yy0wLjIsMC4yLTAuNCwwLjMtMC43LDAuMwoJCQljLTAuMywwLTAuNS0wLjEtMC43LTAuM2MtMC4yLTAuMi0wLjMtMC40LTAuMy0wLjdjMC0wLjMsMC4xLTAuNSwwLjMtMC43QzQ5NS40LDE2MC41LDQ5NS43LDE2MC40LDQ5NS45LDE2MC40eiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik01MDYsMTU5LjlsMS0wLjZjMC43LDEuMywxLjYsMiwyLjUsMmMwLjQsMCwwLjgtMC4xLDEuMS0wLjNjMC40LTAuMiwwLjYtMC40LDAuOC0wLjhjMC4yLTAuMywwLjMtMC43LDAuMy0xCgkJCWMwLTAuNC0wLjEtMC44LTAuNC0xLjJjLTAuNC0wLjUtMS4xLTEuMi0yLjEtMS45Yy0xLTAuOC0xLjYtMS4zLTEuOS0xLjdjLTAuNC0wLjYtMC42LTEuMi0wLjYtMS45YzAtMC41LDAuMS0xLDAuNC0xLjQKCQkJYzAuMy0wLjQsMC42LTAuOCwxLjEtMWMwLjUtMC4yLDEtMC40LDEuNS0wLjRjMC42LDAsMS4xLDAuMSwxLjYsMC40YzAuNSwwLjMsMSwwLjgsMS42LDEuNmwtMSwwLjdjLTAuNS0wLjYtMC44LTEtMS4yLTEuMgoJCQljLTAuMy0wLjItMC43LTAuMy0xLjEtMC4zYy0wLjUsMC0wLjksMC4xLTEuMiwwLjRjLTAuMywwLjMtMC41LDAuNy0wLjUsMS4xYzAsMC4zLDAuMSwwLjUsMC4yLDAuOGMwLjEsMC4yLDAuMywwLjUsMC42LDAuOAoJCQljMC4yLDAuMiwwLjcsMC42LDEuNiwxLjJjMSwwLjgsMS44LDEuNSwyLjIsMi4xYzAuNCwwLjYsMC42LDEuMiwwLjYsMS44YzAsMC45LTAuMywxLjYtMSwyLjNjLTAuNywwLjYtMS41LDEtMi40LDEKCQkJYy0wLjcsMC0xLjQtMC4yLTItMC42QzUwNy4xLDE2MS41LDUwNi41LDE2MC45LDUwNiwxNTkuOXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTE3LDE1MC4xaDEuMnYxMi4xSDUxN1YxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTIyLDE2Mi4ybDEuNy0xMi4xaDAuMmw0LjksMTBsNC45LTEwaDAuMmwxLjcsMTIuMWgtMS4ybC0xLjItOC43bC00LjMsOC43aC0wLjNsLTQuMy04LjdsLTEuMiw4LjdINTIyeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik01MzkuNSwxNTAuMWgyLjRjMS40LDAsMi4zLDAuMSwyLjgsMC4yYzAuNywwLjIsMS4zLDAuNSwxLjcsMWMwLjQsMC41LDAuNywxLjIsMC43LDJjMCwwLjgtMC4yLDEuNS0wLjYsMgoJCQljLTAuNCwwLjUtMSwwLjktMS44LDEuMWMtMC41LDAuMS0xLjYsMC4yLTMuMSwwLjJoLTAuOXY1LjZoLTEuMlYxNTAuMXogTTU0MC44LDE1MS4zdjQuMWwyLjEsMGMwLjgsMCwxLjQtMC4xLDEuOC0wLjIKCQkJYzAuNC0wLjIsMC43LTAuNCwwLjktMC43YzAuMi0wLjMsMC4zLTAuNywwLjMtMS4xYzAtMC40LTAuMS0wLjgtMC4zLTEuMWMtMC4yLTAuMy0wLjUtMC42LTAuOS0wLjdjLTAuNC0wLjEtMS0wLjItMS44LTAuMkg1NDAuOHoKCQkJIi8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU1MS4xLDE1MC4xaDEuMnYxMWg0Ljd2MS4yaC01LjlWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU2MC4yLDE1MC4xaDEuMnYxMi4xaC0xLjJWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU2NS43LDE1MC4xaDYuMXYxLjJoLTQuOXYzLjhoNC45djEuMmgtNC45djZoLTEuMlYxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTc1LjMsMTUwLjFoMS4ydjEyLjFoLTEuMlYxNTAuMXoiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTgwLjgsMTUwLjFoNi45djEuMkg1ODJ2My44aDUuN3YxLjJINTgydjQuOGg1Ljd2MS4yaC02LjlWMTUwLjF6Ii8+CgkJPHBhdGggY2xhc3M9InN0MiIgZD0iTTU5MS4zLDE2Mi4ydi0xMi4xaDIuNWMxLjgsMCwzLjEsMC4xLDMuOSwwLjRjMS4yLDAuNCwyLjEsMS4xLDIuOCwyLjFjMC43LDEsMSwyLjIsMSwzLjYKCQkJYzAsMS4yLTAuMywyLjMtMC44LDMuMmMtMC41LDAuOS0xLjIsMS42LTIsMmMtMC44LDAuNC0yLDAuNy0zLjUsMC43SDU5MS4zeiBNNTkyLjUsMTYxaDEuNGMxLjcsMCwyLjgtMC4xLDMuNS0wLjMKCQkJYzAuOS0wLjMsMS42LTAuOCwyLjItMS42YzAuNS0wLjgsMC44LTEuNywwLjgtMi44YzAtMS4yLTAuMy0yLjItMC44LTNjLTAuNi0wLjgtMS40LTEuNC0yLjQtMS43Yy0wLjgtMC4yLTItMC4zLTMuOC0wLjNoLTAuOVYxNjEKCQkJeiIvPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik02MDYuNSwxNjAuNGMwLjMsMCwwLjUsMC4xLDAuNywwLjNjMC4yLDAuMiwwLjMsMC40LDAuMywwLjdjMCwwLjMtMC4xLDAuNS0wLjMsMC43Yy0wLjIsMC4yLTAuNCwwLjMtMC43LDAuMwoJCQljLTAuMywwLTAuNS0wLjEtMC43LTAuM2MtMC4yLTAuMi0wLjMtMC40LTAuMy0wLjdjMC0wLjMsMC4xLTAuNSwwLjMtMC43QzYwNiwxNjAuNSw2MDYuMiwxNjAuNCw2MDYuNSwxNjAuNHoiLz4KCTwvZz4KCTxnPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMzM4LjEsMTA1LjIgMzIyLjcsMTE4LjkgMjQyLjgsMTk2LjQgMjY5LjUsMTk2LjQgMzM3LjksMTMwLjYgNDA3LjEsMTk2LjQgNDMyLjgsMTk1LjQgMzUzLjMsMTE4LjgKCQkJMzM4LjEsMTA1LjIgCQkiLz4KCQk8Zz4KCQkJPHBhdGggY2xhc3M9InN0MyIgZD0iTTMzOC4xLDEwNS43bDEzLjQsMTNsNzksNzYuMmgtMjMuNGwtNjcuNS02NWwtMS44LTEuN2wtMS44LDEuN2wtNjcuNyw2NWgtMjMuNGw3OS4zLTc2LjFMMzM4LjEsMTA1LjcKCQkJCSBNMzM4LjEsMTAyLjJsLTE1LjQsMTQuOGwtODMuOSw4MC40aDMwLjdsNjguNC02NS43bDY4LjIsNjUuN2gzMC43bC04My41LTgwLjVMMzM4LjEsMTAyLjJMMzM4LjEsMTAyLjJ6Ii8+CgkJPC9nPgoJCTxnPgoJCQk8Zz4KCQkJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MzAuNSw5LjhsLTc5LDc2LjJsLTEzLjQsMTNsLTEzLjYtMTMuMUwyNDUuMSw5LjhoMjMuNGw2Ny43LDY1bDAuMiwwLjJjMC45LDAuOCwyLjIsMC44LDMuMSwwbDAuMi0wLjIKCQkJCQlsNjcuNS02NUg0MzAuNSBNMzIyLjcsODcuNyBNMzUzLjMsODcuNyIvPgoJCQk8L2c+CgkJCTxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik00MzAuNSw5LjhsLTc5LDc2LjJsLTEzLjQsMTNsLTEzLjYtMTMuMUwyNDUuMSw5LjhoMjMuNGw2Ny43LDY1bDAuMiwwLjJjMC45LDAuOCwyLjIsMC44LDMuMSwwbDAuMi0wLjIKCQkJCWw2Ny41LTY1SDQzMC41IE00MzYuOCw3LjJoLTMwLjdMMzM3LjksNzNMMjY5LjUsNy4yaC0zMC43bDgzLjksODAuNGwxNS40LDE0LjhsMTUuMi0xNC43TDQzNi44LDcuMkw0MzYuOCw3LjJ6Ii8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="), linear-gradient(transparent, transparent);
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center center
    }

    #orientation {
        width: 100%;
        height: 100%;
        position: fixed;
        top: 28px;
        left: 0;
        background-color: #000;
        background-image: url("data:image/jpeg;base64,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AAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgACOEJJTQQCAAAAAAAGAAAAAAAAOEJJTQQwAAAAAAADAQEBADhCSU0ELQAAAAAABgABAAAAAzhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAANLAAAABgAAAAAAAAAAAAAAuQAAATgAAAALAG8AcgBpAGUAbgB0AGEAdABpAG8AbgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAABOAAAALkAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAG51bGwAAAACAAAABmJvdW5kc09iamMAAAABAAAAAAAAUmN0MQAAAAQAAAAAVG9wIGxvbmcAAAAAAAAAAExlZnRsb25nAAAAAAAAAABCdG9tbG9uZwAAALkAAAAAUmdodGxvbmcAAAE4AAAABnNsaWNlc1ZsTHMAAAABT2JqYwAAAAEAAAAAAAVzbGljZQAAABIAAAAHc2xpY2VJRGxvbmcAAAAAAAAAB2dyb3VwSURsb25nAAAAAAAAAAZvcmlnaW5lbnVtAAAADEVTbGljZU9yaWdpbgAAAA1hdXRvR2VuZXJhdGVkAAAAAFR5cGVlbnVtAAAACkVTbGljZVR5cGUAAAAASW1nIAAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAC5AAAAAFJnaHRsb25nAAABOAAAAAN1cmxURVhUAAAAAQAAAAAAAG51bGxURVhUAAAAAQAAAAAAAE1zZ2VURVhUAAAAAQAAAAAABmFsdFRhZ1RFWFQAAAABAAAAAAAOY2VsbFRleHRJc0hUTUxib29sAQAAAAhjZWxsVGV4dFRFWFQAAAABAAAAAAAJaG9yekFsaWduZW51bQAAAA9FU2xpY2VIb3J6QWxpZ24AAAAH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MTM6NDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YmI3OTllNjYtYjZiYi0xMTc5LThiMjEtODEzN2VhNzc5OTdlIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4NDBjYmM1LTM5NzAtNDQxNS05MTkzLTg2YWUzNTIyOGQ5ZSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJBRDBGRDY4NkE4MEEwRjUyRDkzMzc4QzUxOTM4NjM2RCIgZGM6Zm9ybWF0PSJpbWFnZS9qcGVnIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0iIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxNi0wOS0wNlQwOTo1Nzo0MC0wNzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTYtMDktMDlUMTA6MDI6MzUtMDc6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTYtMDktMDlUMTA6MDI6MzUtMDc6MDAiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmOTdjYWMwYy1hODdlLTRhNTYtYjUwNC02MWYwOGQyYmIxMjEiIHN0RXZ0OndoZW49IjIwMTYtMDktMDlUMTA6MDI6MzUtMDc6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1LjUgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjk4NDBjYmM1LTM5NzAtNDQxNS05MTkzLTg2YWUzNTIyOGQ5ZSIgc3RFdnQ6d2hlbj0iMjAxNi0wOS0wOVQxMDowMjozNS0wNzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPHBob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8cmRmOkJhZz4gPHJkZjpsaSBwaG90b3Nob3A6TGF5ZXJOYW1lPSJSb3RhdGUgdG8gcGxheSIgcGhvdG9zaG9wOkxheWVyVGV4dD0iUm90YXRlIHRvIHBsYXkiLz4gPHJkZjpsaSBwaG90b3Nob3A6TGF5ZXJOYW1lPSJMYXllciAxIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIiLz4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+4AIUFkb2JlAGSAAAAAAQMAEAMCAwYAAAAAAAAAAAAA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");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center center;
        display: none
    }

    #btn-gettheapp {
        background: #589B5F !important;
        border-radius: 3px;
        -webkit-border-radius: 3;
        -moz-border-radius: 3;
        font-family: Muli, Arial, Helvetica, sans-serif;
        font-size: 14px;
        color: #fff;
        text-decoration: none;
        padding-left: 10px;
        padding-right: 10px;
        top: -1px;
        position: relative;
        height: 23px;
        vertical-align: middle;
        width: 98px;
        margin: 0 auto;
        line-height: 22px
    }

    .ageRatingIcon {
        max-height: 100%;
        width: auto;
        margin-left: 4px
    }

    @font-face {
        font-family: BAUHAUSB;
        src: url("data:;base64,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AO4A/gADAO0AGQADAOwAvQAbAAUA7AD+AAMA6wDoACUABQDrAJYAAwDqAP4AAwDpAOgAJUH/AAUA6QC7AAMA6AC9ABsABQDoACUAAwDnAD4AAwDmAPoAAwDlAP4AAwDkALQAZAAFAOQA/gADAOMA4gAJAAUA4wANAAMA4//2AAQA4gAJAAMA4v/mAAQA4QCWAAMA4AD+AAMA3QDcAA0ABQDdAP4AAwDcANsACQAFANwADQADANz/9AAEANsACQADANv/5gAEANoA/gADANkAvQAbAAUA2QCWAAMA2ADWACUABQDYAP4AAwDXANYAJQAFANcA+gADANYAJQADANUAuwADANQA/gADANMA0gApAAUA0wD+AAMA0gDRACQABQDSACkAAwDRANAAIQAFANEAJAADANAAzwAcAAUA0AAhAAMAzwAcAAMAzgDNAJYABQDOAPoAAwDNAJYAAwDMALsAAwDLAP4AAwDKAP4AAwDJAP4AAwDIAP4AAwDHAJYAAwDGAMUARwAFAMYA/gADAMUARwADAMQAwwAUAAUAxAD+AAMAwwAUAAMAwgDBAIwABQDCAP4AAwDCAMAABADBAMAAXQAFAMEAjAADAMEAgAAEAMAAvwAmAAUAwABdAAMAwABAAAQAvwAmAAMAvgC9ABsABQC+ALsAAwC9ABsAAwC8AK0AQQAFALwA/gADALsAtABkAAUAuwDIAAMAugD+AAMAuQD+AAMAuAC3ABQABQC4AP4AAwC3Qf8AFAADALYA/gADALUAtABkAAUAtQD6AAMAtABkAAMAsAD+AAMArwD+AAMArgCtAEEABQCuAP4AAwCtAEEAAwCsAP4AAwCrAP4AAwCqAP4AAwCpAP4AAwCoAP4AAwCnALsAAwCmALsAAwClAP4AAwCkAP4AAwCjAPoAAwCiAJYAAwChAJYAAwCgAP4AAwCfAP4AAwCeACUAAwCdAJwA/gAFAJwA/gADAJcA/gADAJYA/gADAJUAuwADAJQAuwADAJMA/gADAJIA/gADAJEA/gADAJAA/gADAI4AUwADAI0AfQADAIwA/gADAIoA+gADAIkA+gADAIgAUwADAIcA/gADAIYAEQAbAAUAhgD+AAMAhQD+AAMAhAD+AAMAgwD+AAMAggC7AAMAgQD+AAMAgAD+AAMAfwBTAAMAfgD+AAMAfQBrAAMAewD+AAMAeQC7AAMAdgD+AAMAdQD6AAMAdAATAAMAcwAUAAMAcgAKAAMAcgAMAAQAbwD+AAMAbgD6AAMAbQD+AAMAbAD+AAMAawC7AAMAagD6AAMAaQD6AAMAaABnABQABQBoAP4AAwBnABQAAwBiAPoAAwBhAP4AAwBgAP4AAwBfAP4AAwBeAF0ACgAFAF4A+gADAF0ACgADAFwAWwALAAUAXAD6AAMAWwALAAMAWwAMAAQAWgD+AANB/wBZAFgAEgAFAFkA/gADAFgAEgADAFcA/gADAFYA/gADAFUAfQADAFQAfQADAFMA+gADAFIA/gADAFEAlgADAFAAlgADAE8AIwBkAAUATwD6AAMATgD+AAMATQD+AAMATACWAAMASwD+AAMASgD+AAMASQBIAB8ABQBJAP4AAwBIAEcAGgAFAEgAHwADAEcAGgADAEYAlgADAEUA/gADAEQA/gADAEMA/gADAEIAQQAlAAUAQgD+AAMAQQARABsABQBBACUAAwBAAP4AAwA/APoAAwA+AP4AAwA9AH0AAwA8AP4AAwA7AJYAAwA6ADkANwAFADoA/gADADkANwADADgA/gADADcA/gADADYA/gADADUA/gADADQA/gADADMA/gADADIAMQBHAAUAMgD+AAMAMQBHAAMAMAD+AAMALwCWAAMALgD+AAMALQD+AAMALAD+AAMAKwCWAAMAKgApADIABQAqAP4AAwApADIAAwAoAP4AAwAnAP4AAwAmAP4AAwAlAP4AAwAkACMAZAAFACQA+gADACMAZAADACIA/gADACEA/gADACAA/gADAB8A/gADAB4AuwADAB0A/gADABwA/gADABsA/gADABoA+gADABkAlgADABcA/gADABYA/gADABUAuwADABQAEQAbAAUAFAD+AAMAEwASAJYABUFHABMA/gADABIAEQAbAAUAEgCWAAMAEQAbAAMAEAD+AAMADwD+AAMADgD+AAMADQC7AAMADAD+AAMACwD+AAMACgD+AAMACQAIADIABQAJAJYAAwAIADIAAwAHAP4AAwAGAAUAkQAFAAYA/gADAAUAkQADAAQAlgADAAIA/gADAAEA/gADAAAA/gADAAABZIWNASsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysAKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrHQAAQAcGBQQDAgEALCAQsAIlSWSwQFFYIMhZIS0ssAIlSWSwQFFYIMhZIS0sIBAHILAAULANeSC4//9QWAQbBVmwBRywAyUIsAQlI+EgsABQsA15ILj//1BYBBsFWbAFHLADJQjhLSxLUFgguAFtRURZIS0ssAIlRWBELSxLU1iwAiWwAiVFRFkhIS0sRUQtAAAAAAIAZv6WBGYFpAADAAcAKkEOAAQBawAAAAYBawABAAgABQCrAAIAXwAEAKsAAC/s9OwxABDU7NTsMBMRIRElIREhZgQA/HMDG/zl/pYHDvjycgYpAAIAg//lAhsFmAALAA8ALEAXDLADrwmuDawQDg8GDQAPAgwGAAAMARAQ5PTMEO4SORESOTEAEOT0/OwwNzQ2MzIWFRQGIyImEwMhA4N0V1d2eFVVdikbAXsYsFd2dldUd3cBcQPL/DUAAgBMA20CfwWeAAMABwAdQA4GArIEALEIAQMABAMFCBDc7NzsMQAQ9DzkMjABMxEjATMRIwGg39/+rNvbBZ79zwIx/c8AAAIAF//0BhAFugADAB8AVEA3ARAOHgoGsxwMABgUELMaDggEFhIgHx4dHBsaGBcWFRQTEhEQDw4NDAoJCAcGBQQDAgEAHgsZIBDUzBc5MQAQxDLEMtQ87DIy3Dw87DIyERI5MAEHMzcBMwMzEzMDIQchByEHIQMjEyMDIxMhNyE3ITchAsNS9VL+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AC8Atv+QAC8At/+IADIAD/+tADIAEAA5ADIAEf+tADIAHQAmADIAHgAmADIAOf/cADIAO/+QADIAPP/cADIAtf/cADIAt//cADIAxP+QADIAxf+QADMAD/7TADMAEP/TADMAEf7TADMAHf+kADMAHv+kADMAOv/cADMAPP+3ADMARP+QADMASP+3ADMATP/cADMAUf+QADMAUv+QADMAVf/cADMAVv+3ADMAoP+QADMAof+QADMAqf+QADMAqv+QADMAsf+QADMAtAAmADMAtQAvADMAtgAmADMAtwAvADMAvv+QADMAv/+QADMAxP6tADMAxf6tADQAEAA5ADUAPP/cADUARAAmADUAWAAmADUAoAAmADUAtP/cADUAtf/cADUAtv/cADUAt//cADYAJP/cADYAY//cADcAD/9rADcAEP9EADcAEf9rADcAHf99ADcAHv99ADcAJP/cADcAJv+3ADcANwA5ADcARP99ADcARv+kADcASP+kADcAUv+kADcAVf99ADcAVv+kADcAWP99ADcAWv+kADcAXP99ADcAY//cADcAoP99ADcAof+kADcAqf+QADcAqv+QADcAsf+kADcAtAByADcAtgByADcAvv+QADcAv/+QADcAxP+QADcAxf+QADkAD/9rADkAEf9rADkAHf91ADkAHv91ADkAMv/cADkARP+QADkASP/cADkAUv+QADkAWP/cADkAXP+kADkAkf/cADkAoP+QADkAof+QADkAqf9rADkAqv+QADkAsP/cADkAsf+QADkAtQA5ADkAtwA5ADkAvv9rADkAv/+QADkAxP6tADkAxf6tADoAD//BADoAEf/BADoAHf/TADoAHv/TADoARP/cADoAVf+3ADoAXP/cADoAoP/cADoAqf+QADoAqv+QADoAtABLADoAtQAmADoAtgBLADoAtwAmADoAvv+QADoAv/+QADoAxP9rADoAxf9rADsAEP+aADsAJP/cADsAJv/cADsAMv+QADsANwAmADsASP/cADsAY//cADsAkf+QADsAqf+QADsAsP+QADsAtP+3ADsAtf+3ADsAtv+3ADsAt/+3ADsAvv+QADsAxAByADsAxQByADwAD/88ADwAEP99ADwAEf88ADwAHf/BADwAHv/BADwAJP/cADwAJv+3ADwAMv/cADwARP+3ADwASP+QADwATP/cADwAUv9EADwAWP/BADwAY//cADwAkf/cADwAoP+3ADwAof9EADwAqf8fADwAqv9rADwAsP/cADwAsf9EADwAvv8fADwAv/9rADwAxP74ADwAxf74AD0AEP/cAD0AtP/cAD0Atv/cAEkAD/+3AEkAEf+3AEkAVwAmAEkAWgAmAEkAtAC0AEkAtQCNAEkAtgC0AEkAtwCNAE4ARAAmAE4ASAAmAE4AUgAmAE4AoAAmAE4AoQAmAE4AsQAmAFEAtP+QAFEAtf+QAFEAtv+QAFEAt/+QAFIAEAAmAFIAtP+3AFIAtv+3AFUAD/8yAFUAEP+3AFUAEf8yAFUARgAmAFUARwAmAFUASAAmAFUASQAmAFUASgAmAFUAUgAmAFUAVAAmAFUAWQAmAFUAWgAmAFUAoQAmAFUAqf/cAFUAsQAmAFUAtQBWAFUAtwBWAFUAvv/cAFUAwAAmAFUAwQAmAFUAxP/TAFUAxf/TAFUBAQAmAFkAD/9hAFkAEf9hAFkAtABeAFkAtQByAFkAtgBeAFkAtwByAFkAxP8VAFkAxf8VAFoAD//cAFoAEAAmAFoAEf/cAFoAtAA5AFoAtQByAFoAtgA5AFoAtwByAFoAxP9hAFoAxf9hAFwAEP/cAFwAtAByAFwAtQByAFwAtgByAFwAtwByAFwAxAAmAFwAxQAmAGMAEP/TAGMAHQAmAGMAHgAmAGMAJv/cAGMAKv/cAGMANP/cAGMANv/cAGMAN//cAGMAPP/cAGMAWQAmAGMAWv/cAGMAqf+3AGMAtP/cAGMAtf/JAGMAtv/cAGMAt//JAGMAvv+3AGMAxAAmAGMAxQAmAIkAEABLAIkAtP/cAIkAtv/cAJAAEAAmAJEAD/+tAJEAEAA5AJEAEf+tAJEAHQAmAJEAHgAmAJEAOf/cAJEAO/+QAJEAPP/cAJEAtf/cAJEAt//cAJEAxP+QAJEAxf+QAKEAEAAmAKEAtP+3AKEAtv+3AKkALQAmAKkAN/+QAKkAOf+QAKkAOv+QAKkAPP9rAKoAJP+3AKoALQBLAKoAN/+QAKoAOf9rAKoAOv+QAKoAO/+QAKoAPP8fAKoAY/+3ALQAJP+tALQAJv+3ALQAKv+3ALQALf7wALQAMv+tALQANP/cALQANwAmALQAOQA5ALQAOgAvALQAPABBALQASQA5ALQAVf+QALQAWQA5ALQAY/+tALQAkP+kALQAkf+tALQAsP+tALQAwAA5ALQAwQA5ALYAJP+tALYAJv+3ALYAKv+3ALYALf7wALYAMv+tALYANP/cALYANwAmALYAOQA5ALYAOgAvALYAPABBALYASQA5ALYAVf+QALYAWQA5ALYAY/+tALYAkP+kALYAkf+tALYAsP+tALYAwAA5ALYAwQA5AL4ALQAmAL4AN/+QAL4AOf+QAL4AOv+QAL4APP9rAL8AJP+3AL8ALQBLAL8AN/+QAL8AOf9rAL8AOv+QAL8AO/+QAL8APP8fAL8AY/+3AMQAJv+QAMQAKv+3AMQALQAmAMQAMv+QAMQANP+QAMQAN/8yAMQAOf9EAMQAOv91AMQAPP8fAMQASQAmAMQAWf+tAMQAWv+tAMQAiQAmAMQAkABLAMQAkf+QAMQAsP+QAMQAwAAmAMQAwQAmAMUAJv+QAMUAKv+3AMUALQAmAMUAMv+QAMUANP+QAMUAN/8yAMUAOf9EAMUAOv91AMUAPP8fAMUASQAmAMUAWf+tAMUAWv+tAMUAiQAmAMUAkABLAMUAkf+QAMUAsP+QAMUAwAAmAMUAwQAmAOIAEP/cAOIAMv+3AOIAN/+QAOIAOP/cAOIAOf+QAOIAPP/cAOIARAAmAOIASAAmAOIAUgAmAOIAkf+3AOIAoAAmAOIAoQAmAOIAsP+3AOIAsQAmAOIAtP+QAOIAtf+IAOIAtv+QAOIAt/+IAOkAEABBAOkAJP/cAOkAOf/cAOkAOv/cAOkAPP+3AOkAY//cAOkAtP/cAOkAtf/cAOkAtv/cAOkAt//cAOkAxP9EAOkAxf9EAAAAAQAAAQQAVAAHAEEABAACABAAQAAHAAAKhADKAAMAAQABAAAAAQABsKDap18PPPUAAAgAAAAAAKgcQJkAAAAAqBxAmf6q/h0J4weuAAEABgABAAAAAAAAAAEAAAeu/h0AAAov/qr+rAnjAAEAAAAAAAAAAAAAAAAAAAEEAAADkQK8AAUADgVHBMwAAP5UBUcEzAAAAj0A3wJmCAQEAwgFAgsCAgwDAAAAAAAAAAAAAAAAAAAAAEJpdHMAIAAg8AIGFAHsAZoHrgHjAAAAAQAAQgABmAJCA/cAACBKBZgAAEJhdWhhdXMgQmQAAAAAAAD/////Nv///jA2MEIwMAMAQAAAAA==")
    }</style>

    <script type="text/javascript">
        var ad_name = "rafo_piggy";
        var ad_title = "Piggy Boom";
        var ad_click_dest = "https://itunes.apple.com/app/id1129050711";
        var ad_orientation = "portrait";
        var ad_webroot = "https://cdn.unityads.unity3d.com/playables/piggy_ios";
        var ad_logroot = "";
        var ad_has_custom_load_screen = false;
        var ad_close_duration = 30000;
        var ad_close_countdown = false;
        var ad_exchange = "mopub";
        var ad_getapp_instead_of_title = false;
        var ad_dynamic_parameters = "";
        var ad_advertising_label_lang = "";
        var ad_show_age_ratings = "";
    </script>
    <script type='text/javascript'>function LP(t, e) {
        return "landscape" === ad_orientation ? t : e
    }
    function setupMraid(t) {
        body_width = document.body.offsetWidth, body_height = document.body.offsetHeight, console.log("BODY SIZE", body_width), "none" != ad_close_position && mraid.useCustomClose(!0), time_mraid_ready = (new Date).getTime(), genlog_time_since(time_wrapper_start, "time_mraid_ready"), console.log("setupMraid - start"), genlog("funnel", "setupMraid." + t), registerMraidHandlers(mraid), showAd(), console.log("setupMraid - end")
    }
    function genlog_time_since(t, e) {
        if(t) {
            var i = bucket_time_since(t);
            "rubicon" == ad_exchange && (e = "rubicon." + e), genlog(e, i)
        }
    }
    function registerMraidHandlers(t) {
        console.log("registerMraidHandlers - start"), t.setOrientationProperties({
            allowOrientationChange: !1,
            forceOrientation: ad_orientation
        }), t.addEventListener("viewableChange", function(e) {
            console.log("viewable changed to: " + e + " (" + typeof e + ")"), genlog("mraidviewable", e), t.isViewable() && (console.log("showAd (viewable listener): calling"), showAd())
        }), t.addEventListener("error", function(t, e) {
            console.log("mraid error.  message: " + t + "   action: " + e), log_remote("mraid_error", "message: " + t + "   action: " + e)
        }), t.addEventListener("stateChange", function(t) {
            if(console.log("stateChange: " + t), genlog("mraidstate", t), "expanded" == t)return genlog("mraidstate", t + "_avert"), !1;
            switch(t) {
                case"hidden":
                    break;
                case"expanded":
                    console.log("Toggle to: Expanded"), wrapper_toggle_layer("ad_banner", "ad_expanded"), showAd(!0);
                    break;
                case"default":
                    console.log("Toggle to: Default"), wrapper_toggle_layer("ad_expanded", "ad_banner")
            }
        }), console.log("registerMraidHandlers - end")
    }
    function wrapper_click_go(t) {
        genlog("funnel", "click_go");
        var e = ad_click_dest;
        e += "adex" == ad_exchange ? "" : "", t && !isObject(t) && (e += "." + t.toString()), localization && (e += ""), console.log("clicked; going to click destination: " + e), mraid.open(e)
    }
    function isObject(t) {
        return null !== t && ("function" == typeof t || "object" == typeof t)
    }
    function showCloseButtonCountdown() {
        if(!close_button_showing && "none" != ad_close_position) {
            var t = close_button_time_remaining / 1e3, e = document.getElementById("close_timer");
            e && (e.innerHTML = t);
            var i = document.createAttribute("style");
            i.value = "display:block", e && e.setAttributeNode(i), close_button_time_remaining -= 1e3, close_button_time_remaining > 0 && setTimeout(function() {
                showCloseButtonCountdown()
            }, 1e3)
        }
    }
    function showCloseButton() {
        if("none" != ad_close_position) {
            genlog("render", "showCloseButton");
            var t = document.getElementById("close_timer"), e = document.createAttribute("style");
            e.value = "display:none", t.setAttributeNode(e);
            var i = document.getElementById("close_zone"), n = document.createAttribute("style");
            n.value = "display:block", i.setAttributeNode(n), i.onclick = function() {
                return genlog("funnel", "close"), mraid.close(), !1
            }, close_button_showing = !0
        }
    }
    function showAd() {
        if(console.log("showAd"), (!ad_expandable || force_full) && (console.log("showAd - full"), query_params.dev_nomraid || mraid.isViewable())) {
            time_mraid_viewable = (new Date).getTime(), genlog_time_since(time_mraid_ready, "time_mraid_viewable"), console.log("showAd - viewable"), genlog("funnel", "viewable");
            var t = document.getElementById("ad");
            if(t) {
                console.log("has ad div; setting style display:block");
                var e = document.createAttribute("style");
                e.value = "display:block", t.setAttributeNode(e)
            }
            if(wrapper_splash_shadows_start(), setTimeout(function() {
                    showCloseButton()
                }, ad_close_duration), close_button_timeout_id = setTimeout(function() {
                    showCloseButton()
                }, ad_close_duration), ad_close_countdown && (close_button_time_remaining = ad_close_duration, showCloseButtonCountdown()), console.log("ad_begin: calling"), "ready" != ad_state) {
                ad_state = "ready";
                try {
                    ad_begin()
                } catch(i) {
                }
            }
            genlog("lang", localization.getLanguage())
        }
    }
    function wrapper_preload_complete() {
        time_app_preload_complete = (new Date).getTime(), genlog_time_since(time_wrapper_start, "time_app_preload")
    }
    function wrapper_load_progress(t) {
        fitTitle();
        var e = document.getElementById("splash_loading_bar") || document.getElementById("splash_loading_bar_full");
        if(e) {
            var i = document.createAttribute("style");
            i.value = "width:" + Math.floor(135 * t / 100) + "px", e.setAttributeNode(i), e.style.width = Math.floor(133 * t / 100) + "px"
        }
    }
    function wrapper_hide_splash() {
        if(null === time_app_start) {
            wrapper_load_progress(100);
            var t;
            time_app_start = (new Date).getTime(), genlog_time_since(time_mraid_viewable, "time_app_start"), genlog("funnel", "hide_splash");
            var e = document.getElementById("splash");
            e && (t = document.createAttribute("style"), t.value = "display:none", e.setAttributeNode(t));
            var i = document.getElementById("ad_header_logo");
            i && (t = document.createAttribute("style"), t.value = "display:block", i.setAttributeNode(t)), console.log("close duration:", ad_close_duration), close_button_timeout_id && (clearTimeout(close_button_timeout_id), close_button_timeout_id = null), isSplashHidden = !0, wrapper_cleanup()
        }
    }
    function wrapper_mark_interaction() {
        return hadFirstInteraction ? hadSecondInteraction ? hadThirdInteraction ? void 0 : (genlog("funnel", "third_interaction"), void(hadThirdInteraction = !0)) : (genlog("funnel", "second_interaction"), void(hadSecondInteraction = !0)) : (genlog("funnel", "first_interaction"), void(hadFirstInteraction = !0))
    }
    function wrapper_mark_cta(t) {
        var e = "cta";
        t && (e += "." + t.toString()), genlog("funnel", e)
    }
    function log_remote(t, e) {
    }
    function genlog(t, e) {
    }
    function genlog_time_since(t, e) {
        if(t) {
            var i = bucket_time_since(t);
            genlog(e, i)
        }
    }
    function bucket_time_since(t) {
        var e = (new Date).getTime(), i = e - t, n = get_bucket(i, 0, 1e4, 40), s = "[";
        return s += n.start == Number.NEGATIVE_INFINITY ? "-inf" : n.start, n.start != n.end && (s += " to ", s += n.end == Number.POSITIVE_INFINITY ? "+inf" : n.end), s += "]"
    }
    function bucketObj() {
        this.offset = null, this.start = null, this.end = null, this.width = null
    }
    function get_bucket(t, e, i, n) {
        var s = new bucketObj;
        if(s.width = (i - e) / n, t <= e || i == e) s.offset = 0, s.start = Number.NEGATIVE_INFINITY, s.end = e + s.width; else if(t >= i) s.offset = n - 1, s.start = i - s.width, s.end = Number.POSITIVE_INFINITY; else {
            var r = n * (t - e) / (i - e), o = Math.floor(r);
            s.offset = Math.round(o), s.start = e + s.offset * s.width, s.end = s.start + s.width
        }
        return 0 === s.offset && (s.start = Number.NEGATIVE_INFINITY), s.offset == n - 1 && (s.end = Number.POSITIVE_INFINITY), s
    }
    function getAdvertisingLabel() {
        return "" !== ad_advertising_label_lang ? " - " + advertisingLabels[ad_advertising_label_lang] : ""
    }
    function getAgeRating() {
        return "" !== ad_show_age_ratings ? '<img class="ageRatingIcon" src="/global_v2/img/age_ratings/' + ageRatingImages[ad_show_age_ratings] + '"/>' : ""
    }
    function wrapper_splash_shadows_start() {
        var t = document.getElementById("splash");
        if(t) {
            for(var e = 0; e < bgNumShadows; e++) {
                var i = document.createElement("div");
                i.id = "bgShadow" + e;
                var n = 50 + e * Math.floor(150 / bgNumShadows);
                i.style.width = n + "px", i.style.height = Math.floor(n / 5) + "px";
                var s = 3 * Math.floor((200 - n) / 20) + 1;
                10 == s && (s = "A"), 11 == s && (s = "B"), 12 == s && (s = "C"), 13 == s && (s = "D"), 14 == s && (s = "E"), 15 == s && (s = "F"), s > 15 && (s = "E"), i.className = "bg-shadow", i.style.background = "#2" + s + "2" + s + "2" + s, i.style.borderRadius = Math.floor(n / 2) + "px", i.style.position = "absolute", i.style.zIndex = 1, void 0 !== body_width && void 0 !== body_height ? (i.style.left = -100 + Math.floor(Math.random() * (body_width + 1)) + "px", i.style.top = 50 + Math.floor(Math.random() * (body_height + 1)) + "px") : (i.style.left = -100 + Math.floor(Math.random() * (gameWidth + 1)) + "px", i.style.top = 50 + Math.floor(Math.random() * (gameHeight + 1)) + "px"), t.insertBefore(i, t.firstChild)
            }
            setTimeout(wrapper_splash_shadows_move, 20)
        }
    }
    function wrapper_splash_shadows_move() {
        if(!isSplashHidden) {
            for(var t = 0; t < bgNumShadows; t++) {
                var e = document.getElementById("bgShadow" + t), i = parseInt(e.style.left),
                    n = parseInt(e.style.width);
                i += Math.floor((200 - n) / 15) + 1, i > body_width + 200 && (i = -200), e.style.left = i + "px"
            }
            setTimeout(wrapper_splash_shadows_move, 20)
        }
    }
    function fitTitle() {
        for(var t = document.getElementById("ad_title"), e = 1.25; t.scrollHeight > 28 && e > .5;) {
            e -= .1;
            var i = document.createAttribute("style");
            i.value = "font-size: " + e + "em;line-height: " + e + "em", t.setAttributeNode(i)
        }
    }
    function wrapper_expand() {
        console.log("wrapper expanded"), genlog("funnel", "expand"), mraid.expand()
    }
    function wrapper_toggle_layer(t, e) {
        var i = document.getElementById(t);
        i && (i.style.display = "none");
        var n = document.getElementById(e);
        n && (n.style.display = "")
    }
    function wrapper_cleanup() {
        var t = document.getElementById("splash");
        t && (t.parentNode.removeChild(t), console.log("wrapper - cleanup"))
    }
    (function() {
        var t = this, e = e || {};
        return e.game = null, e.CANVAS_RENDERER = 1, e.VERSION = "v2.2.9", e._UID = 0, "undefined" != typeof Float32Array ? (e.Float32Array = Float32Array, e.Uint16Array = Uint16Array, e.Uint32Array = Uint32Array, e.ArrayBuffer = ArrayBuffer) : (e.Float32Array = Array, e.Uint16Array = Array), e.PI_2 = 2 * Math.PI, e.RAD_TO_DEG = 180 / Math.PI, e.DEG_TO_RAD = Math.PI / 180, e.RETINA_PREFIX = "@2x", e.DisplayObject = function() {
            this.position = new e.Point(0, 0), this.scale = new e.Point(1, 1), this.pivot = new e.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new e.Matrix, this.worldPosition = new e.Point(0, 0), this.worldScale = new e.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new e.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, e.DisplayObject.prototype.constructor = e.DisplayObject, e.DisplayObject.prototype = {
            destroy: function() {
                if(this.children) {
                    for(var t = this.children.length; t--;)this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            }, updateTransform: function(t) {
                if(!t && !this.parent && !this.game)return this;
                var i = this.parent;
                t ? i = t : this.parent || (i = this.game.world);
                var n, s, r, o, a, h, l = i.worldTransform, c = this.worldTransform;
                return this.rotation % e.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), n = this._cr * this.scale.x, s = this._sr * this.scale.x, r = -this._sr * this.scale.y, o = this._cr * this.scale.y, a = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * n + this.pivot.y * r, h -= this.pivot.x * s + this.pivot.y * o), c.a = n * l.a + s * l.c, c.b = n * l.b + s * l.d, c.c = r * l.a + o * l.c, c.d = r * l.b + o * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty) : (n = this.scale.x, o = this.scale.y, a = this.position.x - this.pivot.x * n, h = this.position.y - this.pivot.y * o, c.a = n * l.a, c.b = n * l.b, c.c = o * l.c, c.d = o * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty), this.worldAlpha = this.alpha * i.worldAlpha, this.worldPosition.set(c.tx, c.ty), this.worldScale.set(this.scale.x * Math.sqrt(c.a * c.a + c.c * c.c), this.scale.y * Math.sqrt(c.b * c.b + c.d * c.d)), this.worldRotation = Math.atan2(-c.c, c.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, c, l), this
            }, preUpdate: function() {
            }, generateTexture: function(t, i, n) {
                var s = this.getLocalBounds(), r = new e.RenderTexture(0 | s.width, 0 | s.height, n, i, t);
                return e.DisplayObject._tempMatrix.tx = -s.x, e.DisplayObject._tempMatrix.ty = -s.y, r.render(this, e.DisplayObject._tempMatrix), r
            }, updateCache: function() {
                return this._generateCachedSprite(), this
            }, toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            }, toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            }, _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, e.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            }, _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if(t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height); else {
                    var i = new e.RenderTexture(t.width, t.height);
                    this._cachedSprite = new e.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
                }
                var n = this._filters;
                this._filters = null, this._cachedSprite.filters = n, e.DisplayObject._tempMatrix.tx = -t.x, e.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, e.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -(t.x / t.width), this._cachedSprite.anchor.y = -(t.y / t.height), this._filters = n, this._cacheAsBitmap = !0
            }, _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            }
        }, e.DisplayObject.prototype.displayObjectUpdateTransform = e.DisplayObject.prototype.updateTransform, Object.defineProperties(e.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                }, set: function(t) {
                    this.position.x = t
                }
            }, y: {
                get: function() {
                    return this.position.y
                }, set: function(t) {
                    this.position.y = t
                }
            }, worldVisible: {
                get: function() {
                    if(this.visible) {
                        var t = this.parent;
                        if(!t)return this.visible;
                        do {
                            if(!t.visible)return !1;
                            t = t.parent
                        } while(t);
                        return !0
                    }
                    return !1
                }
            }, mask: {
                get: function() {
                    return this._mask
                }, set: function(t) {
                    this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                }
            }, filters: {
                get: function() {
                    return this._filters
                }, set: function(t) {
                    if(Array.isArray(t)) {
                        for(var i = [], n = 0; n < t.length; n++)for(var s = t[n].passes,
                                                                         r = 0; r < s.length; r++)i.push(s[r]);
                        this._filterBlock = {target: this, filterPasses: i}
                    }
                    this._filters = t, this.blendMode && this.blendMode === e.blendModes.MULTIPLY && (this.blendMode = e.blendModes.NORMAL)
                }
            }, cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                }, set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), e.DisplayObjectContainer = function() {
            e.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype), e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer, e.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, e.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if(e >= 0 && e <= this.children.length)return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, e.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if(t !== e) {
                var i = this.getChildIndex(t), n = this.getChildIndex(e);
                if(i < 0 || n < 0)throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[n] = t
            }
        }, e.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if(e === -1)throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }, e.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if(e < 0 || e >= this.children.length)throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, e.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if(t < 0 || t >= this.children.length)throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, e.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if(e !== -1)return this.removeChildAt(e)
        }, e.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, e.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            var i = e - t;
            if(i > 0 && i <= e) {
                for(var n = this.children.splice(begin, i), s = 0; s < n.length; s++) {
                    var r = n[s];
                    r.parent = void 0
                }
                return n
            }
            if(0 === i && 0 === this.children.length)return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, e.DisplayObjectContainer.prototype.updateTransform = function() {
            if(this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))for(var t = 0; t < this.children.length; t++)this.children[t].updateTransform()
        }, e.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = e.DisplayObjectContainer.prototype.updateTransform, e.DisplayObjectContainer.prototype.getBounds = function(t) {
            var i = t && t instanceof e.DisplayObject, n = !0;
            i ? n = t instanceof e.DisplayObjectContainer && t.contains(this) : t = this;
            var s;
            if(i) {
                var r = t.worldTransform;
                for(t.worldTransform = e.identityMatrix, s = 0; s < t.children.length; s++)t.children[s].updateTransform()
            }
            var o, a, h, l = 1 / 0, c = 1 / 0, u = -(1 / 0), d = -(1 / 0), p = !1;
            for(s = 0; s < this.children.length; s++) {
                var f = this.children[s];
                f.visible && (p = !0, o = this.children[s].getBounds(), l = l < o.x ? l : o.x, c = c < o.y ? c : o.y, a = o.width + o.x, h = o.height + o.y, u = u > a ? u : a, d = d > h ? d : h)
            }
            var g = this._bounds;
            if(!p) {
                g = new e.Rectangle;
                var m = g.x, y = g.width + g.x, v = g.y, x = g.height + g.y, _ = this.worldTransform, b = _.a, w = _.b,
                    T = _.c, P = _.d, C = _.tx, S = _.ty, I = b * y + T * x + C, O = P * x + w * y + S,
                    A = b * m + T * x + C, M = P * x + w * m + S, k = b * m + T * v + C, E = P * v + w * m + S,
                    R = b * y + T * v + C, D = P * v + w * y + S;
                u = I, d = O, l = I, c = O, l = A < l ? A : l, l = k < l ? k : l, l = R < l ? R : l, c = M < c ? M : c, c = E < c ? E : c, c = D < c ? D : c, u = A > u ? A : u, u = k > u ? k : u, u = R > u ? R : u, d = M > d ? M : d, d = E > d ? E : d, d = D > d ? D : d
            }
            if(g.x = l, g.y = c, g.width = u - l, g.height = d - c, i)for(t.worldTransform = r, s = 0; s < t.children.length; s++)t.children[s].updateTransform();
            if(!n) {
                var L = t.getBounds();
                g.x -= L.x, g.y -= L.y
            }
            return g
        }, e.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, e.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, e.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if(this.visible !== !1 && 0 !== this.alpha) {
                if(this._cacheAsBitmap)return void this._renderCachedSprite(t);
                this._mask && t.maskManager.pushMask(this._mask, t);
                for(var e = 0; e < this.children.length; e++)this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, Object.defineProperty(e.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            }, set: function(t) {
                var e = this.getLocalBounds().width;
                0 !== e ? this.scale.x = t / e : this.scale.x = 1, this._width = t
            }
        }), Object.defineProperty(e.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            }, set: function(t) {
                var e = this.getLocalBounds().height;
                0 !== e ? this.scale.y = t / e : this.scale.y = 1, this._height = t
            }
        }), e.Sprite = function(t) {
            e.DisplayObjectContainer.call(this), this.anchor = new e.Point, this.texture = t || e.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = e.blendModes.NORMAL, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Sprite.prototype.constructor = e.Sprite, Object.defineProperty(e.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            }, set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(e.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            }, set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), e.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, e.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, e.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width, i = this.texture.frame.height, n = e * (1 - this.anchor.x),
                s = e * -this.anchor.x, r = i * (1 - this.anchor.y), o = i * -this.anchor.y,
                a = t || this.worldTransform, h = a.a, l = a.b, c = a.c, u = a.d, d = a.tx, p = a.ty, f = -(1 / 0),
                g = -(1 / 0), m = 1 / 0, y = 1 / 0;
            if(0 === l && 0 === c) {
                if(h < 0) {
                    h *= -1;
                    var v = n;
                    n = -s, s = -v
                }
                if(u < 0) {
                    u *= -1;
                    var v = r;
                    r = -o, o = -v
                }
                m = h * s + d, f = h * n + d, y = u * o + p, g = u * r + p
            } else {
                var x = h * s + c * o + d, _ = u * o + l * s + p, b = h * n + c * o + d, w = u * o + l * n + p,
                    T = h * n + c * r + d, P = u * r + l * n + p, C = h * s + c * r + d, S = u * r + l * s + p;
                m = x < m ? x : m, m = b < m ? b : m, m = T < m ? T : m, m = C < m ? C : m, y = _ < y ? _ : y, y = w < y ? w : y, y = P < y ? P : y, y = S < y ? S : y, f = x > f ? x : f, f = b > f ? b : f, f = T > f ? T : f, f = C > f ? C : f, g = _ > g ? _ : g, g = w > g ? w : g, g = P > g ? P : g, g = S > g ? S : g
            }
            var I = this._bounds;
            return I.x = m, I.width = f - m, I.y = y, I.height = g - y, this._currentBounds = I, I
        }, e.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = e.identityMatrix;
            for(var i = 0; i < this.children.length; i++)this.children[i].updateTransform();
            var n = this.getBounds();
            for(this.worldTransform = t, i = 0; i < this.children.length; i++)this.children[i].updateTransform();
            return n
        }, e.Sprite.prototype._renderCanvas = function(t, i) {
            if(!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var n = this.worldTransform;
                if(i && (n = i), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                    var s = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === e.scaleModes.LINEAR);
                    var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        a = n.tx * t.resolution + t.shakeX, h = n.ty * t.resolution + t.shakeY;
                    t.roundPixels ? (t.context.setTransform(n.a, n.b, n.c, n.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(n.a, n.b, n.c, n.d, a, h);
                    var l = this.texture.crop.width, c = this.texture.crop.height;
                    if(r /= s, o /= s, 16777215 !== this.tint) (this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = e.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / s, c / s); else {
                        var u = this.texture.crop.x, d = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, u, d, l, c, r, o, l / s, c / s)
                    }
                }
                for(var p = 0; p < this.children.length; p++)this.children[p]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, e.SpriteBatch = function(t) {
            e.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
        }, e.SpriteBatch.prototype = Object.create(e.DisplayObjectContainer.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }, e.SpriteBatch.prototype._renderCanvas = function(t) {
            if(this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for(var i = this.worldTransform, n = !0, s = 0; s < this.children.length; s++) {
                    var r = this.children[s];
                    if(r.visible) {
                        var o = r.texture, a = o.frame;
                        if(e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) === 0) n && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), n = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y); else {
                            n || (n = !0), r.displayObjectUpdateTransform();
                            var h = r.worldTransform, l = h.tx * t.resolution + t.shakeX,
                                c = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                        }
                    }
                }
            }
        }, e.hex2rgb = function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        }, e.rgb2hex = function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        }, e.canUseNewCanvasBlendModes = function() {
            if(void 0 === document)return !1;
            var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                i = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==", n = new Image;
            n.src = t + "AP804Oa6" + i;
            var s = new Image;
            s.src = t + "/wCKxvRF" + i;
            var r = e.CanvasPool.create(this, 6, 1), o = r.getContext("2d");
            if(o.globalCompositeOperation = "multiply", o.drawImage(n, 0, 0), o.drawImage(s, 2, 0), !o.getImageData(2, 0, 1, 1))return !1;
            var a = o.getImageData(2, 0, 1, 1).data;
            return e.CanvasPool.remove(this), 255 === a[0] && 0 === a[1] && 0 === a[2]
        }, e.getNextPowerOfTwo = function(t) {
            if(t > 0 && 0 === (t & t - 1))return t;
            for(var e = 1; e < t;)e <<= 1;
            return e
        }, e.isPowerOfTwo = function(t, e) {
            return t > 0 && 0 === (t & t - 1) && e > 0 && 0 === (e & e - 1)
        }, e.CanvasPool = {
            create: function(t, i, n) {
                var s, r = e.CanvasPool.getFirst();
                if(r === -1) {
                    var o = {parent: t, canvas: document.createElement("canvas")};
                    e.CanvasPool.pool.push(o), s = o.canvas
                } else e.CanvasPool.pool[r].parent = t, s = e.CanvasPool.pool[r].canvas;
                return void 0 !== i && (s.width = i, s.height = n), s
            }, getFirst: function() {
                for(var t = e.CanvasPool.pool, i = 0; i < t.length; i++)if(!t[i].parent)return i;
                return -1
            }, remove: function(t) {
                for(var i = e.CanvasPool.pool,
                        n = 0; n < i.length; n++)i[n].parent === t && (i[n].parent = null, i[n].canvas.width = 1, i[n].canvas.height = 1)
            }, removeByCanvas: function(t) {
                for(var i = e.CanvasPool.pool,
                        n = 0; n < i.length; n++)i[n].canvas === t && (i[n].parent = null, i[n].canvas.width = 1, i[n].canvas.height = 1)
            }, getTotal: function() {
                for(var t = e.CanvasPool.pool, i = 0, n = 0; n < t.length; n++)t[n].parent && i++;
                return i
            }, getFree: function() {
                for(var t = e.CanvasPool.pool, i = 0, n = 0; n < t.length; n++)t[n].parent || i++;
                return i
            }
        }, e.CanvasPool.pool = [], e.glContexts = [], e.instances = [], e.CanvasBuffer = function(t, i) {
            this.width = t, this.height = i, this.canvas = e.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = i
        }, e.CanvasBuffer.prototype.constructor = e.CanvasBuffer, e.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, e.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, e.CanvasBuffer.prototype.destroy = function() {
            e.CanvasPool.remove(this)
        }, e.CanvasMaskManager = function() {
        }, e.CanvasMaskManager.prototype.constructor = e.CanvasMaskManager, e.CanvasMaskManager.prototype.pushMask = function(t, i) {
            var n = i.context;
            n.save();
            var s = t.alpha, r = t.worldTransform, o = i.resolution;
            n.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), e.CanvasGraphics.renderGraphicsMask(t, n), n.clip(), t.worldAlpha = s
        }, e.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, e.CanvasTinter = function() {
        }, e.CanvasTinter.getTintedTexture = function(t, i) {
            var n = t.tintedTexture || e.CanvasPool.create(this);
            return e.CanvasTinter.tintMethod(t.texture, i, n), n
        }, e.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var n = i.getContext("2d"), s = t.crop;
            i.width === s.width && i.height === s.height || (i.width = s.width, i.height = s.height), n.clearRect(0, 0, s.width, s.height), n.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), n.fillRect(0, 0, s.width, s.height), n.globalCompositeOperation = "multiply", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height), n.globalCompositeOperation = "destination-atop", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height)
        }, e.CanvasTinter.tintWithPerPixel = function(t, i, n) {
            var s = n.getContext("2d"), r = t.crop;
            n.width = r.width, n.height = r.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
            for(var o = e.hex2rgb(i), a = o[0], h = o[1], l = o[2], c = s.getImageData(0, 0, r.width, r.height),
                    u = c.data,
                    d = 0; d < u.length; d += 4)if(u[d + 0] *= a, u[d + 1] *= h, u[d + 2] *= l, !e.CanvasTinter.canHandleAlpha) {
                var p = u[d + 3];
                u[d + 0] /= 255 / p, u[d + 1] /= 255 / p, u[d + 2] /= 255 / p
            }
            s.putImageData(c, 0, 0)
        }, e.CanvasTinter.checkInverseAlpha = function() {
            var t = new e.CanvasBuffer(2, 1);
            t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
            var i = t.context.getImageData(0, 0, 1, 1);
            if(null === i)return !1;
            t.context.putImageData(i, 1, 0);
            var n = t.context.getImageData(1, 0, 1, 1);
            return n.data[0] === i.data[0] && n.data[1] === i.data[1] && n.data[2] === i.data[2] && n.data[3] === i.data[3]
        }, e.CanvasTinter.canHandleAlpha = e.CanvasTinter.checkInverseAlpha(), e.CanvasTinter.canUseMultiply = e.canUseNewCanvasBlendModes(), e.CanvasTinter.tintMethod = e.CanvasTinter.canUseMultiply ? e.CanvasTinter.tintWithMultiply : e.CanvasTinter.tintWithPerPixel, e.CanvasRenderer = function(t) {
            this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {alpha: this.transparent}), this.refresh = !0, this.count = 0, this.maskManager = new e.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, e.CanvasRenderer.prototype.constructor = e.CanvasRenderer, e.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, e.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, e.CanvasRenderer.prototype.resize = function(t, i) {
            this.width = t * this.resolution, this.height = i * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === e.scaleModes.LINEAR)
        }, e.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, e.CanvasRenderer.prototype.mapBlendModes = function() {
            if(!e.blendModesCanvas) {
                var t = [], i = e.blendModes, n = e.canUseNewCanvasBlendModes();
                t[i.NORMAL] = "source-over", t[i.ADD] = "lighter", t[i.MULTIPLY] = n ? "multiply" : "source-over", t[i.SCREEN] = n ? "screen" : "source-over", t[i.OVERLAY] = n ? "overlay" : "source-over", t[i.DARKEN] = n ? "darken" : "source-over", t[i.LIGHTEN] = n ? "lighten" : "source-over", t[i.COLOR_DODGE] = n ? "color-dodge" : "source-over", t[i.COLOR_BURN] = n ? "color-burn" : "source-over", t[i.HARD_LIGHT] = n ? "hard-light" : "source-over", t[i.SOFT_LIGHT] = n ? "soft-light" : "source-over", t[i.DIFFERENCE] = n ? "difference" : "source-over", t[i.EXCLUSION] = n ? "exclusion" : "source-over", t[i.HUE] = n ? "hue" : "source-over", t[i.SATURATION] = n ? "saturation" : "source-over", t[i.COLOR] = n ? "color" : "source-over", t[i.LUMINOSITY] = n ? "luminosity" : "source-over", e.blendModesCanvas = t
            }
        }, e.BaseTexture = function(t, i) {
            this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = i || e.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, e.BaseTexture.prototype.constructor = e.BaseTexture, e.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, e.BaseTexture.prototype.destroy = function() {
            this.source && e.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, e.BaseTexture.prototype.updateSourceImage = function(t) {
            console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead.")
        }, e.BaseTexture.prototype.dirty = function() {
            for(var t = 0; t < this._glTextures.length; t++)this._dirty[t] = !0
        }, e.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for(var t = this._glTextures.length - 1; t >= 0; t--) {
                var i = this._glTextures[t], n = e.glContexts[t];
                n && i && n.deleteTexture(i)
            }
            this._glTextures.length = 0, this.dirty()
        }, e.BaseTexture.fromCanvas = function(t, i) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new e.BaseTexture(t, i)
        }, e.TextureSilentFail = !1, e.Texture = function(t, i, n, s) {
            this.noFrame = !1, i || (this.noFrame = !0, i = new e.Rectangle(0, 0, 1, 1)), t instanceof e.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = i, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = n || new e.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (i = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(i))
        }, e.Texture.prototype.constructor = e.Texture, e.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, e.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, e.Texture.prototype.setFrame = function(t) {
            if(this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, !this.trim && (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) {
                if(!e.TextureSilentFail)throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                return void(this.valid = !1)
            }
            this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs()
        }, e.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new e.TextureUvs);
            var t = this.crop, i = this.baseTexture.width, n = this.baseTexture.height;
            this._uvs.x0 = t.x / i, this._uvs.y0 = t.y / n, this._uvs.x1 = (t.x + t.width) / i, this._uvs.y1 = t.y / n, this._uvs.x2 = (t.x + t.width) / i, this._uvs.y2 = (t.y + t.height) / n, this._uvs.x3 = t.x / i, this._uvs.y3 = (t.y + t.height) / n
        }, e.Texture.fromCanvas = function(t, i) {
            var n = e.BaseTexture.fromCanvas(t, i);
            return new e.Texture(n)
        }, e.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, e.RenderTexture = function(t, i, n, s, r) {
            this.width = t || 100, this.height = i || 100, this.resolution = r || 1, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new e.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || e.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, e.Texture.call(this, this.baseTexture, new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = n || e.defaultRenderer, this.render = this.renderCanvas, this.textureBuffer = new e.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas, this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, e.RenderTexture.prototype = Object.create(e.Texture.prototype),e.RenderTexture.prototype.constructor = e.RenderTexture,e.RenderTexture.prototype.resize = function(t, e, i) {
            t === this.width && e === this.height || (this.valid = t > 0 && e > 0, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.valid && this.textureBuffer.resize(this.width, this.height))
        },e.RenderTexture.prototype.clear = function() {
            this.valid && this.textureBuffer.clear()
        },e.RenderTexture.prototype.renderCanvas = function(t, e, i) {
            if(this.valid && 0 !== t.alpha) {
                var n = t.worldTransform;
                n.identity(), e && n.append(e);
                for(var s = 0; s < t.children.length; s++)t.children[s].updateTransform();
                i && this.textureBuffer.clear();
                var r = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
            }
        },e.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(), t
        },e.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas().toDataURL()
        },e.RenderTexture.prototype.getCanvas = function() {
            return this.textureBuffer.canvas
        },e.Strip = function(t) {
            e.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new e.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new e.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new e.Float32Array([1, 1, 1, 1]), this.indices = new e.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = e.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = e.Strip.DrawModes.TRIANGLE_STRIP
        },e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype),e.Strip.prototype.constructor = e.Strip,e.Strip.prototype._renderStrip = function(t) {
            var i = t.gl, n = t.projection, s = t.offset, r = t.shaderManager.stripShader,
                o = this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(r.projectionVector, n.x, -n.y), i.uniform2f(r.offsetVector, -s.x, -s.y), i.uniform1f(r.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(o, this.indices.length, i.UNSIGNED_SHORT, 0)
        },e.Strip.prototype._renderCanvas = function(t) {
            var i = t.context, n = this.worldTransform, s = n.tx * t.resolution + t.shakeX,
                r = n.ty * t.resolution + t.shakeY;
            t.roundPixels ? i.setTransform(n.a, n.b, n.c, n.d, 0 | s, 0 | r) : i.setTransform(n.a, n.b, n.c, n.d, s, r), this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
        },e.Strip.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices, i = this.uvs, n = e.length / 2;
            this.count++;
            for(var s = 0; s < n - 2; s++) {
                var r = 2 * s;
                this._renderCanvasDrawTriangle(t, e, i, r, r + 2, r + 4)
            }
        },e.Strip.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices, i = this.uvs, n = this.indices, s = n.length;
            this.count++;
            for(var r = 0; r < s; r += 3) {
                var o = 2 * n[r], a = 2 * n[r + 1], h = 2 * n[r + 2];
                this._renderCanvasDrawTriangle(t, e, i, o, a, h)
            }
        },e.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, n, s, r) {
            var o = this.texture.baseTexture.source, a = this.texture.width, h = this.texture.height, l = e[n],
                c = e[s], u = e[r], d = e[n + 1], p = e[s + 1], f = e[r + 1], g = i[n] * a, m = i[s] * a, y = i[r] * a,
                v = i[n + 1] * h, x = i[s + 1] * h, _ = i[r + 1] * h;
            if(this.canvasPadding > 0) {
                var b = this.canvasPadding / this.worldTransform.a, w = this.canvasPadding / this.worldTransform.d,
                    T = (l + c + u) / 3, P = (d + p + f) / 3, C = l - T, S = d - P, I = Math.sqrt(C * C + S * S);
                l = T + C / I * (I + b), C = c - T, d = P + S / I * (I + w), I = Math.sqrt(C * C + S * S), S = p - P, c = T + C / I * (I + b), p = P + S / I * (I + w), C = u - T, S = f - P, I = Math.sqrt(C * C + S * S), u = T + C / I * (I + b), f = P + S / I * (I + w)
            }
            t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
            var O = g * x + v * y + m * _ - x * y - v * m - g * _, A = l * x + v * u + c * _ - x * u - v * c - l * _,
                M = g * c + l * y + m * u - c * y - l * m - g * u,
                k = g * x * u + v * c * y + l * m * _ - l * x * y - v * m * u - g * c * _,
                E = d * x + v * f + p * _ - x * f - v * p - d * _, R = g * p + d * y + m * f - p * y - d * m - g * f,
                D = g * x * f + v * p * y + d * m * _ - d * x * y - v * m * f - g * p * _;
            t.transform(A / O, E / O, M / O, R / O, k / O, D / O), t.drawImage(o, 0, 0), t.restore()
        },e.Strip.prototype.renderStripFlat = function(t) {
            var e = this.context, i = t.vertices, n = i.length / 2;
            this.count++, e.beginPath();
            for(var s = 1; s < n - 2; s++) {
                var r = 2 * s, o = i[r], a = i[r + 2], h = i[r + 4], l = i[r + 1], c = i[r + 3], u = i[r + 5];
                e.moveTo(o, l), e.lineTo(a, c), e.lineTo(h, u)
            }
            e.fillStyle = "#FF0000", e.fill(), e.closePath()
        },e.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        },e.Strip.prototype.getBounds = function(t) {
            for(var i = t || this.worldTransform, n = i.a, s = i.b, r = i.c, o = i.d, a = i.tx, h = i.ty, l = -(1 / 0),
                    c = -(1 / 0), u = 1 / 0, d = 1 / 0, p = this.vertices, f = 0, g = p.length; f < g; f += 2) {
                var m = p[f], y = p[f + 1], v = n * m + r * y + a;
                u = v < u ? v : u;
                var x = o * y + s * m + h;
                d = x < d ? x : d, l = v > l ? v : l, c = x > c ? x : c
            }
            if(u === -(1 / 0) || c === 1 / 0)return e.EmptyRectangle;
            var _ = this._bounds;
            return _.x = u, _.width = l - u, _.y = d, _.height = c - d, this._currentBounds = _, _
        },e.Strip.DrawModes = {TRIANGLE_STRIP: 0, TRIANGLES: 1},e.TilingSprite = function(t, i, n) {
            e.Sprite.call(this, t), this._width = i || 128, this._height = n || 128, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = e.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
        },e.TilingSprite.prototype = Object.create(e.Sprite.prototype),e.TilingSprite.prototype.constructor = e.TilingSprite,e.TilingSprite.prototype.setTexture = function(t) {
            this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
        },e.TilingSprite.prototype._renderCanvas = function(t) {
            if(this.visible && this.renderable && 0 !== this.alpha) {
                var i = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), i.globalAlpha = this.worldAlpha;
                var n = this.worldTransform, s = t.resolution, r = n.tx * s + t.shakeX, o = n.ty * s + t.shakeY;
                if(i.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, r, o), this.refreshTexture) {
                    if(this.generateTilingTexture(!1, t), !this.tilingTexture)return;
                    this.tilePattern = i.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var a = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, i.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]);
                var h = this.tilePosition, l = this.tileScale;
                h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, i.scale(l.x, l.y), i.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), i.fillStyle = this.tilePattern;
                var r = -h.x, o = -h.y, c = this._width / l.x, u = this._height / l.y;
                t.roundPixels && (r |= 0, o |= 0, c |= 0, u |= 0), i.fillRect(r, o, c, u), i.scale(1 / l.x, 1 / l.y), i.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for(var d = 0; d < this.children.length; d++)this.children[d]._renderCanvas(t);
                a !== this.blendMode && (t.currentBlendMode = a, i.globalCompositeOperation = e.blendModesCanvas[a])
            }
        },e.TilingSprite.prototype.onTextureUpdate = function() {
        },e.TilingSprite.prototype.generateTilingTexture = function(t, i) {
            if(this.texture.baseTexture.hasLoaded) {
                var n = this.texture, s = n.frame, r = this._frame.sourceSizeW || this._frame.width,
                    o = this._frame.sourceSizeH || this._frame.height, a = 0, h = 0;
                this._frame.trimmed && (a = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (r = e.getNextPowerOfTwo(r), o = e.getNextPowerOfTwo(o)), this.canvasBuffer ? (this.canvasBuffer.resize(r, o), this.tilingTexture.baseTexture.width = r, this.tilingTexture.baseTexture.height = o, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new e.CanvasBuffer(r, o), this.tilingTexture = e.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, r, o));
                var l = n.crop.width, c = n.crop.height;
                l === r && c === o || (l = r, c = o), this.canvasBuffer.context.drawImage(n.baseTexture.source, n.crop.x, n.crop.y, n.crop.width, n.crop.height, a, h, l, c), this.tileScaleOffset.x = s.width / r, this.tileScaleOffset.y = s.height / o, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        },e.TilingSprite.prototype.getBounds = function() {
            var t = this._width, e = this._height, i = t * (1 - this.anchor.x), n = t * -this.anchor.x,
                s = e * (1 - this.anchor.y), r = e * -this.anchor.y, o = this.worldTransform, a = o.a, h = o.b, l = o.c,
                c = o.d, u = o.tx, d = o.ty, p = a * n + l * r + u, f = c * r + h * n + d, g = a * i + l * r + u,
                m = c * r + h * i + d, y = a * i + l * s + u, v = c * s + h * i + d, x = a * n + l * s + u,
                _ = c * s + h * n + d, b = -(1 / 0), w = -(1 / 0), T = 1 / 0, P = 1 / 0;
            T = p < T ? p : T, T = g < T ? g : T, T = y < T ? y : T, T = x < T ? x : T, P = f < P ? f : P, P = m < P ? m : P, P = v < P ? v : P, P = _ < P ? _ : P, b = p > b ? p : b, b = g > b ? g : b, b = y > b ? y : b, b = x > b ? x : b, w = f > w ? f : w, w = m > w ? m : w, w = v > w ? v : w, w = _ > w ? _ : w;
            var C = this._bounds;
            return C.x = T, C.width = b - T, C.y = P, C.height = w - P, this._currentBounds = C, C
        },e.TilingSprite.prototype.destroy = function() {
            e.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        },Object.defineProperty(e.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            }, set: function(t) {
                this._width = t
            }
        }),Object.defineProperty(e.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            }, set: function(t) {
                this._height = t
            }
        }),"undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.PIXI = e) : "undefined" != typeof define && define.amd ? define("PIXI", function() {
            return t.PIXI = e
        }()) : t.PIXI = e,e
    }).call(this), function() {
        function t(t, e) {
            this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
        }

        var e = this, i = i || {
                VERSION: "2.6.2",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {DEFAULT: 0, LINEAR: 0, NEAREST: 1},
                PIXI: PIXI || {}
            };
        if(Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = function() {
                var t = Array.prototype.slice;
                return function(e) {
                    function i() {
                        var r = s.concat(t.call(arguments));
                        n.apply(this instanceof i ? this : e, r)
                    }

                    var n = this, s = t.call(arguments, 1);
                    if("function" != typeof n)throw new TypeError;
                    return i.prototype = function r(t) {
                        if(t && (r.prototype = t), !(this instanceof r))return new r
                    }(n.prototype), i
                }
            }()), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                if(void 0 === this || null === this)throw new TypeError;
                var e = Object(this), i = e.length >>> 0;
                if("function" != typeof t)throw new TypeError;
                for(var n = arguments.length >= 2 ? arguments[1] : void 0,
                        s = 0; s < i; s++)s in e && t.call(n, e[s], s, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var n = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for(var e = 0; e < this.length; e++)this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for(var e = 0; e < this.length; e++)this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            n("Uint32Array"), n("Int16Array")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {
        }, window.console.warn = window.console.assert = function() {
        }), i.Utils = {
            reverseString: function(t) {
                return t.split("").reverse().join("")
            }, getProperty: function(t, e) {
                for(var i = e.split("."), n = i.pop(), s = i.length, r = 1,
                        o = i[0]; r < s && (t = t[o]);)o = i[r], r++;
                return t ? t[n] : null
            }, setProperty: function(t, e, i) {
                for(var n = e.split("."), s = n.pop(), r = n.length, o = 1,
                        a = n[0]; o < r && (t = t[a]);)a = n[o], o++;
                return t && (t[s] = i), t
            }, chanceRoll: function(t) {
                return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
            }, randomChoice: function(t, e) {
                return Math.random() < .5 ? t : e
            }, parseDimension: function(t, e) {
                var i = 0, n = 0;
                return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, n = 0 === e ? window.innerWidth * i : window.innerHeight * i) : n = parseInt(t, 10) : n = t, n
            }, pad: function(t, e, i, n) {
                if(void 0 === e)var e = 0;
                if(void 0 === i)var i = " ";
                if(void 0 === n)var n = 3;
                t = t.toString();
                var s = 0;
                if(e + 1 >= t.length)switch(n) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t;
                        break;
                    case 3:
                        var r = Math.ceil((s = e - t.length) / 2), o = s - r;
                        t = new Array(o + 1).join(i) + t + new Array(r + 1).join(i);
                        break;
                    default:
                        t += new Array(e + 1 - t.length).join(i)
                }
                return t
            }, isPlainObject: function(t) {
                if("object" != typeof t || t.nodeType || t === t.window)return !1;
                try {
                    if(t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf"))return !1
                } catch(e) {
                    return !1
                }
                return !0
            }, extend: function() {
                var t, e, n, s, r, o, a = arguments[0] || {}, h = 1, l = arguments.length, c = !1;
                for("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)if(null != (t = arguments[h]))for(e in t)n = a[e], s = t[e], a !== s && (c && s && (i.Utils.isPlainObject(s) || (r = Array.isArray(s))) ? (r ? (r = !1, o = n && Array.isArray(n) ? n : []) : o = n && i.Utils.isPlainObject(n) ? n : {}, a[e] = i.Utils.extend(c, o, s)) : void 0 !== s && (a[e] = s));
                return a
            }, mixinPrototype: function(t, e, i) {
                void 0 === i && (i = !1);
                for(var n = Object.keys(e), s = 0; s < n.length; s++) {
                    var r = n[s], o = e[r];
                    !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                }
            }, mixin: function(t, e) {
                if(!t || "object" != typeof t)return e;
                for(var n in t) {
                    var s = t[n];
                    if(!s.childNodes && !s.cloneNode) {
                        var r = typeof t[n];
                        t[n] && "object" === r ? typeof e[n] === r ? e[n] = i.Utils.mixin(t[n], e[n]) : e[n] = i.Utils.mixin(t[n], new s.constructor) : e[n] = t[n]
                    }
                }
                return e
            }
        }, i.Circle = function(t, e, n) {
            t = t || 0, e = e || 0, n = n || 0, this.x = t, this.y = e, this._diameter = n, this._radius = 0, n > 0 && (this._radius = .5 * n), this.type = i.CIRCLE
        }, i.Circle.prototype = {
            circumference: function() {
                return 2 * (Math.PI * this._radius)
            }, random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = 2 * Math.PI * Math.random(), n = Math.random() + Math.random(), s = n > 1 ? 2 - n : n,
                    r = s * Math.cos(e), o = s * Math.sin(e);
                return t.x = this.x + r * this.radius, t.y = this.y + o * this.radius, t
            }, getBounds: function() {
                return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
            }, setTo: function(t, e, i) {
                return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
            }, copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.diameter)
            }, copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
            }, distance: function(t, e) {
                var n = i.Math.distance(this.x, this.y, t.x, t.y);
                return e ? Math.round(n) : n
            }, clone: function(t) {
                return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
            }, contains: function(t, e) {
                return i.Circle.contains(this, t, e)
            }, circumferencePoint: function(t, e, n) {
                return i.Circle.circumferencePoint(this, t, e, n)
            }, offset: function(t, e) {
                return this.x += t, this.y += e, this
            }, offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            }, toString: function() {
                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
            }
        }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", {
            get: function() {
                return this._diameter
            }, set: function(t) {
                t > 0 && (this._diameter = t, this._radius = .5 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "radius", {
            get: function() {
                return this._radius
            }, set: function(t) {
                t > 0 && (this._radius = t, this._diameter = 2 * t)
            }
        }), Object.defineProperty(i.Circle.prototype, "left", {
            get: function() {
                return this.x - this._radius
            }, set: function(t) {
                t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
            }
        }), Object.defineProperty(i.Circle.prototype, "right", {
            get: function() {
                return this.x + this._radius
            }, set: function(t) {
                t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
            }
        }), Object.defineProperty(i.Circle.prototype, "top", {
            get: function() {
                return this.y - this._radius
            }, set: function(t) {
                t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
            }
        }), Object.defineProperty(i.Circle.prototype, "bottom", {
            get: function() {
                return this.y + this._radius
            }, set: function(t) {
                t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
            }
        }), Object.defineProperty(i.Circle.prototype, "area", {
            get: function() {
                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
            }
        }), Object.defineProperty(i.Circle.prototype, "empty", {
            get: function() {
                return 0 === this._diameter
            }, set: function(t) {
                t === !0 && this.setTo(0, 0, 0)
            }
        }), i.Circle.contains = function(t, e, i) {
            if(t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom) {
                var n = (t.x - e) * (t.x - e), s = (t.y - i) * (t.y - i);
                return n + s <= t.radius * t.radius
            }
            return !1
        }, i.Circle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.diameter === e.diameter
        }, i.Circle.intersects = function(t, e) {
            return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
        }, i.Circle.circumferencePoint = function(t, e, n, s) {
            return void 0 === n && (n = !1), void 0 === s && (s = new i.Point), n === !0 && (e = i.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
        }, i.Circle.intersectsRectangle = function(t, e) {
            var i = Math.abs(t.x - e.x - e.halfWidth), n = e.halfWidth + t.radius;
            if(i > n)return !1;
            var s = Math.abs(t.y - e.y - e.halfHeight), r = e.halfHeight + t.radius;
            if(s > r)return !1;
            if(i <= e.halfWidth || s <= e.halfHeight)return !0;
            var o = i - e.halfWidth, a = s - e.halfHeight, h = o * o, l = a * a, c = t.radius * t.radius;
            return h + l <= c
        }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, n, s) {
            t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.x = t, this.y = e, this.width = n, this.height = s, this.type = i.ELLIPSE
        }, i.Ellipse.prototype = {
            setTo: function(t, e, i, n) {
                return this.x = t, this.y = e, this.width = i, this.height = n, this
            }, getBounds: function() {
                return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
            }, copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            }, copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            }, clone: function(t) {
                return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }, contains: function(t, e) {
                return i.Ellipse.contains(this, t, e)
            }, random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random() * Math.PI * 2, n = Math.random();
                return t.x = Math.sqrt(n) * Math.cos(e), t.y = Math.sqrt(n) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
            }, toString: function() {
                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
            }
        }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", {
            get: function() {
                return this.x
            }, set: function(t) {
                this.x = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "right", {
            get: function() {
                return this.x + this.width
            }, set: function(t) {
                t < this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Ellipse.prototype, "top", {
            get: function() {
                return this.y
            }, set: function(t) {
                this.y = t
            }
        }), Object.defineProperty(i.Ellipse.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            }, set: function(t) {
                t < this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Ellipse.prototype, "empty", {
            get: function() {
                return 0 === this.width || 0 === this.height
            }, set: function(t) {
                t === !0 && this.setTo(0, 0, 0, 0)
            }
        }), i.Ellipse.contains = function(t, e, i) {
            if(t.width <= 0 || t.height <= 0)return !1;
            var n = (e - t.x) / t.width - .5, s = (i - t.y) / t.height - .5;
            return n *= n, s *= s, n + s < .25
        }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, n, s) {
            t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.start = new i.Point(t, e), this.end = new i.Point(n, s), this.type = i.LINE
        }, i.Line.prototype = {
            setTo: function(t, e, i, n) {
                return this.start.setTo(t, e), this.end.setTo(i, n), this
            }, fromSprite: function(t, e, i) {
                return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
            }, fromAngle: function(t, e, i, n) {
                return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * n, e + Math.sin(i) * n), this
            }, rotate: function(t, e) {
                var i = (this.start.x + this.end.x) / 2, n = (this.start.y + this.end.y) / 2;
                return this.start.rotate(i, n, t, e), this.end.rotate(i, n, t, e), this
            }, rotateAround: function(t, e, i, n) {
                return this.start.rotate(t, e, i, n), this.end.rotate(t, e, i, n), this
            }, intersects: function(t, e, n) {
                return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, n)
            }, reflect: function(t) {
                return i.Line.reflect(this, t)
            }, midPoint: function(t) {
                return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
            }, centerOn: function(t, e) {
                var i = (this.start.x + this.end.x) / 2, n = (this.start.y + this.end.y) / 2, s = t - i, r = e - n;
                this.start.add(s, r), this.end.add(s, r)
            }, pointOnLine: function(t, e) {
                return (t - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (e - this.start.y)
            }, pointOnSegment: function(t, e) {
                var i = Math.min(this.start.x, this.end.x), n = Math.max(this.start.x, this.end.x),
                    s = Math.min(this.start.y, this.end.y), r = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(t, e) && t >= i && t <= n && e >= s && e <= r
            }, random: function(t) {
                void 0 === t && (t = new i.Point);
                var e = Math.random();
                return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
            }, coordinatesOnLine: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = []);
                var i = Math.round(this.start.x), n = Math.round(this.start.y), s = Math.round(this.end.x),
                    r = Math.round(this.end.y), o = Math.abs(s - i), a = Math.abs(r - n), h = i < s ? 1 : -1,
                    l = n < r ? 1 : -1, c = o - a;
                e.push([i, n]);
                for(var u = 1; i !== s || n !== r;) {
                    var d = c << 1;
                    d > -a && (c -= a, i += h), d < o && (c += o, n += l), u % t === 0 && e.push([i, n]), u++
                }
                return e
            }, clone: function(t) {
                return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
            }
        }, Object.defineProperty(i.Line.prototype, "length", {
            get: function() {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
            }
        }), Object.defineProperty(i.Line.prototype, "angle", {
            get: function() {
                return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        }), Object.defineProperty(i.Line.prototype, "perpSlope", {
            get: function() {
                return -((this.end.x - this.start.x) / (this.end.y - this.start.y))
            }
        }), Object.defineProperty(i.Line.prototype, "x", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "y", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "left", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "right", {
            get: function() {
                return Math.max(this.start.x, this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "top", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "bottom", {
            get: function() {
                return Math.max(this.start.y, this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "width", {
            get: function() {
                return Math.abs(this.start.x - this.end.x)
            }
        }), Object.defineProperty(i.Line.prototype, "height", {
            get: function() {
                return Math.abs(this.start.y - this.end.y)
            }
        }), Object.defineProperty(i.Line.prototype, "normalX", {
            get: function() {
                return Math.cos(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalY", {
            get: function() {
                return Math.sin(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(i.Line.prototype, "normalAngle", {
            get: function() {
                return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
            }
        }), i.Line.intersectsPoints = function(t, e, n, s, r, o) {
            void 0 === r && (r = !0), void 0 === o && (o = new i.Point);
            var a = e.y - t.y, h = s.y - n.y, l = t.x - e.x, c = n.x - s.x, u = e.x * t.y - t.x * e.y,
                d = s.x * n.y - n.x * s.y, p = a * c - h * l;
            if(0 === p)return null;
            if(o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
                var f = (s.y - n.y) * (e.x - t.x) - (s.x - n.x) * (e.y - t.y),
                    g = ((s.x - n.x) * (t.y - n.y) - (s.y - n.y) * (t.x - n.x)) / f,
                    m = ((e.x - t.x) * (t.y - n.y) - (e.y - t.y) * (t.x - n.x)) / f;
                return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o : null
            }
            return o
        }, i.Line.intersects = function(t, e, n, s) {
            return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, n, s)
        }, i.Line.intersectsRectangle = function(t, e) {
            if(!i.Rectangle.intersects(t, e))return !1;
            var n = t.start.x, s = t.start.y, r = t.end.x, o = t.end.y, a = e.x, h = e.y, l = e.right, c = e.bottom,
                u = 0;
            if(n >= a && n <= l && s >= h && s <= c || r >= a && r <= l && o >= h && o <= c)return !0;
            if(n < a && r >= a) {
                if(u = s + (o - s) * (a - n) / (r - n), u > h && u <= c)return !0
            } else if(n > l && r <= l && (u = s + (o - s) * (l - n) / (r - n), u >= h && u <= c))return !0;
            if(s < h && o >= h) {
                if(u = n + (r - n) * (h - s) / (o - s), u >= a && u <= l)return !0
            } else if(s > c && o <= c && (u = n + (r - n) * (c - s) / (o - s), u >= a && u <= l))return !0;
            return !1
        }, i.Line.reflect = function(t, e) {
            return 2 * e.normalAngle - 3.141592653589793 - t.angle
        }, i.Matrix = function(t, e, n, s, r, o) {
            void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== n && null !== n || (n = 0), void 0 !== s && null !== s || (s = 1), void 0 !== r && null !== r || (r = 0), void 0 !== o && null !== o || (o = 0), this.a = t, this.b = e, this.c = n, this.d = s, this.tx = r, this.ty = o, this.type = i.MATRIX
        }, i.Matrix.prototype = {
            fromArray: function(t) {
                return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
            }, setTo: function(t, e, i, n, s, r) {
                return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = r, this
            }, clone: function(t) {
                return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
            }, copyTo: function(t) {
                return t.copyFrom(this), t
            }, copyFrom: function(t) {
                return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
            }, toArray: function(t, e) {
                return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
            }, apply: function(t, e) {
                return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
            }, applyInverse: function(t, e) {
                void 0 === e && (e = new i.Point);
                var n = 1 / (this.a * this.d + this.c * -this.b), s = t.x, r = t.y;
                return e.x = this.d * n * s + -this.c * n * r + (this.ty * this.c - this.tx * this.d) * n, e.y = this.a * n * r + -this.b * n * s + (-this.ty * this.a + this.tx * this.b) * n, e
            }, translate: function(t, e) {
                return this.tx += t, this.ty += e, this
            }, scale: function(t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            }, rotate: function(t) {
                var e = Math.cos(t), i = Math.sin(t), n = this.a, s = this.c, r = this.tx;
                return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
            }, append: function(t) {
                var e = this.a, i = this.b, n = this.c, s = this.d;
                return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this
            }, identity: function() {
                return this.setTo(1, 0, 0, 1, 0, 0)
            }
        }, i.identityMatrix = new i.Matrix, PIXI.Matrix = i.Matrix, PIXI.identityMatrix = i.identityMatrix, i.Point = function(t, e) {
            t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT
        }, i.Point.prototype = {
            copyFrom: function(t) {
                return this.setTo(t.x, t.y)
            }, invert: function() {
                return this.setTo(this.y, this.x)
            }, setTo: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            }, set: function(t, e) {
                return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
            }, add: function(t, e) {
                return this.x += t, this.y += e, this
            }, subtract: function(t, e) {
                return this.x -= t, this.y -= e, this
            }, multiply: function(t, e) {
                return this.x *= t, this.y *= e, this
            }, divide: function(t, e) {
                return this.x /= t, this.y /= e, this
            }, clampX: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this
            }, clampY: function(t, e) {
                return this.y = i.Math.clamp(this.y, t, e), this
            }, clamp: function(t, e) {
                return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this
            }, clone: function(t) {
                return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t
            }, copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t
            }, distance: function(t, e) {
                return i.Point.distance(this, t, e)
            }, equals: function(t) {
                return t.x === this.x && t.y === this.y
            }, angle: function(t, e) {
                return void 0 === e && (e = !1), e ? i.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
            }, rotate: function(t, e, n, s, r) {
                return i.Point.rotate(this, t, e, n, s, r)
            }, getMagnitude: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, getMagnitudeSq: function() {
                return this.x * this.x + this.y * this.y
            }, setMagnitude: function(t) {
                return this.normalize().multiply(t, t)
            }, normalize: function() {
                if(!this.isZero()) {
                    var t = this.getMagnitude();
                    this.x /= t, this.y /= t
                }
                return this
            }, isZero: function() {
                return 0 === this.x && 0 === this.y
            }, dot: function(t) {
                return this.x * t.x + this.y * t.y
            }, cross: function(t) {
                return this.x * t.y - this.y * t.x
            }, perp: function() {
                return this.setTo(-this.y, this.x)
            }, rperp: function() {
                return this.setTo(this.y, -this.x)
            }, normalRightHand: function() {
                return this.setTo(this.y * -1, this.x)
            }, floor: function() {
                return this.setTo(Math.floor(this.x), Math.floor(this.y))
            }, ceil: function() {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
            }, toString: function() {
                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
            }
        }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, n) {
            return void 0 === n && (n = new i.Point), n.x = t.x + e.x, n.y = t.y + e.y, n
        }, i.Point.subtract = function(t, e, n) {
            return void 0 === n && (n = new i.Point), n.x = t.x - e.x, n.y = t.y - e.y, n
        }, i.Point.multiply = function(t, e, n) {
            return void 0 === n && (n = new i.Point), n.x = t.x * e.x, n.y = t.y * e.y, n
        }, i.Point.divide = function(t, e, n) {
            return void 0 === n && (n = new i.Point), n.x = t.x / e.x, n.y = t.y / e.y, n
        }, i.Point.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, i.Point.angle = function(t, e) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }, i.Point.negative = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y)
        }, i.Point.multiplyAdd = function(t, e, n, s) {
            return void 0 === s && (s = new i.Point), s.setTo(t.x + e.x * n, t.y + e.y * n)
        }, i.Point.interpolate = function(t, e, n, s) {
            return void 0 === s && (s = new i.Point), s.setTo(t.x + (e.x - t.x) * n, t.y + (e.y - t.y) * n)
        }, i.Point.perp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x)
        }, i.Point.rperp = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x)
        }, i.Point.distance = function(t, e, n) {
            var s = i.Math.distance(t.x, t.y, e.x, e.y);
            return n ? Math.round(s) : s
        }, i.Point.project = function(t, e, n) {
            void 0 === n && (n = new i.Point);
            var s = t.dot(e) / e.getMagnitudeSq();
            return 0 !== s && n.setTo(s * e.x, s * e.y), n
        }, i.Point.projectUnit = function(t, e, n) {
            void 0 === n && (n = new i.Point);
            var s = t.dot(e);
            return 0 !== s && n.setTo(s * e.x, s * e.y), n
        }, i.Point.normalRightHand = function(t, e) {
            return void 0 === e && (e = new i.Point), e.setTo(t.y * -1, t.x)
        }, i.Point.normalize = function(t, e) {
            void 0 === e && (e = new i.Point);
            var n = t.getMagnitude();
            return 0 !== n && e.setTo(t.x / n, t.y / n), e
        }, i.Point.rotate = function(t, e, n, s, r, o) {
            if(r && (s = i.Math.degToRad(s)), void 0 === o) {
                t.subtract(e, n);
                var a = Math.sin(s), h = Math.cos(s), l = h * t.x - a * t.y, c = a * t.x + h * t.y;
                t.x = l + e, t.y = c + n
            } else {
                var u = s + Math.atan2(t.y - n, t.x - e);
                t.x = e + o * Math.cos(u), t.y = n + o * Math.sin(u)
            }
            return t
        }, i.Point.centroid = function(t, e) {
            if(void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t))throw new Error("Phaser.Point. Parameter 'points' must be an array");
            var n = t.length;
            if(n < 1)throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            if(1 === n)return e.copyFrom(t[0]), e;
            for(var s = 0; s < n; s++)i.Point.add(e, t[s], e);
            return e.divide(n, n), e
        }, i.Point.parse = function(t, e, n) {
            e = e || "x", n = n || "y";
            var s = new i.Point;
            return t[e] && (s.x = parseInt(t[e], 10)), t[n] && (s.y = parseInt(t[n], 10)), s
        }, PIXI.Point = i.Point, i.Polygon = function() {
            this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON
        }, i.Polygon.prototype = {
            toNumberArray: function(t) {
                void 0 === t && (t = []);
                for(var e = 0; e < this._points.length; e++)"number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                return t
            }, flatten: function() {
                return this._points = this.toNumberArray(), this.flattened = !0, this
            }, clone: function(t) {
                var e = this._points.slice();
                return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t
            }, contains: function(t, e) {
                var i = !1;
                if(this.flattened)for(var n = -2, s = this._points.length - 2; (n += 2) < this._points.length; s = n) {
                    var r = this._points[n], o = this._points[n + 1], a = this._points[s], h = this._points[s + 1];
                    (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                } else for(var n = -1, s = this._points.length - 1; ++n < this._points.length; s = n) {
                    var r = this._points[n].x, o = this._points[n].y, a = this._points[s].x, h = this._points[s].y;
                    (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                }
                return i
            }, setTo: function(t) {
                if(this.area = 0, this._points = [], arguments.length > 0) {
                    Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                    for(var e = Number.MAX_VALUE, i = 0, n = t.length; i < n; i++) {
                        if("number" == typeof t[i]) {
                            var s = new PIXI.Point(t[i], t[i + 1]);
                            i++
                        } else if(Array.isArray(t[i]))var s = new PIXI.Point(t[i][0], t[i][1]); else var s = new PIXI.Point(t[i].x, t[i].y);
                        this._points.push(s), s.y < e && (e = s.y)
                    }
                    this.calculateArea(e)
                }
                return this
            }, calculateArea: function(t) {
                for(var e, i, n, s, r = 0,
                        o = this._points.length; r < o; r++)e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], n = (e.y - t + (i.y - t)) / 2, s = e.x - i.x, this.area += n * s;
                return this.area
            }
        }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", {
            get: function() {
                return this._points
            }, set: function(t) {
                null != t ? this.setTo(t) : this.setTo()
            }
        }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, n, s) {
            t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.x = t, this.y = e, this.width = n, this.height = s, this.type = i.RECTANGLE
        }, i.Rectangle.prototype = {
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            }, offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            }, setTo: function(t, e, i, n) {
                return this.x = t, this.y = e, this.width = i, this.height = n, this
            }, scale: function(t, e) {
                return void 0 === e && (e = t), this.width *= t, this.height *= e, this
            }, centerOn: function(t, e) {
                return this.centerX = t, this.centerY = e, this
            }, floor: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y)
            }, floorAll: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
            }, ceil: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
            }, ceilAll: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
            }, copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            }, copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            }, inflate: function(t, e) {
                return i.Rectangle.inflate(this, t, e)
            }, size: function(t) {
                return i.Rectangle.size(this, t)
            }, resize: function(t, e) {
                return this.width = t, this.height = e, this
            }, clone: function(t) {
                return i.Rectangle.clone(this, t)
            }, contains: function(t, e) {
                return i.Rectangle.contains(this, t, e)
            }, containsRect: function(t) {
                return i.Rectangle.containsRect(t, this)
            }, equals: function(t) {
                return i.Rectangle.equals(this, t)
            }, intersection: function(t, e) {
                return i.Rectangle.intersection(this, t, e)
            }, intersects: function(t) {
                return i.Rectangle.intersects(this, t)
            }, intersectsRaw: function(t, e, n, s, r) {
                return i.Rectangle.intersectsRaw(this, t, e, n, s, r)
            }, union: function(t, e) {
                return i.Rectangle.union(this, t, e)
            }, random: function(t) {
                return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t
            }, getPoint: function(t, e) {
                switch(void 0 === e && (e = new i.Point), t) {
                    default:
                    case i.TOP_LEFT:
                        return e.set(this.x, this.y);
                    case i.TOP_CENTER:
                        return e.set(this.centerX, this.y);
                    case i.TOP_RIGHT:
                        return e.set(this.right, this.y);
                    case i.LEFT_CENTER:
                        return e.set(this.x, this.centerY);
                    case i.CENTER:
                        return e.set(this.centerX, this.centerY);
                    case i.RIGHT_CENTER:
                        return e.set(this.right, this.centerY);
                    case i.BOTTOM_LEFT:
                        return e.set(this.x, this.bottom);
                    case i.BOTTOM_CENTER:
                        return e.set(this.centerX, this.bottom);
                    case i.BOTTOM_RIGHT:
                        return e.set(this.right, this.bottom)
                }
            }, toString: function() {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
            }
        }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", {
            get: function() {
                return Math.round(this.height / 2)
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            }, set: function(t) {
                t <= this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", {
            get: function() {
                return new i.Point(this.x, this.bottom)
            }, set: function(t) {
                this.x = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", {
            get: function() {
                return new i.Point(this.right, this.bottom)
            }, set: function(t) {
                this.right = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "left", {
            get: function() {
                return this.x
            }, set: function(t) {
                t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "right", {
            get: function() {
                return this.x + this.width
            }, set: function(t) {
                t <= this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(i.Rectangle.prototype, "volume", {
            get: function() {
                return this.width * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "perimeter", {
            get: function() {
                return 2 * this.width + 2 * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerX", {
            get: function() {
                return this.x + this.halfWidth
            }, set: function(t) {
                this.x = t - this.halfWidth
            }
        }), Object.defineProperty(i.Rectangle.prototype, "centerY", {
            get: function() {
                return this.y + this.halfHeight
            }, set: function(t) {
                this.y = t - this.halfHeight
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomX", {
            get: function() {
                return this.x + Math.random() * this.width
            }
        }), Object.defineProperty(i.Rectangle.prototype, "randomY", {
            get: function() {
                return this.y + Math.random() * this.height
            }
        }), Object.defineProperty(i.Rectangle.prototype, "top", {
            get: function() {
                return this.y
            }, set: function(t) {
                t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topLeft", {
            get: function() {
                return new i.Point(this.x, this.y)
            }, set: function(t) {
                this.x = t.x, this.y = t.y
            }
        }), Object.defineProperty(i.Rectangle.prototype, "topRight", {
            get: function() {
                return new i.Point(this.x + this.width, this.y)
            }, set: function(t) {
                this.right = t.x, this.y = t.y
            }
        }),Object.defineProperty(i.Rectangle.prototype, "empty", {
            get: function() {
                return !this.width || !this.height
            }, set: function(t) {
                t === !0 && this.setTo(0, 0, 0, 0)
            }
        }),i.Rectangle.prototype.constructor = i.Rectangle,i.Rectangle.inflate = function(t, e, i) {
            return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
        },i.Rectangle.inflatePoint = function(t, e) {
            return i.Rectangle.inflate(t, e.x, e.y)
        },i.Rectangle.size = function(t, e) {
            return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e
        },i.Rectangle.clone = function(t, e) {
            return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
        },i.Rectangle.contains = function(t, e, i) {
            return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
        },i.Rectangle.containsRaw = function(t, e, i, n, s, r) {
            return s >= t && s < t + i && r >= e && r < e + n
        },i.Rectangle.containsPoint = function(t, e) {
            return i.Rectangle.contains(t, e.x, e.y)
        },i.Rectangle.containsRect = function(t, e) {
            return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
        },i.Rectangle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
        },i.Rectangle.sameDimensions = function(t, e) {
            return t.width === e.width && t.height === e.height
        },i.Rectangle.intersection = function(t, e, n) {
            return void 0 === n && (n = new i.Rectangle), i.Rectangle.intersects(t, e) && (n.x = Math.max(t.x, e.x), n.y = Math.max(t.y, e.y), n.width = Math.min(t.right, e.right) - n.x, n.height = Math.min(t.bottom, e.bottom) - n.y), n
        },i.Rectangle.intersects = function(t, e) {
            return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
        },i.Rectangle.intersectsRaw = function(t, e, i, n, s, r) {
            return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r)
        },i.Rectangle.union = function(t, e, n) {
            return void 0 === n && (n = new i.Rectangle), n.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
        },i.Rectangle.aabb = function(t, e) {
            void 0 === e && (e = new i.Rectangle);
            var n = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY,
                o = Number.POSITIVE_INFINITY;
            return t.forEach(function(t) {
                t.x > n && (n = t.x), t.x < s && (s = t.x), t.y > r && (r = t.y), t.y < o && (o = t.y)
            }), e.setTo(s, o, n - s, r - o), e
        },PIXI.Rectangle = i.Rectangle,PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0),i.RoundedRectangle = function(t, e, n, s, r) {
            void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 20), this.x = t, this.y = e, this.width = n, this.height = s, this.radius = r || 20, this.type = i.ROUNDEDRECTANGLE
        },i.RoundedRectangle.prototype = {
            clone: function() {
                return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
            }, contains: function(t, e) {
                if(this.width <= 0 || this.height <= 0)return !1;
                var i = this.x;
                if(t >= i && t <= i + this.width) {
                    var n = this.y;
                    if(e >= n && e <= n + this.height)return !0
                }
                return !1
            }
        },i.RoundedRectangle.prototype.constructor = i.RoundedRectangle,PIXI.RoundedRectangle = i.RoundedRectangle,i.Camera = function(t, e, n, s, r, o) {
            this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(n, s, r, o), this.bounds = new i.Rectangle(n, s, r, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                x: !1,
                y: !1
            }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = {
                intensity: 0,
                duration: 0,
                horizontal: !1,
                vertical: !1,
                shakeBounds: !0,
                x: 0,
                y: 0
            }, this._fxDuration = 0, this._fxType = 0
        },i.Camera.FOLLOW_LOCKON = 0,i.Camera.FOLLOW_PLATFORMER = 1,i.Camera.FOLLOW_TOPDOWN = 2,i.Camera.FOLLOW_TOPDOWN_TIGHT = 3,i.Camera.SHAKE_BOTH = 4,i.Camera.SHAKE_HORIZONTAL = 5,i.Camera.SHAKE_VERTICAL = 6,i.Camera.ENABLE_FX = !0,i.Camera.prototype = {
            boot: function() {
                this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx))
            }, preUpdate: function() {
                this.totalInView = 0
            }, follow: function(t, e, n, s) {
                void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === n && (n = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(n, s);
                var r;
                switch(e) {
                    case i.Camera.FOLLOW_PLATFORMER:
                        var o = this.width / 8, a = this.height / 3;
                        this.deadzone = new i.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN:
                        r = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                        break;
                    case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                        r = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                        break;
                    case i.Camera.FOLLOW_LOCKON:
                        this.deadzone = null;
                        break;
                    default:
                        this.deadzone = null
                }
            }, unfollow: function() {
                this.target = null
            }, focusOn: function(t) {
                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
            }, focusOnXY: function(t, e) {
                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
            }, shake: function(t, e, n, s, r) {
                return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === n && (n = !0), void 0 === s && (s = i.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!n && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_VERTICAL, !0)
            }, flash: function(t, e, i) {
                return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
            }, fade: function(t, e, i) {
                return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
            }, update: function() {
                this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            }, updateFX: function() {
                0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
            }, updateShake: function() {
                this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
            }, updateTarget: function() {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            }, setBoundsToWorld: function() {
                this.bounds && this.bounds.copyFrom(this.game.world.bounds)
            }, checkBounds: function() {
                this.atLimit.x = !1, this.atLimit.y = !1;
                var t = this.view.x + this._shake.x, e = this.view.right + this._shake.x,
                    i = this.view.y + this._shake.y, n = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), n >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
            }, setPosition: function(t, e) {
                this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
            }, setSize: function(t, e) {
                this.view.width = t, this.view.height = e
            }, reset: function() {
                this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
            }, resetFX: function() {
                this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
            }
        },i.Camera.prototype.constructor = i.Camera,Object.defineProperty(i.Camera.prototype, "x", {
            get: function() {
                return this.view.x
            }, set: function(t) {
                this.view.x = t, this.bounds && this.checkBounds()
            }
        }),Object.defineProperty(i.Camera.prototype, "y", {
            get: function() {
                return this.view.y
            }, set: function(t) {
                this.view.y = t, this.bounds && this.checkBounds()
            }
        }),Object.defineProperty(i.Camera.prototype, "position", {
            get: function() {
                return this._position.set(this.view.x, this.view.y), this._position
            }, set: function(t) {
                "undefined" != typeof t.x && (this.view.x = t.x), "undefined" != typeof t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
            }
        }),Object.defineProperty(i.Camera.prototype, "width", {
            get: function() {
                return this.view.width
            }, set: function(t) {
                this.view.width = t
            }
        }),Object.defineProperty(i.Camera.prototype, "height", {
            get: function() {
                return this.view.height
            }, set: function(t) {
                this.view.height = t
            }
        }),Object.defineProperty(i.Camera.prototype, "shakeIntensity", {
            get: function() {
                return this._shake.intensity
            }, set: function(t) {
                this._shake.intensity = t
            }
        }),i.State = function() {
            this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
        },i.State.prototype = {
            init: function() {
            }, preload: function() {
            }, loadUpdate: function() {
            }, loadRender: function() {
            }, create: function() {
            }, update: function() {
            }, preRender: function() {
            }, render: function() {
            }, resize: function() {
            }, paused: function() {
            }, resumed: function() {
            }, pauseUpdate: function() {
            }, shutdown: function() {
            }
        },i.State.prototype.constructor = i.State,i.StateManager = function(t, e) {
            this.game = t, this.states = {}, this._pendingState = null, "undefined" != typeof e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
        },i.StateManager.prototype = {
            boot: function() {
                this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
            }, add: function(t, e, n) {
                void 0 === n && (n = !1);
                var s;
                return e instanceof i.State ? s = e : "object" == typeof e ? (s = e, s.game = this.game) : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, n && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
            }, remove: function(t) {
                this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
            }, start: function(t, e, i) {
                void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
            }, restart: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
            }, dummy: function() {
            }, preUpdate: function() {
                if(this._pendingState && this.game.isBooted) {
                    var t = this.current;
                    if(this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState)return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            }, clearCurrentState: function() {
                this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
            }, checkState: function(t) {
                return this.states[t] ? !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) || (console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
            }, link: function(t) {
                this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
            }, unlink: function(t) {
                this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
            }, setCurrentState: function(t) {
                this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
            }, getCurrentState: function() {
                return this.states[this.current]
            }, loadComplete: function() {
                this._created === !1 && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), this._created === !1 && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
            }, pause: function() {
                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
            }, resume: function() {
                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
            }, update: function() {
                this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            }, pauseUpdate: function() {
                this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            }, preRender: function(t) {
                this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
            }, resize: function(t, e) {
                this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
            }, render: function() {
                this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
            }, destroy: function() {
                this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
            }
        },i.StateManager.prototype.constructor = i.StateManager,Object.defineProperty(i.StateManager.prototype, "created", {
            get: function() {
                return this._created
            }
        }),i.Signal = function() {
        },i.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(t, e) {
                if("function" != typeof t)throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
            },
            _registerListener: function(t, e, n, s, r) {
                var o, a = this._indexOfListener(t, n);
                if(a !== -1) {
                    if(o = this._bindings[a], o.isOnce() !== e)throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                } else o = new i.SignalBinding(this, t, e, n, s, r), this._addBinding(o);
                return this.memorize && this._prevParams && o.execute(this._prevParams), o
            },
            _addBinding: function(t) {
                this._bindings || (this._bindings = []);
                var e = this._bindings.length;
                do e--; while(this._bindings[e] && t._priority <= this._bindings[e]._priority);
                this._bindings.splice(e + 1, 0, t)
            },
            _indexOfListener: function(t, e) {
                if(!this._bindings)return -1;
                void 0 === e && (e = null);
                for(var i,
                        n = this._bindings.length; n--;)if(i = this._bindings[n], i._listener === t && i.context === e)return n;
                return -1
            },
            has: function(t, e) {
                return this._indexOfListener(t, e) !== -1
            },
            add: function(t, e, i) {
                this.validateListener(t, "add");
                var n = [];
                if(arguments.length > 3)for(var s = 3; s < arguments.length; s++)n.push(arguments[s]);
                return this._registerListener(t, !1, e, i, n)
            },
            addOnce: function(t, e, i) {
                this.validateListener(t, "addOnce");
                var n = [];
                if(arguments.length > 3)for(var s = 3; s < arguments.length; s++)n.push(arguments[s]);
                return this._registerListener(t, !0, e, i, n)
            },
            remove: function(t, e) {
                this.validateListener(t, "remove");
                var i = this._indexOfListener(t, e);
                return i !== -1 && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
            },
            removeAll: function(t) {
                if(void 0 === t && (t = null), this._bindings) {
                    for(var e = this._bindings.length; e--;)t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() {
                return this._bindings ? this._bindings.length : 0
            },
            halt: function() {
                this._shouldPropagate = !1
            },
            dispatch: function() {
                if(this.active && this._bindings) {
                    var t, e = Array.prototype.slice.call(arguments), i = this._bindings.length;
                    if(this.memorize && (this._prevParams = e), i) {
                        t = this._bindings.slice(), this._shouldPropagate = !0;
                        do i--; while(t[i] && this._shouldPropagate && t[i].execute(e) !== !1)
                    }
                }
            },
            forget: function() {
                this._prevParams && (this._prevParams = null)
            },
            dispose: function() {
                this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
            },
            toString: function() {
                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
            }
        },Object.defineProperty(i.Signal.prototype, "boundDispatch", {
            get: function() {
                var t = this;
                return this._boundDispatch || (this._boundDispatch = function() {
                        return t.dispatch.apply(t, arguments)
                    })
            }
        }),i.Signal.prototype.constructor = i.Signal,i.SignalBinding = function(t, e, i, n, s, r) {
            this._listener = e, i && (this._isOnce = !0), null != n && (this.context = n), this._signal = t, s && (this._priority = s), r && r.length && (this._args = r)
        },i.SignalBinding.prototype = {
            context: null,
            _isOnce: !1,
            _priority: 0,
            _args: null,
            callCount: 0,
            active: !0,
            params: null,
            execute: function(t) {
                var e, i;
                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
            },
            isBound: function() {
                return !!this._signal && !!this._listener
            },
            isOnce: function() {
                return this._isOnce
            },
            getListener: function() {
                return this._listener
            },
            getSignal: function() {
                return this._signal
            },
            _destroy: function() {
                delete this._signal, delete this._listener, delete this.context
            },
            toString: function() {
                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
            }
        },i.SignalBinding.prototype.constructor = i.SignalBinding,i.Plugin = function(t, e) {
            void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
        },i.Plugin.prototype = {
            preUpdate: function() {
            }, update: function() {
            }, render: function() {
            }, postRender: function() {
            }, destroy: function() {
                this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }
        },i.Plugin.prototype.constructor = i.Plugin,i.PluginManager = function(t) {
            this.game = t, this.plugins = [], this._len = 0, this._i = 0
        },i.PluginManager.prototype = {
            add: function(t) {
                var e = Array.prototype.slice.call(arguments, 1), i = !1;
                return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
            }, remove: function(t, e) {
                for(void 0 === e && (e = !0), this._i = this._len; this._i--;)if(this.plugins[this._i] === t)return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
            }, removeAll: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0
            }, preUpdate: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
            }, update: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
            }, postUpdate: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
            }, render: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
            }, postRender: function() {
                for(this._i = this._len; this._i--;)this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
            }, destroy: function() {
                this.removeAll(), this.game = null
            }
        },i.PluginManager.prototype.constructor = i.PluginManager,i.Stage = function(t) {
            this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                color: 0,
                rgba: "#000000"
            }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
        },i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),i.Stage.prototype.constructor = i.Stage,i.Stage.prototype.parseConfig = function(t) {
            t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
        },i.Stage.prototype.boot = function() {
            i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
        },i.Stage.prototype.preUpdate = function() {
            this.currentRenderOrderID = 0;
            for(var t = 0; t < this.children.length; t++)this.children[t].preUpdate()
        },i.Stage.prototype.update = function() {
            for(var t = this.children.length; t--;)this.children[t].update()
        },i.Stage.prototype.postUpdate = function() {
            this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
            for(var t = 0; t < this.children.length; t++)this.children[t].postUpdate();
            this.updateTransform()
        },i.Stage.prototype.updateTransform = function() {
            this.worldAlpha = 1;
            for(var t = 0; t < this.children.length; t++)this.children[t].updateTransform()
        },i.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var t = this;
            this._onChange = function(e) {
                return t.visibilityChange(e)
            }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {type: "pause"})
            }), CocoonJS.App.onActivated.addEventListener(function() {
                i.Stage.prototype.visibilityChange.call(t, {type: "resume"})
            }))
        },i.Stage.prototype.visibilityChange = function(t) {
            return "pagehide" === t.type || "blur" === t.type || "pageshow" === t.type || "focus" === t.type ? void("pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)) : void(this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)))
        },i.Stage.prototype.setBackgroundColor = function(t) {
            this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
        },i.Stage.prototype.destroy = function() {
            this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
        },Object.defineProperty(i.Stage.prototype, "backgroundColor", {
            get: function() {
                return this._bgColor.color
            }, set: function(t) {
                this.setBackgroundColor(t)
            }
        }),Object.defineProperty(i.Stage.prototype, "smoothed", {
            get: function() {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
            }, set: function(t) {
                t ? PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR : PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST
            }
        }),i.Group = function(t, e, n, s, r, o) {
            void 0 === s && (s = !1), void 0 === r && (r = !1), void 0 === o && (o = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = n || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new i.Point, this.hash = [], this._sortProperty = "z"
        },i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype),i.Group.prototype.constructor = i.Group,i.Group.RETURN_NONE = 0,i.Group.RETURN_TOTAL = 1,i.Group.RETURN_CHILD = 2,i.Group.RETURN_ALL = 3,i.Group.SORT_ASCENDING = -1,i.Group.SORT_DESCENDING = 1,i.Group.prototype.add = function(t, e, i) {
            return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
        },i.Group.prototype.addAt = function(t, e, i) {
            this.add(t, i, e)
        },i.Group.prototype.addToHash = function(t) {
            if(t.parent === this) {
                var e = this.hash.indexOf(t);
                if(e === -1)return this.hash.push(t), !0
            }
            return !1
        },i.Group.prototype.removeFromHash = function(t) {
            if(t) {
                var e = this.hash.indexOf(t);
                if(e !== -1)return this.hash.splice(e, 1), !0
            }
            return !1
        },i.Group.prototype.addMultiple = function(t, e) {
            if(t instanceof i.Group) t.moveAll(this, e); else if(Array.isArray(t))for(var n = 0; n < t.length; n++)this.add(t[n], e);
            return t
        },i.Group.prototype.getAt = function(t) {
            return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
        },i.Group.prototype.create = function(t, e, i, n, s, r) {
            void 0 === s && (s = !0);
            var o = new this.classType(this.game, t, e, i, n);
            return o.exists = s, o.visible = s, o.alive = s, this.add(o, !1, r)
        },i.Group.prototype.createMultiple = function(t, e, i, n) {
            void 0 === i && (i = 0), void 0 === n && (n = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
            var s = this, r = [];
            return e.forEach(function(e) {
                i.forEach(function(i) {
                    for(var o = 0; o < t; o++)r.push(s.create(0, 0, e, i, n))
                })
            }), r
        },i.Group.prototype.updateZ = function() {
            for(var t = this.children.length; t--;)this.children[t].z = t
        },i.Group.prototype.align = function(t, e, n, s, r, o) {
            if(void 0 === r && (r = i.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || t === -1 && e === -1)return !1;
            for(var a = new i.Rectangle(0, 0, n, s), h = t * n, l = e * s, c = o; c < this.children.length; c++) {
                var u = this.children[c];
                if(u.alignIn)if(u.alignIn(a, r), t === -1) a.y += s, a.y === l && (a.x += n, a.y = 0); else if(e === -1) a.x += n, a.x === h && (a.x = 0, a.y += s); else if(a.x += n, a.x === h && (a.x = 0, a.y += s, a.y === l))return !0
            }
            return !0
        },i.Group.prototype.resetCursor = function(t) {
            if(void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor)return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
        },i.Group.prototype.next = function() {
            if(this.cursor)return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
        },i.Group.prototype.previous = function() {
            if(this.cursor)return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
        },i.Group.prototype.swap = function(t, e) {
            this.swapChildren(t, e), this.updateZ()
        },i.Group.prototype.bringToTop = function(t) {
            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
        },i.Group.prototype.sendToBack = function(t) {
            return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
        },i.Group.prototype.moveUp = function(t) {
            if(t.parent === this && this.getIndex(t) < this.children.length - 1) {
                var e = this.getIndex(t), i = this.getAt(e + 1);
                i && this.swap(t, i)
            }
            return t
        },i.Group.prototype.moveDown = function(t) {
            if(t.parent === this && this.getIndex(t) > 0) {
                var e = this.getIndex(t), i = this.getAt(e - 1);
                i && this.swap(t, i)
            }
            return t
        },i.Group.prototype.xy = function(t, e, i) {
            return t < 0 || t > this.children.length ? -1 : (this.getChildAt(t).x = e, void(this.getChildAt(t).y = i))
        },i.Group.prototype.reverse = function() {
            this.children.reverse(), this.updateZ()
        },i.Group.prototype.getIndex = function(t) {
            return this.children.indexOf(t)
        },i.Group.prototype.getByName = function(t) {
            for(var e = 0; e < this.children.length; e++)if(this.children[e].name === t)return this.children[e];
            return null
        },i.Group.prototype.replace = function(t, e) {
            var n = this.getIndex(t);
            if(n !== -1)return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, n), t
        },i.Group.prototype.hasProperty = function(t, e) {
            var i = e.length;
            return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
        },i.Group.prototype.setProperty = function(t, e, i, n, s) {
            if(void 0 === s && (s = !1), n = n || 0, !this.hasProperty(t, e) && (!s || n > 0))return !1;
            var r = e.length;
            return 1 === r ? 0 === n ? t[e[0]] = i : 1 === n ? t[e[0]] += i : 2 === n ? t[e[0]] -= i : 3 === n ? t[e[0]] *= i : 4 === n && (t[e[0]] /= i) : 2 === r ? 0 === n ? t[e[0]][e[1]] = i : 1 === n ? t[e[0]][e[1]] += i : 2 === n ? t[e[0]][e[1]] -= i : 3 === n ? t[e[0]][e[1]] *= i : 4 === n && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === n ? t[e[0]][e[1]][e[2]] = i : 1 === n ? t[e[0]][e[1]][e[2]] += i : 2 === n ? t[e[0]][e[1]][e[2]] -= i : 3 === n ? t[e[0]][e[1]][e[2]] *= i : 4 === n && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === n ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === n ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === n ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === n ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === n && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
        },i.Group.prototype.checkProperty = function(t, e, n, s) {
            return void 0 === s && (s = !1), !(!i.Utils.getProperty(t, e) && s) && i.Utils.getProperty(t, e) === n
        },i.Group.prototype.set = function(t, e, i, n, s, r, o) {
            if(void 0 === o && (o = !1), e = e.split("."), void 0 === n && (n = !1), void 0 === s && (s = !1), (n === !1 || n && t.alive) && (s === !1 || s && t.visible))return this.setProperty(t, e, i, r, o)
        },i.Group.prototype.setAll = function(t, e, i, n, s, r) {
            void 0 === i && (i = !1), void 0 === n && (n = !1), void 0 === r && (r = !1), t = t.split("."), s = s || 0;
            for(var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!n || n && this.children[o].visible) && this.setProperty(this.children[o], t, e, s, r)
        },i.Group.prototype.setAllChildren = function(t, e, n, s, r, o) {
            void 0 === n && (n = !1), void 0 === s && (s = !1), void 0 === o && (o = !1), r = r || 0;
            for(var a = 0; a < this.children.length; a++)(!n || n && this.children[a].alive) && (!s || s && this.children[a].visible) && (this.children[a] instanceof i.Group ? this.children[a].setAllChildren(t, e, n, s, r, o) : this.setProperty(this.children[a], t.split("."), e, r, o))
        },i.Group.prototype.checkAll = function(t, e, i, n, s) {
            void 0 === i && (i = !1), void 0 === n && (n = !1), void 0 === s && (s = !1);
            for(var r = 0; r < this.children.length; r++)if((!i || i && this.children[r].alive) && (!n || n && this.children[r].visible) && !this.checkProperty(this.children[r], t, e, s))return !1;
            return !0
        },i.Group.prototype.addAll = function(t, e, i, n) {
            this.setAll(t, e, i, n, 1)
        },i.Group.prototype.subAll = function(t, e, i, n) {
            this.setAll(t, e, i, n, 2)
        },i.Group.prototype.multiplyAll = function(t, e, i, n) {
            this.setAll(t, e, i, n, 3)
        },i.Group.prototype.divideAll = function(t, e, i, n) {
            this.setAll(t, e, i, n, 4)
        },i.Group.prototype.callAllExists = function(t, e) {
            var i;
            if(arguments.length > 2) {
                i = [];
                for(var n = 2; n < arguments.length; n++)i.push(arguments[n])
            }
            for(var n = 0; n < this.children.length; n++)this.children[n].exists === e && this.children[n][t] && this.children[n][t].apply(this.children[n], i)
        },i.Group.prototype.callbackFromArray = function(t, e, i) {
            if(1 === i) {
                if(t[e[0]])return t[e[0]]
            } else if(2 === i) {
                if(t[e[0]][e[1]])return t[e[0]][e[1]]
            } else if(3 === i) {
                if(t[e[0]][e[1]][e[2]])return t[e[0]][e[1]][e[2]]
            } else if(4 === i) {
                if(t[e[0]][e[1]][e[2]][e[3]])return t[e[0]][e[1]][e[2]][e[3]]
            } else if(t[e])return t[e];
            return !1
        },i.Group.prototype.callAll = function(t, e) {
            if(void 0 !== t) {
                t = t.split(".");
                var i = t.length;
                if(void 0 === e || null === e || "" === e) e = null; else if("string" == typeof e) {
                    e = e.split(".");
                    var n = e.length
                }
                var s;
                if(arguments.length > 2) {
                    s = [];
                    for(var r = 2; r < arguments.length; r++)s.push(arguments[r])
                }
                for(var o = null, a = null,
                        r = 0; r < this.children.length; r++)o = this.callbackFromArray(this.children[r], t, i), e && o ? (a = this.callbackFromArray(this.children[r], e, n), o && o.apply(a, s)) : o && o.apply(this.children[r], s)
            }
        },i.Group.prototype.preUpdate = function() {
            if(this.pendingDestroy)return this.destroy(), !1;
            if(!this.exists || !this.parent.exists)return this.renderOrderID = -1, !1;
            for(var t = 0; t < this.children.length; t++)this.children[t].preUpdate();
            return !0
        },i.Group.prototype.update = function() {
            for(var t = this.children.length; t--;)this.children[t].update()
        },i.Group.prototype.postUpdate = function() {
            this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
            for(var t = 0; t < this.children.length; t++)this.children[t].postUpdate()
        },i.Group.prototype.filter = function(t, e) {
            for(var n = -1, s = this.children.length, r = []; ++n < s;) {
                var o = this.children[n];
                (!e || e && o.exists) && t(o, n, this.children) && r.push(o)
            }
            return new i.ArraySet(r)
        },i.Group.prototype.forEach = function(t, e, i) {
            if(void 0 === i && (i = !1), arguments.length <= 3)for(var n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && t.call(e, this.children[n]); else {
                for(var s = [null], n = 3; n < arguments.length; n++)s.push(arguments[n]);
                for(var n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && (s[0] = this.children[n], t.apply(e, s))
            }
        },i.Group.prototype.forEachExists = function(t, e) {
            var n;
            if(arguments.length > 2) {
                n = [null];
                for(var s = 2; s < arguments.length; s++)n.push(arguments[s])
            }
            this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, n)
        },i.Group.prototype.forEachAlive = function(t, e) {
            var n;
            if(arguments.length > 2) {
                n = [null];
                for(var s = 2; s < arguments.length; s++)n.push(arguments[s])
            }
            this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, n)
        },i.Group.prototype.forEachDead = function(t, e) {
            var n;
            if(arguments.length > 2) {
                n = [null];
                for(var s = 2; s < arguments.length; s++)n.push(arguments[s])
            }
            this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, n)
        },i.Group.prototype.sort = function(t, e) {
            this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
        },i.Group.prototype.customSort = function(t, e) {
            this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
        },i.Group.prototype.ascendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
        },i.Group.prototype.descendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
        },i.Group.prototype.iterate = function(t, e, n, s, r, o) {
            if(0 === this.children.length) {
                if(n === i.Group.RETURN_TOTAL)return 0;
                if(n === i.Group.RETURN_ALL)return []
            }
            var a = 0;
            if(n === i.Group.RETURN_ALL)var h = [];
            for(var l = 0; l < this.children.length; l++)if(this.children[l][t] === e) {
                if(a++, s && (o ? (o[0] = this.children[l], s.apply(r, o)) : s.call(r, this.children[l])), n === i.Group.RETURN_CHILD)return this.children[l];
                n === i.Group.RETURN_ALL && h.push(this.children[l])
            }
            return n === i.Group.RETURN_TOTAL ? a : n === i.Group.RETURN_ALL ? h : null
        },i.Group.prototype.getFirstExists = function(t, e, n, s, r, o) {
            void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
            var a = this.iterate("exists", t, i.Group.RETURN_CHILD);
            return null === a && e ? this.create(n, s, r, o) : this.resetChild(a, n, s, r, o)
        },i.Group.prototype.getFirstAlive = function(t, e, n, s, r) {
            void 0 === t && (t = !1);
            var o = this.iterate("alive", !0, i.Group.RETURN_CHILD);
            return null === o && t ? this.create(e, n, s, r) : this.resetChild(o, e, n, s, r)
        },i.Group.prototype.getFirstDead = function(t, e, n, s, r) {
            void 0 === t && (t = !1);
            var o = this.iterate("alive", !1, i.Group.RETURN_CHILD);
            return null === o && t ? this.create(e, n, s, r) : this.resetChild(o, e, n, s, r)
        },i.Group.prototype.resetChild = function(t, e, i, n, s) {
            return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== n && t.loadTexture(n, s), t)
        },i.Group.prototype.getTop = function() {
            if(this.children.length > 0)return this.children[this.children.length - 1]
        },i.Group.prototype.getBottom = function() {
            if(this.children.length > 0)return this.children[0]
        },i.Group.prototype.getClosestTo = function(t, e, n) {
            for(var s = Number.MAX_VALUE, r = 0, o = null, a = 0; a < this.children.length; a++) {
                var h = this.children[a];
                h.exists && (r = Math.abs(i.Point.distance(t, h)), r < s && (!e || e.call(n, h, r)) && (s = r, o = h))
            }
            return o
        },i.Group.prototype.getFurthestFrom = function(t, e, n) {
            for(var s = 0, r = 0, o = null, a = 0; a < this.children.length; a++) {
                var h = this.children[a];
                h.exists && (r = Math.abs(i.Point.distance(t, h)), r > s && (!e || e.call(n, h, r)) && (s = r, o = h))
            }
            return o
        },i.Group.prototype.countLiving = function() {
            return this.iterate("alive", !0, i.Group.RETURN_TOTAL)
        },i.Group.prototype.countDead = function() {
            return this.iterate("alive", !1, i.Group.RETURN_TOTAL)
        },i.Group.prototype.getRandom = function(t, e) {
            return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e)
        },i.Group.prototype.getRandomExists = function(t, e) {
            var i = this.getAll("exists", !0, t, e);
            return this.game.rnd.pick(i)
        },i.Group.prototype.getAll = function(t, e, i, n) {
            void 0 === i && (i = 0), void 0 === n && (n = this.children.length);
            for(var s = [], r = i; r < n; r++) {
                var o = this.children[r];
                t && o[t] === e && s.push(o)
            }
            return s
        },i.Group.prototype.remove = function(t, e, i) {
            if(void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || this.children.indexOf(t) === -1)return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
            var n = this.removeChild(t);
            return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && n && n.destroy(!0), !0
        },i.Group.prototype.moveAll = function(t, e) {
            if(void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) {
                do t.add(this.children[0], e); while(this.children.length > 0);
                this.hash = [], this.cursor = null
            }
            return t
        },i.Group.prototype.removeAll = function(t, e, i) {
            if(void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                do {
                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var n = this.removeChild(this.children[0]);
                    this.removeFromHash(n), t && n && n.destroy(!0, i)
                } while(this.children.length > 0);
                this.hash = [], this.cursor = null
            }
        },i.Group.prototype.removeBetween = function(t, e, i, n) {
            if(void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === n && (n = !1), 0 !== this.children.length) {
                if(t > e || t < 0 || e > this.children.length)return !1;
                for(var s = e; s >= t;) {
                    !n && this.children[s].events && this.children[s].events.onRemovedFromGroup$dispatch(this.children[s], this);
                    var r = this.removeChild(this.children[s]);
                    this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[s] && (this.cursor = null), s--
                }
                this.updateZ()
            }
        },i.Group.prototype.destroy = function(t, e) {
            null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        },Object.defineProperty(i.Group.prototype, "total", {
            get: function() {
                return this.iterate("exists", !0, i.Group.RETURN_TOTAL)
            }
        }),Object.defineProperty(i.Group.prototype, "length", {
            get: function() {
                return this.children.length
            }
        }),Object.defineProperty(i.Group.prototype, "angle", {
            get: function() {
                return i.Math.radToDeg(this.rotation)
            }, set: function(t) {
                this.rotation = i.Math.degToRad(t)
            }
        }),Object.defineProperty(i.Group.prototype, "centerX", {
            get: function() {
                return this.getBounds(this.parent).centerX
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.x - e.x;
                this.x = t + i - e.halfWidth
            }
        }),Object.defineProperty(i.Group.prototype, "centerY", {
            get: function() {
                return this.getBounds(this.parent).centerY
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.y - e.y;
                this.y = t + i - e.halfHeight
            }
        }),Object.defineProperty(i.Group.prototype, "left", {
            get: function() {
                return this.getBounds(this.parent).left
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.x - e.x;
                this.x = t + i
            }
        }),Object.defineProperty(i.Group.prototype, "right", {
            get: function() {
                return this.getBounds(this.parent).right
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.x - e.x;
                this.x = t + i - e.width
            }
        }),Object.defineProperty(i.Group.prototype, "top", {
            get: function() {
                return this.getBounds(this.parent).top
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.y - e.y;
                this.y = t + i
            }
        }),Object.defineProperty(i.Group.prototype, "bottom", {
            get: function() {
                return this.getBounds(this.parent).bottom
            }, set: function(t) {
                var e = this.getBounds(this.parent), i = this.y - e.y;
                this.y = t + i - e.height
            }
        }),i.World = function(t) {
            i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
        },i.World.prototype = Object.create(i.Group.prototype),i.World.prototype.constructor = i.World,i.World.prototype.boot = function() {
            this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
        },i.World.prototype.stateChange = function() {
            this.x = 0, this.y = 0, this.camera.reset()
        },i.World.prototype.setBounds = function(t, e, i, n) {
            this._definedSize = !0, this._width = i, this._height = n, this.bounds.setTo(t, e, i, n), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(n, this.game.height)), this.game.physics.setBoundsToWorld()
        },i.World.prototype.resize = function(t, e) {
            this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
        },i.World.prototype.shutdown = function() {
            this.destroy(!0, !0)
        },i.World.prototype.wrap = function(t, e, i, n, s) {
            void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === n && (n = !0), void 0 === s && (s = !0), i ? (t.getBounds(), n && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), s && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (n && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : n && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), s && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : s && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
        },Object.defineProperty(i.World.prototype, "width", {
            get: function() {
                return this.bounds.width
            }, set: function(t) {
                t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
            }
        }),Object.defineProperty(i.World.prototype, "height", {
            get: function() {
                return this.bounds.height
            }, set: function(t) {
                t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
            }
        }),Object.defineProperty(i.World.prototype, "centerX", {
            get: function() {
                return this.bounds.halfWidth + this.bounds.x
            }
        }),Object.defineProperty(i.World.prototype, "centerY", {
            get: function() {
                return this.bounds.halfHeight + this.bounds.y
            }
        }),Object.defineProperty(i.World.prototype, "randomX", {
            get: function() {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
            }
        }),Object.defineProperty(i.World.prototype, "randomY", {
            get: function() {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
            }
        }),i.Game = function(t, e, n, s, r, o, a, h) {
            return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {enableDebug: !0}, "undefined" != typeof t && (this._width = t), "undefined" != typeof e && (this._height = e), "undefined" != typeof n && (this.renderType = n), "undefined" != typeof s && (this.parent = s), "undefined" != typeof o && (this.transparent = o), "undefined" != typeof a && (this.antialias = a), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, r)), this.device.whenReady(this.boot, this), this
        },i.Game.prototype = {
            parseConfig: function(t) {
                this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                var e = [(Date.now() * Math.random()).toString()];
                t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e);
                var n = null;
                t.state && (n = t.state), this.state = new i.StateManager(this, n)
            }, boot: function() {
                this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = {
                    preUpdate: function() {
                    }, update: function() {
                    }, reset: function() {
                    }
                }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, (!1)), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
            }, showDebugHeader: function() {
                if(!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var t = i.VERSION, e = "Canvas", n = "HTML Audio", s = 1;
                    if(this.renderType === i.HEADLESS && (e = "Headless"), this.device.chrome) {
                        for(var r = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + n + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"],
                                o = 0; o < 3; o++)o < s ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                        console.log.apply(console, r)
                    } else window.console && console.log("Phaser v" + t + " | Pixi.js " + PIXI.VERSION + " | " + e + " | " + n + " | http://phaser.io")
                }
            }, setUpRenderer: function() {
                if(this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === i.HEADLESS || this.renderType === i.CANVAS || this.renderType === i.AUTO) {
                    if(!this.device.canvas)throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderType = i.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                }
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas))
            }, contextLost: function(t) {
                t.preventDefault(), this.renderer.contextLost = !0
            }, contextRestored: function() {
                this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
            }, update: function(t) {
                if(this.time.update(t), this._kickstart)return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                if(this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps); else {
                    var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                    var i = 0;
                    for(this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);)this.time.refresh();
                    i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                }
            }, updateLogic: function(t) {
                this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
            }, updateRender: function(t) {
                this.lockRender || (this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
            }, enableStep: function() {
                this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
            }, disableStep: function() {
                this.stepping = !1, this.pendingStep = !1
            }, step: function() {
                this.pendingStep = !1, this.stepCount++
            }, destroy: function() {
                this.raf.stop(), this.state.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null
            }, gamePaused: function(t) {
                this._paused || (this._paused = !0, this.time.gamePaused(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
            }, gameResumed: function(t) {
                this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
            }, focusLoss: function(t) {
                this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
            }, focusGain: function(t) {
                this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
            }
        },i.Game.prototype.constructor = i.Game,Object.defineProperty(i.Game.prototype, "paused", {
            get: function() {
                return this._paused
            }, set: function(t) {
                t === !0 ? (this._paused === !1 && (this._paused = !0, this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
            }
        }),i.Input = function(t) {
            this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.touch = null, this.mspointer = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
        },i.Input.MOUSE_OVERRIDES_TOUCH = 0,i.Input.TOUCH_OVERRIDES_MOUSE = 1,i.Input.MOUSE_TOUCH_COMBINE = 2,i.Input.MAX_POINTERS = 10,i.Input.prototype = {
            boot: function() {
                this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0;
                var t = this;
                this._onClickTrampoline = function(e) {
                    t.onClickTrampoline(e)
                }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            }, destroy: function() {
                this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
            }, setInteractiveCandidateHandler: function(t, e) {
                this.customCandidateHandler = t, this.customCandidateHandlerContext = e
            }, addMoveCallback: function(t, e) {
                this.moveCallbacks.push({callback: t, context: e})
            }, deleteMoveCallback: function(t, e) {
                for(var i = this.moveCallbacks.length; i--;)if(this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e)return void this.moveCallbacks.splice(i, 1)
            }, addPointer: function() {
                if(this.pointers.length >= i.Input.MAX_POINTERS)return console.warn("Phaser.Input.addPointer: Maximum limit of " + i.Input.MAX_POINTERS + " pointers reached."), null;
                var t = this.pointers.length + 1, e = new i.Pointer(this.game, t, i.PointerMode.TOUCH);
                return this.pointers.push(e), this["pointer" + t] = e, e
            }, update: function() {
                if(this.pollRate > 0 && this._pollCounter < this.pollRate)return void this._pollCounter++;
                this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update();
                for(var t = 0; t < this.pointers.length; t++)this.pointers[t].update();
                this._pollCounter = 0
            }, reset: function(t) {
                if(this.game.isBooted && !this.resetLocked) {
                    void 0 === t && (t = !1), this.mousePointer.reset();
                    for(var e = 0; e < this.pointers.length; e++)this.pointers[e].reset();
                    "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0
                }
            }, resetSpeed: function(t, e) {
                this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
            }, startPointer: function(t) {
                if(this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers)return null;
                if(!this.pointer1.active)return this.pointer1.start(t);
                if(!this.pointer2.active)return this.pointer2.start(t);
                for(var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(!i.active)return i.start(t)
                }
                return null
            }, updatePointer: function(t) {
                if(this.pointer1.active && this.pointer1.identifier === t.identifier)return this.pointer1.move(t);
                if(this.pointer2.active && this.pointer2.identifier === t.identifier)return this.pointer2.move(t);
                for(var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(i.active && i.identifier === t.identifier)return i.move(t)
                }
                return null
            }, stopPointer: function(t) {
                if(this.pointer1.active && this.pointer1.identifier === t.identifier)return this.pointer1.stop(t);
                if(this.pointer2.active && this.pointer2.identifier === t.identifier)return this.pointer2.stop(t);
                for(var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(i.active && i.identifier === t.identifier)return i.stop(t)
                }
                return null
            }, countActivePointers: function(t) {
                void 0 === t && (t = this.pointers.length);
                for(var e = t, i = 0; i < this.pointers.length && e > 0; i++) {
                    var n = this.pointers[i];
                    n.active && e--
                }
                return t - e
            }, getPointer: function(t) {
                void 0 === t && (t = !1);
                for(var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(i.active === t)return i
                }
                return null
            }, getPointerFromIdentifier: function(t) {
                for(var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(i.identifier === t)return i
                }
                return null
            }, getPointerFromId: function(t) {
                for(var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if(i.pointerId === t)return i
                }
                return null
            }, getLocalPosition: function(t, e, n) {
                void 0 === n && (n = new i.Point);
                var s = t.worldTransform, r = 1 / (s.a * s.d + s.c * -s.b);
                return n.setTo(s.d * r * e.x + -s.c * r * e.y + (s.ty * s.c - s.tx * s.d) * r, s.a * r * e.y + -s.b * r * e.x + (-s.ty * s.a + s.tx * s.b) * r)
            }, hitTest: function(t, e, n) {
                if(!t.worldVisible)return !1;
                if(this.getLocalPosition(t, e, this._localPoint), n.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains)return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if(t instanceof i.TileSprite) {
                    var s = t.width, r = t.height, o = -s * t.anchor.x;
                    if(this._localPoint.x >= o && this._localPoint.x < o + s) {
                        var a = -r * t.anchor.y;
                        if(this._localPoint.y >= a && this._localPoint.y < a + r)return !0
                    }
                } else if(t instanceof PIXI.Sprite) {
                    var s = t.texture.frame.width, r = t.texture.frame.height, o = -s * t.anchor.x;
                    if(this._localPoint.x >= o && this._localPoint.x < o + s) {
                        var a = -r * t.anchor.y;
                        if(this._localPoint.y >= a && this._localPoint.y < a + r)return !0
                    }
                } else if(t instanceof i.Graphics)for(var h = 0; h < t.graphicsData.length; h++) {
                    var l = t.graphicsData[h];
                    if(l.fill && l.shape && l.shape.contains(this._localPoint.x, this._localPoint.y))return !0
                }
                for(var h = 0; h < t.children.length; h++)if(this.hitTest(t.children[h], e, n))return !0;
                return !1
            }, onClickTrampoline: function() {
                this.activePointer.processClickTrampolines()
            }
        },i.Input.prototype.constructor = i.Input,Object.defineProperty(i.Input.prototype, "x", {
            get: function() {
                return this._x
            }, set: function(t) {
                this._x = Math.floor(t)
            }
        }),Object.defineProperty(i.Input.prototype, "y", {
            get: function() {
                return this._y
            }, set: function(t) {
                this._y = Math.floor(t)
            }
        }),Object.defineProperty(i.Input.prototype, "pollLocked", {
            get: function() {
                return this.pollRate > 0 && this._pollCounter < this.pollRate
            }
        }),Object.defineProperty(i.Input.prototype, "totalInactivePointers", {
            get: function() {
                return this.pointers.length - this.countActivePointers()
            }
        }),Object.defineProperty(i.Input.prototype, "totalActivePointers", {
            get: function() {
                return this.countActivePointers()
            }
        }),Object.defineProperty(i.Input.prototype, "worldX", {
            get: function() {
                return this.game.camera.view.x + this.x
            }
        }),Object.defineProperty(i.Input.prototype, "worldY", {
            get: function() {
                return this.game.camera.view.y + this.y
            }
        }),i.Mouse = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
        },i.Mouse.NO_BUTTON = -1,i.Mouse.LEFT_BUTTON = 0,i.Mouse.MIDDLE_BUTTON = 1,i.Mouse.RIGHT_BUTTON = 2,i.Mouse.BACK_BUTTON = 3,i.Mouse.FORWARD_BUTTON = 4,i.Mouse.WHEEL_UP = 1,i.Mouse.WHEEL_DOWN = -1,i.Mouse.prototype = {
            start: function() {
                if((!this.game.device.android || this.game.device.chrome !== !1) && null === this._onMouseDown) {
                    var e = this;
                    this._onMouseDown = function(t) {
                        return e.onMouseDown(t)
                    }, this._onMouseMove = function(t) {
                        return e.onMouseMove(t)
                    }, this._onMouseUp = function(t) {
                        return e.onMouseUp(t)
                    }, this._onMouseUpGlobal = function(t) {
                        return e.onMouseUpGlobal(t)
                    }, this._onMouseOutGlobal = function(t) {
                        return e.onMouseOutGlobal(t)
                    }, this._onMouseOut = function(t) {
                        return e.onMouseOut(t)
                    }, this._onMouseOver = function(t) {
                        return e.onMouseOver(t)
                    }, this._onMouseWheel = function(t) {
                        return e.onMouseWheel(t)
                    };
                    var i = this.game.canvas;
                    i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0));
                    var n = this.game.device.wheelEvent;
                    n && (i.addEventListener(n, this._onMouseWheel, !0), "mousewheel" === n ? this._wheelEvent = new t((-.025), 1) : "DOMMouseScroll" === n && (this._wheelEvent = new t(1, 1)))
                }
            }, onMouseDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
            }, onMouseMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
            }, onMouseUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
            }, onMouseUpGlobal: function(t) {
                this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
            }, onMouseOutGlobal: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
            }, onMouseOut: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
            }, onMouseOver: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
            }, onMouseWheel: function(t) {
                this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
            }, requestPointerLock: function() {
                if(this.game.device.pointerLock) {
                    var t = this.game.canvas;
                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                    var e = this;
                    this._pointerLockChange = function(t) {
                        return e.pointerLockChange(t)
                    }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            }, pointerLockChange: function(t) {
                var e = this.game.canvas;
                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
            }, releasePointerLock: function() {
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }, stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                var e = this.game.device.wheelEvent;
                e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
            }
        },i.Mouse.prototype.constructor = i.Mouse,t.prototype = {},t.prototype.constructor = t,t.prototype.bindEvent = function(e) {
            if(!t._stubsGenerated && e) {
                var i = function(t) {
                    return function() {
                        var e = this.originalEvent[t];
                        return "function" != typeof e ? e : e.bind(this.originalEvent)
                    }
                };
                for(var n in e)n in t.prototype || Object.defineProperty(t.prototype, n, {get: i(n)});
                t._stubsGenerated = !0
            }
            return this.originalEvent = e, this
        },Object.defineProperties(t.prototype, {
            type: {value: "wheel"}, deltaMode: {
                get: function() {
                    return this._deltaMode
                }
            }, deltaY: {
                get: function() {
                    return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                }
            }, deltaX: {
                get: function() {
                    return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                }
            }, deltaZ: {value: 0}
        }),i.MSPointer = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
        },i.MSPointer.prototype = {
            start: function() {
                if(null === this._onMSPointerDown) {
                    var t = this;
                    if(this.game.device.mspointer) {
                        this._onMSPointerDown = function(e) {
                            return t.onPointerDown(e)
                        }, this._onMSPointerMove = function(e) {
                            return t.onPointerMove(e)
                        }, this._onMSPointerUp = function(e) {
                            return t.onPointerUp(e)
                        }, this._onMSPointerUpGlobal = function(e) {
                            return t.onPointerUpGlobal(e)
                        }, this._onMSPointerOut = function(e) {
                            return t.onPointerOut(e)
                        }, this._onMSPointerOver = function(e) {
                            return t.onPointerOver(e)
                        };
                        var e = this.game.canvas;
                        e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                    }
                }
            }, onPointerDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
            }, onPointerMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
            }, onPointerUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            }, onPointerUpGlobal: function(t) {
                if("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t)
                } else this.onPointerUp(t)
            }, onPointerOut: function(t) {
                if(this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1; else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !1)
                }
                this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
            }, onPointerOver: function(t) {
                if(this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0; else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !0)
                }
                this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
            }, stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
            }
        },i.MSPointer.prototype.constructor = i.MSPointer,i.DeviceButton = function(t, e) {
            this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal
        },i.DeviceButton.prototype = {
            start: function(t, e) {
                this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
            }, stop: function(t, e) {
                this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
            }, padFloat: function(t) {
                this.value = t, this.onFloat.dispatch(this, t)
            }, justPressed: function(t) {
                return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
            }, justReleased: function(t) {
                return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
            }, reset: function() {
                this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
            }, destroy: function() {
                this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
            }
        },i.DeviceButton.prototype.constructor = i.DeviceButton,Object.defineProperty(i.DeviceButton.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }),i.Pointer = function(t, e, n) {
            this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = n || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
        },i.Pointer.NO_BUTTON = 0,i.Pointer.LEFT_BUTTON = 1,i.Pointer.RIGHT_BUTTON = 2,i.Pointer.MIDDLE_BUTTON = 4,i.Pointer.BACK_BUTTON = 8,i.Pointer.FORWARD_BUTTON = 16,i.Pointer.ERASER_BUTTON = 32,i.Pointer.prototype = {
            resetButtons: function() {
                this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
            }, processButtonsDown: function(t, e) {
                i.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), i.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), i.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), i.Pointer.BACK_BUTTON & t && this.backButton.start(e), i.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), i.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
            }, processButtonsUp: function(t, e) {
                t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
            }, updateButtons: function(t) {
                this.button = t.button;
                var e = "down" === t.type.toLowerCase().substr(-4);
                void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
            }, start: function(t) {
                var e = this.game.input;
                return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
            }, update: function() {
                var t = this.game.input;
                this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), this._holdSent === !1 && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }), this._history.length > t.recordLimit && this._history.shift()))
            }, move: function(t, e) {
                var n = this.game.input;
                if(!n.pollLocked) {
                    if(void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && n.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * n.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * n.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (n.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || n.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || n.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === n.totalActivePointers) && (n.activePointer = this, n.x = this.x, n.y = this.y, n.position.setTo(n.x, n.y), n.circle.x = n.x, n.circle.y = n.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused)return this;
                    for(var s = n.moveCallbacks.length; s--;)n.moveCallbacks[s].callback.call(n.moveCallbacks[s].context, this, this.x, this.y, e);
                    return null !== this.targetObject && this.targetObject.isDragged === !0 ? this.targetObject.update(this) === !1 && (this.targetObject = null) : n.interactiveItems.total > 0 && this.processInteractiveObjects(e), this
                }
            }, processInteractiveObjects: function(t) {
                var e = 0, i = -1, n = null, s = this.game.input.interactiveItems.first;
                for(this.interactiveCandidates = []; s;)s.checked = !1, s.validForInput(i, e, !1) && (s.checked = !0, (t && s.checkPointerDown(this, !0) || !t && s.checkPointerOver(this, !0)) && (e = s.sprite.renderOrderID, i = s.priorityID, n = s, this.interactiveCandidates.push(s))), s = this.game.input.interactiveItems.next;
                for(s = this.game.input.interactiveItems.first; s;)!s.checked && s.validForInput(i, e, !0) && (t && s.checkPointerDown(this, !1) || !t && s.checkPointerOver(this, !1)) && (e = s.sprite.renderOrderID, i = s.priorityID, n = s, this.interactiveCandidates.push(s)), s = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (n = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, n)), this.swapTarget(n, !1), null !== this.targetObject
            }, swapTarget: function(t, e) {
                void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? t.update(this) === !1 && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
            }, leave: function(t) {
                this.withinGame = !1, this.move(t, !1)
            }, stop: function(t) {
                var e = this.game.input;
                return this._stateReset && this.withinGame ? void t.preventDefault() : (this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), this.isMouse === !1 && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
            }, justPressed: function(t) {
                return t = t || this.game.input.justPressedRate, this.isDown === !0 && this.timeDown + t > this.game.time.time
            }, justReleased: function(t) {
                return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
            }, addClickTrampoline: function(t, e, i, n) {
                if(this.isDown) {
                    for(var s = this._clickTrampolines = this._clickTrampolines || [],
                            r = 0; r < s.length; r++)if(s[r].name === t) {
                        s.splice(r, 1);
                        break
                    }
                    s.push({name: t, targetObject: this.targetObject, callback: e, callbackContext: i, callbackArgs: n})
                }
            }, processClickTrampolines: function() {
                var t = this._clickTrampolines;
                if(t) {
                    for(var e = 0; e < t.length; e++) {
                        var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                    }
                    this._clickTrampolines = null, this._trampolineTargetObject = null
                }
            }, reset: function() {
                this.isMouse === !1 && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
            }, resetMovement: function() {
                this.movementX = 0, this.movementY = 0
            }
        },i.Pointer.prototype.constructor = i.Pointer,Object.defineProperty(i.Pointer.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }),Object.defineProperty(i.Pointer.prototype, "worldX", {
            get: function() {
                return this.game.world.camera.x + this.x
            }
        }),Object.defineProperty(i.Pointer.prototype, "worldY", {
            get: function() {
                return this.game.world.camera.y + this.y
            }
        }),i.PointerMode = {CURSOR: 1, CONTACT: 2},i.Touch = function(t) {
            this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
        },i.Touch.prototype = {
            start: function() {
                if(null === this._onTouchStart) {
                    var t = this;
                    this.game.device.touch && (this._onTouchStart = function(e) {
                        return t.onTouchStart(e)
                    }, this._onTouchMove = function(e) {
                        return t.onTouchMove(e)
                    }, this._onTouchEnd = function(e) {
                        return t.onTouchEnd(e)
                    }, this._onTouchEnter = function(e) {
                        return t.onTouchEnter(e)
                    }, this._onTouchLeave = function(e) {
                        return t.onTouchLeave(e)
                    }, this._onTouchCancel = function(e) {
                        return t.onTouchCancel(e)
                    }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                }
            }, consumeDocumentTouches: function() {
                this._documentTouchMove = function(t) {
                    t.preventDefault()
                }, document.addEventListener("touchmove", this._documentTouchMove, !1)
            }, addTouchLockCallback: function(t, e, i) {
                void 0 === i && (i = !1), this.touchLockCallbacks.push({callback: t, context: e, onEnd: i})
            }, removeTouchLockCallback: function(t, e) {
                for(var i = this.touchLockCallbacks.length; i--;)if(this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e)return this.touchLockCallbacks.splice(i, 1), !0;
                return !1
            }, onTouchStart: function(t) {
                for(var e = this.touchLockCallbacks.length; e--;) {
                    var i = this.touchLockCallbacks[e];
                    !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                if(this.event = t, this.game.input.enabled && this.enabled) {
                    this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for(var e = 0; e < t.changedTouches.length; e++)this.game.input.startPointer(t.changedTouches[e])
                }
            }, onTouchCancel: function(t) {
                if(this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                    this.preventDefault && t.preventDefault();
                    for(var e = 0; e < t.changedTouches.length; e++)this.game.input.stopPointer(t.changedTouches[e])
                }
            }, onTouchEnter: function(t) {
                this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
            }, onTouchLeave: function(t) {
                this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
            }, onTouchMove: function(t) {
                this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for(var e = 0; e < t.changedTouches.length; e++)this.game.input.updatePointer(t.changedTouches[e])
            }, onTouchEnd: function(t) {
                for(var e = this.touchLockCallbacks.length; e--;) {
                    var i = this.touchLockCallbacks[e];
                    i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                }
                this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for(var e = 0; e < t.changedTouches.length; e++)this.game.input.stopPointer(t.changedTouches[e])
            }, stop: function() {
                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
            }
        },i.Touch.prototype.constructor = i.Touch,i.InputHandler = function(t) {
            this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                camX: 0,
                camY: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        },i.InputHandler.prototype = {
            start: function(t, e) {
                if(t = t || 0, void 0 === e && (e = !1), this.enabled === !1) {
                    this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                    for(var n = 0; n < 10; n++)this._pointerData[n] = {
                        id: n,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    };
                    this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
            }, addedToGroup: function() {
                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
            }, removedFromGroup: function() {
                this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
            }, reset: function() {
                this.enabled = !1;
                for(var t = 0; t < 10; t++)this._pointerData[t] = {
                    id: t,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                }
            }, stop: function() {
                this.enabled !== !1 && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
            }, destroy: function() {
                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
            }, validForInput: function(t, e, i) {
                return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
            }, isPixelPerfect: function() {
                return this.pixelPerfectClick || this.pixelPerfectOver
            }, pointerX: function(t) {
                return t = t || 0, this._pointerData[t].x
            }, pointerY: function(t) {
                return t = t || 0, this._pointerData[t].y
            }, pointerDown: function(t) {
                return t = t || 0, this._pointerData[t].isDown
            }, pointerUp: function(t) {
                return t = t || 0, this._pointerData[t].isUp
            }, pointerTimeDown: function(t) {
                return t = t || 0, this._pointerData[t].timeDown
            }, pointerTimeUp: function(t) {
                return t = t || 0, this._pointerData[t].timeUp
            }, pointerOver: function(t) {
                if(!this.enabled)return !1;
                if(void 0 === t) {
                    for(var e = 0; e < 10; e++)if(this._pointerData[e].isOver)return !0;
                    return !1
                }
                return this._pointerData[t].isOver
            }, pointerOut: function(t) {
                if(!this.enabled)return !1;
                if(void 0 !== t)return this._pointerData[t].isOut;
                for(var e = 0; e < 10; e++)if(this._pointerData[e].isOut)return !0
            }, pointerTimeOver: function(t) {
                return t = t || 0, this._pointerData[t].timeOver
            }, pointerTimeOut: function(t) {
                return t = t || 0, this._pointerData[t].timeOut
            }, pointerDragged: function(t) {
                return t = t || 0, this._pointerData[t].isDragged
            }, checkPointerDown: function(t, e) {
                return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            }, checkPointerOver: function(t, e) {
                return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            }, checkPixel: function(t, e, i) {
                if(this.sprite.texture.baseTexture.source) {
                    if(null === t && null === e) {
                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                        var t = this._tempPoint.x, e = this._tempPoint.y
                    }
                    if(0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom))return this._dx = t, this._dy = e, !1;
                    this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1);
                    var n = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                    if(n.data[3] >= this.pixelPerfectAlpha)return !0
                }
                return !1
            }, update: function(t) {
                if(null !== this.sprite && void 0 !== this.sprite.parent)return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
            }, _pointerOverHandler: function(t, e) {
                if(null !== this.sprite) {
                    var n = this._pointerData[t.id];
                    if(n.isOver === !1 || t.dirty) {
                        var s = n.isOver === !1;
                        n.isOver = !0, n.isOut = !1, n.timeOver = this.game.time.time, n.x = t.x - this.sprite.x, n.y = t.y - this.sprite.y, this.useHandCursor && n.isDragged === !1 && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                    }
                }
            }, _pointerOutHandler: function(t, e) {
                if(null !== this.sprite) {
                    var n = this._pointerData[t.id];
                    n.isOver = !1, n.isOut = !0, n.timeOut = this.game.time.time, this.useHandCursor && n.isDragged === !1 && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                }
            }, _touchedHandler: function(t) {
                if(null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if(!e.isDown && e.isOver) {
                        if(this.pixelPerfectClick && !this.checkPixel(null, null, t))return;
                        if(e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite))return;
                        this.draggable && this.isDragged === !1 && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                    }
                }
            }, dragTimeElapsed: function(t) {
                this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
            }, _releasedHandler: function(t) {
                if(null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if(e.isDown && t.isUp) {
                        e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                        var n = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, n), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, n), n && (n = this.checkPointerOver(t))), e.isOver = n, !n && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                    }
                }
            }, updateDrag: function(t, e) {
                if(void 0 === e && (e = !1), t.isUp)return this.stopDrag(t), !1;
                var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                    n = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                if(this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y)); else {
                    var s = this.game.camera.x - this._pointerData[t.id].camX,
                        r = this.game.camera.y - this._pointerData[t.id].camY;
                    this.allowHorizontalDrag && (this.sprite.x = i + s), this.allowVerticalDrag && (this.sprite.y = n + r), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                }
                return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, n, this.snapPoint, e), !0
            }, justOver: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
            }, justOut: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
            }, justPressed: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
            }, justReleased: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
            }, overDuration: function(t) {
                return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
            }, downDuration: function(t) {
                return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
            }, enableDrag: function(t, e, n, s, r, o) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === n && (n = !1), void 0 === s && (s = 255), void 0 === r && (r = null), void 0 === o && (o = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = n, this.pixelPerfectAlpha = s, r && (this.boundsRect = r), o && (this.boundsSprite = o)
            }, disableDrag: function() {
                if(this._pointerData)for(var t = 0; t < 10; t++)this._pointerData[t].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
            }, startDrag: function(t) {
                var e = this.sprite.x, i = this.sprite.y;
                if(this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                    if(this.dragFromCenter) {
                        var n = this.sprite.getBounds();
                        this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - n.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - n.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                } else {
                    if(this.dragFromCenter) {
                        var n = this.sprite.getBounds();
                        this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - n.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - n.centerY)
                    }
                    this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                }
                this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
            }, globalToLocalX: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
            }, globalToLocalY: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
            }, stopDrag: function(t) {
                this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), this.checkPointerOver(t) === !1 && this._pointerOutHandler(t)
            }, setDragLock: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
            }, enableSnap: function(t, e, i, n, s, r) {
                void 0 === i && (i = !0), void 0 === n && (n = !1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = s, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = n
            }, disableSnap: function() {
                this.snapOnDrag = !1, this.snapOnRelease = !1
            }, checkBoundsRect: function() {
                this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
            }, checkBoundsSprite: function() {
                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
            }
        },i.InputHandler.prototype.constructor = i.InputHandler,i.Component = function() {
        },i.Component.Angle = function() {
        },i.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return i.Math.wrapAngle(i.Math.radToDeg(this.rotation))
                }, set: function(t) {
                    this.rotation = i.Math.degToRad(i.Math.wrapAngle(t))
                }
            }
        },i.Component.Animation = function() {
        },i.Component.Animation.prototype = {
            play: function(t, e, i, n) {
                if(this.animations)return this.animations.play(t, e, i, n)
            }
        },i.Component.AutoCull = function() {
        },i.Component.AutoCull.prototype = {
            autoCull: !1, inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                }
            }
        },i.Component.Bounds = function() {
        },i.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            }, offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            }, centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                }, set: function(t) {
                    this.x = t + this.offsetX - .5 * this.width
                }
            }, centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                }, set: function(t) {
                    this.y = t + this.offsetY - .5 * this.height
                }
            }, left: {
                get: function() {
                    return this.x - this.offsetX
                }, set: function(t) {
                    this.x = t + this.offsetX
                }
            }, right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                }, set: function(t) {
                    this.x = t - this.width + this.offsetX
                }
            }, top: {
                get: function() {
                    return this.y - this.offsetY
                }, set: function(t) {
                    this.y = t + this.offsetY
                }
            }, bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                }, set: function(t) {
                    this.y = t - this.height + this.offsetY
                }
            }, alignIn: function(t, e, n, s) {
                switch(void 0 === n && (n = 0), void 0 === s && (s = 0), e) {
                    default:
                    case i.TOP_LEFT:
                        this.left = t.left - n, this.top = t.top - s;
                        break;
                    case i.TOP_CENTER:
                        this.centerX = t.centerX + n, this.top = t.top - s;
                        break;
                    case i.TOP_RIGHT:
                        this.right = t.right + n, this.top = t.top - s;
                        break;
                    case i.LEFT_CENTER:
                        this.left = t.left - n, this.centerY = t.centerY + s;
                        break;
                    case i.CENTER:
                        this.centerX = t.centerX + n, this.centerY = t.centerY + s;
                        break;
                    case i.RIGHT_CENTER:
                        this.right = t.right + n, this.centerY = t.centerY + s;
                        break;
                    case i.BOTTOM_LEFT:
                        this.left = t.left - n, this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_CENTER:
                        this.centerX = t.centerX + n, this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_RIGHT:
                        this.right = t.right + n, this.bottom = t.bottom + s
                }
                return this
            }, alignTo: function(t, e, n, s) {
                switch(void 0 === n && (n = 0), void 0 === s && (s = 0), e) {
                    default:
                    case i.TOP_LEFT:
                        this.left = t.left - n, this.bottom = t.top - s;
                        break;
                    case i.TOP_CENTER:
                        this.centerX = t.centerX + n, this.bottom = t.top - s;
                        break;
                    case i.TOP_RIGHT:
                        this.right = t.right + n, this.bottom = t.top - s;
                        break;
                    case i.LEFT_TOP:
                        this.right = t.left - n, this.top = t.top - s;
                        break;
                    case i.LEFT_CENTER:
                        this.right = t.left - n, this.centerY = t.centerY + s;
                        break;
                    case i.LEFT_BOTTOM:
                        this.right = t.left - n, this.bottom = t.bottom + s;
                        break;
                    case i.RIGHT_TOP:
                        this.left = t.right + n, this.top = t.top - s;
                        break;
                    case i.RIGHT_CENTER:
                        this.left = t.right + n, this.centerY = t.centerY + s;
                        break;
                    case i.RIGHT_BOTTOM:
                        this.left = t.right + n, this.bottom = t.bottom + s;
                        break;
                    case i.BOTTOM_LEFT:
                        this.left = t.left - n, this.top = t.bottom + s;
                        break;
                    case i.BOTTOM_CENTER:
                        this.centerX = t.centerX + n, this.top = t.bottom + s;
                        break;
                    case i.BOTTOM_RIGHT:
                        this.right = t.right + n, this.top = t.bottom + s
                }
                return this
            }
        },i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn,i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo,i.Component.BringToTop = function() {
        },i.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringToTop(this), this
        },i.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendToBack(this), this
        },i.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this), this
        },i.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this), this
        },i.Component.Core = function() {
        },i.Component.Core.install = function(t) {
            i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {};
            for(var e = 0; e < t.length; e++) {
                var n = t[e], s = !1;
                "Destroy" === n && (s = !0), i.Utils.mixinPrototype(this, i.Component[n].prototype, s), this.components[n] = !0
            }
        },i.Component.Core.init = function(t, e, n, s, r) {
            this.game = t, this.key = s, this.data = {}, this.position.set(e, n), this.world = new i.Point(e, n), this.previousPosition = new i.Point(e, n), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, r), this.components.FixedToCamera && (this.cameraOffset = new i.Point(e, n))
        },i.Component.Core.preUpdate = function() {
            if(this.pendingDestroy)return void this.destroy();
            if(this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists)return this.renderOrderID = -1, !1;
            this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
            for(var t = 0; t < this.children.length; t++)this.children[t].preUpdate();
            return !0
        },i.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                }, set: function(t) {
                    t ? (this._exists = !0, this.visible = !0) : (this._exists = !1, this.visible = !1)
                }
            },
            update: function() {
            },
            postUpdate: function() {
                this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && i.Component.FixedToCamera.postUpdate.call(this);
                for(var t = 0; t < this.children.length; t++)this.children[t].postUpdate()
            }
        },i.Component.Crop = function() {
        },i.Component.Crop.prototype = {
            cropRect: null, _crop: null, crop: function(t, e) {
                void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
            }, updateCrop: function() {
                if(this.cropRect) {
                    var t = this.texture.crop.x, e = this.texture.crop.y, n = this.texture.crop.width,
                        s = this.texture.crop.height;
                    this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var r = Math.max(this._frame.x, this._crop.x), o = Math.max(this._frame.y, this._crop.y),
                        a = Math.min(this._frame.right, this._crop.right) - r,
                        h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                    this.texture.crop.x = r, this.texture.crop.y = o, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === r && e === o && n === a && s === h || (this.texture.requiresReTint = !0)
                }
            }
        },i.Component.Delta = function() {
        },i.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            }, deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            }, deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        },i.Component.Destroy = function() {
        },i.Component.Destroy.prototype = {
            destroyPhase: !1, destroy: function(t, e) {
                if(null !== this.game && !this.destroyPhase) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var n = this.children.length;
                    if(t)for(; n--;)this.children[n].destroy(t); else for(; n--;)this.removeChild(this.children[n]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        },i.Events = function(t) {
            this.parent = t
        },i.Events.prototype = {
            destroy: function() {
                this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onRemovedFromWorld: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        },i.Events.prototype.constructor = i.Events;
        for(var s in i.Events.prototype)i.Events.prototype.hasOwnProperty(s) && 0 === s.indexOf("on") && null === i.Events.prototype[s] && !function(t, e) {
            Object.defineProperty(i.Events.prototype, t, {
                get: function() {
                    return this[e] || (this[e] = new i.Signal)
                }
            }), i.Events.prototype[t + "$dispatch"] = function() {
                return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
            }
        }(s, "_" + s);
        i.Component.FixedToCamera = function() {
        }, i.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, i.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1, fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                }, set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            }, cameraOffset: new i.Point
        }, i.Component.Health = function() {
        }, i.Component.Health.prototype = {
            health: 1, maxHealth: 100, damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            }, setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            }, heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, i.Component.InCamera = function() {
        }, i.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.InputEnabled = function() {
        }, i.Component.InputEnabled.prototype = {
            input: null, inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                }, set: function(t) {
                    t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, i.Component.InWorld = function() {
        }, i.Component.InWorld.preUpdate = function() {
            if(this.autoCull || this.checkWorldBounds) {
                if(this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)if(this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++; else if(this.renderable = !1, this.outOfCameraBoundsKill)return this.kill(), !1;
                if(this.checkWorldBounds)if(this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this); else if(!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill))return this.kill(), !1
            }
            return !0
        }, i.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, i.Component.LifeSpan = function() {
        }, i.Component.LifeSpan.preUpdate = function() {
            return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
        }, i.Component.LifeSpan.prototype = {
            alive: !0, lifespan: 0, revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            }, kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, i.Component.LoadTexture = function() {
        }, i.Component.LoadTexture.prototype = {
            customRender: !1, _frame: null, loadTexture: function(t, e, n) {
                t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (n || void 0 === n) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var s = this.game.cache, r = !0, o = !this.texture.baseTexture.scaleMode;
                if(i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t); else if(i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), r = s.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0); else if(i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas)); else if(t instanceof PIXI.Texture) this.setTexture(t); else {
                    var a = s.getImage(t, !0);
                    this.key = a.key, this.setTexture(new PIXI.Texture(a.base)), "__default" === t ? this.texture.baseTexture.skipRender = !0 : this.texture.baseTexture.skipRender = !1, r = !this.animations.loadFrameData(a.frameData, e)
                }
                r && (this._frame = i.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
            }, setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            }, resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            }, resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            }, frame: {
                get: function() {
                    return this.animations.frame
                }, set: function(t) {
                    this.animations.frame = t
                }
            }, frameName: {
                get: function() {
                    return this.animations.frameName
                }, set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, i.Component.Overlap = function() {
        }, i.Component.Overlap.prototype = {
            overlap: function(t) {
                return i.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, i.Component.PhysicsBody = function() {
        }, i.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, i.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, i.Component.PhysicsBody.prototype = {
            body: null, x: {
                get: function() {
                    return this.position.x
                }, set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }, y: {
                get: function() {
                    return this.position.y
                }, set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, i.Component.Reset = function() {
        }, i.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, i.Component.ScaleMinMax = function() {
        }, i.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, n, s) {
                void 0 === e ? e = n = s = t : void 0 === n && (n = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === n ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(n, s) : this.scaleMax = new i.Point(n, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, i.Component.Smoothed = function() {
        }, i.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                }, set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, i.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            }, image: function(t, e, n, s, r) {
                return void 0 === r && (r = this.world), r.add(new i.Image(this.game, t, e, n, s))
            }, sprite: function(t, e, i, n, s) {
                return void 0 === s && (s = this.world), s.create(t, e, i, n)
            }, tween: function(t) {
                return this.game.tweens.create(t)
            }, group: function(t, e, n, s, r) {
                return new i.Group(this.game, t, e, n, s, r)
            }, physicsGroup: function(t, e, n, s) {
                return new i.Group(this.game, e, n, s, (!0), t)
            }, spriteBatch: function(t, e, n) {
                return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === n && (n = !1), new i.SpriteBatch(this.game, t, e, n)
            }, tileSprite: function(t, e, n, s, r, o, a) {
                return void 0 === a && (a = this.world), a.add(new i.TileSprite(this.game, t, e, n, s, r, o))
            }, rope: function(t, e, n, s, r, o) {
                return void 0 === o && (o = this.world), o.add(new i.Rope(this.game, t, e, n, s, r))
            }, text: function(t, e, n, s, r) {
                return void 0 === r && (r = this.world), r.add(new i.Text(this.game, t, e, n, s))
            }, button: function(t, e, n, s, r, o, a, h, l, c) {
                return void 0 === c && (c = this.world), c.add(new i.Button(this.game, t, e, n, s, r, o, a, h, l))
            }, graphics: function(t, e, n) {
                return void 0 === n && (n = this.world), n.add(new i.Graphics(this.game, t, e))
            }, emitter: function(t, e, n) {
                return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, n))
            }, tilemap: function(t, e, n, s, r) {
                return new i.Tilemap(this.game, t, e, n, s, r)
            }, renderTexture: function(t, e, n, s) {
                void 0 !== n && "" !== n || (n = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var r = new i.RenderTexture(this.game, t, e, n);
                return s && this.game.cache.addRenderTexture(n, r), r
            }, bitmapData: function(t, e, n, s) {
                void 0 === s && (s = !1), void 0 !== n && "" !== n || (n = this.game.rnd.uuid());
                var r = new i.BitmapData(this.game, n, t, e);
                return s && this.game.cache.addBitmapData(n, r), r
            }, plugin: function(t) {
                return this.game.plugins.add(t)
            }
        }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectCreator.prototype = {
            image: function(t, e, n, s) {
                return new i.Image(this.game, t, e, n, s)
            }, sprite: function(t, e, n, s) {
                return new i.Sprite(this.game, t, e, n, s)
            }, tween: function(t) {
                return new i.Tween(t, this.game, this.game.tweens)
            }, group: function(t, e, n, s, r) {
                return new i.Group(this.game, t, e, n, s, r)
            }, spriteBatch: function(t, e, n) {
                return void 0 === e && (e = "group"), void 0 === n && (n = !1), new i.SpriteBatch(this.game, t, e, n)
            }, tileSprite: function(t, e, n, s, r, o) {
                return new i.TileSprite(this.game, t, e, n, s, r, o)
            }, rope: function(t, e, n, s, r) {
                return new i.Rope(this.game, t, e, n, s, r)
            }, text: function(t, e, n, s) {
                return new i.Text(this.game, t, e, n, s)
            }, button: function(t, e, n, s, r, o, a, h, l) {
                return new i.Button(this.game, t, e, n, s, r, o, a, h, l)
            }, graphics: function(t, e) {
                return new i.Graphics(this.game, t, e)
            }, emitter: function(t, e, n) {
                return new i.Particles.Arcade.Emitter(this.game, t, e, n)
            }, tilemap: function(t, e, n, s, r) {
                return new i.Tilemap(this.game, t, e, n, s, r)
            }, renderTexture: function(t, e, n, s) {
                void 0 !== n && "" !== n || (n = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var r = new i.RenderTexture(this.game, t, e, n);
                return s && this.game.cache.addRenderTexture(n, r), r
            }, bitmapData: function(t, e, n, s) {
                void 0 === s && (s = !1), void 0 !== n && "" !== n || (n = this.game.rnd.uuid());
                var r = new i.BitmapData(this.game, n, t, e);
                return s && this.game.cache.addBitmapData(n, r), r
            }
        }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, n, s, r)
        }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Image = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, n, s, r)
        }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && this.preUpdateCore()
        }, i.Button = function(t, e, n, s, r, o, a, h, l, c) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, o = o || this, i.Image.call(this, t, e, n, s, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, c), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
        var r = "Over", o = "Out", a = "Down", h = "Up";
        i.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, i.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, i.Button.prototype.setStateFrame = function(t, e, i) {
            var n = "_on" + t + "Frame";
            null !== e ? (this[n] = e, i && this.changeStateFrame(t)) : this[n] = null
        }, i.Button.prototype.changeStateFrame = function(t) {
            if(this.freezeFrames)return !1;
            var e = "_on" + t + "Frame", i = this[e];
            return "string" == typeof i ? (this.frameName = i, !0) : "number" == typeof i && (this.frame = i, !0)
        }, i.Button.prototype.setFrames = function(t, e, i, n) {
            this.setStateFrame(r, t, this.input.pointerOver()), this.setStateFrame(o, e, !this.input.pointerOver()), this.setStateFrame(a, i, this.input.pointerDown()), this.setStateFrame(h, n, this.input.pointerUp())
        }, i.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame(r), this.onOverMouseOnly && !e.isMouse || this.onInputOver && this.onInputOver.dispatch(this, e))
        }, i.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame(o), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, i.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame(a), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, i.Button.prototype.onInputUpHandler = function(t, e, i) {
            if(this.onInputUp && this.onInputUp.dispatch(this, e, i), !this.freezeFrames)if(this.forceOut === !0 || (this.forceOut & e.pointerMode) === e.pointerMode) this.changeStateFrame(o); else {
                var n = this.changeStateFrame(h);
                n || (i ? this.changeStateFrame(r) : this.changeStateFrame(o))
            }
        }, i.SpriteBatch = function(t, e, n, s) {
            void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), i.Group.call(this, t, e, n, s), this.type = i.SPRITEBATCH
        }, i.SpriteBatch.prototype = i.Utils.extend(!0, i.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.BitmapData = function(t, e, n, s, r) {
            void 0 !== n && 0 !== n || (n = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === r && (r = !1), this.game = t, this.key = e, this.width = n, this.height = s, this.canvas = i.Canvas.create(this, n, s, null, r), this.context = this.canvas.getContext("2d", {alpha: !0}), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, n, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0
        }, i.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            }, moveH: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas, n = i.getContext("2d"), s = this.height, r = this.canvas;
                if(n.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var o = this.width - t;
                    e && n.drawImage(r, 0, 0, t, s, o, 0, t, s), n.drawImage(r, t, 0, o, s, 0, 0, o, s)
                } else {
                    var o = this.width - t;
                    e && n.drawImage(r, o, 0, t, s, 0, 0, t, s), n.drawImage(r, 0, 0, o, s, t, 0, o, s)
                }
                return this.clear(), this.copy(this._swapCanvas)
            }, moveV: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas, n = i.getContext("2d"), s = this.width, r = this.canvas;
                if(n.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var o = this.height - t;
                    e && n.drawImage(r, 0, 0, s, t, 0, o, s, t), n.drawImage(r, 0, t, s, o, 0, 0, s, o)
                } else {
                    var o = this.height - t;
                    e && n.drawImage(r, 0, o, s, t, 0, 0, s, t), n.drawImage(r, 0, 0, s, o, 0, t, s, o)
                }
                return this.clear(), this.copy(this._swapCanvas)
            }, add: function(t) {
                if(Array.isArray(t))for(var e = 0; e < t.length; e++)t[e].loadTexture && t[e].loadTexture(this); else t.loadTexture(this);
                return this
            }, load: function(t) {
                if("string" == typeof t && (t = this.game.cache.getImage(t)), t)return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            }, clear: function(t, e, i, n) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), this.context.clearRect(t, e, i, n), this.dirty = !0, this
            }, fill: function(t, e, i, n) {
                return void 0 === n && (n = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + n + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            }, generateTexture: function(t) {
                var e = new Image;
                e.src = this.canvas.toDataURL("image/png");
                var i = this.game.cache.addImage(t, "", e);
                return new PIXI.Texture(i.base)
            }, resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            }, update: function(t, e, i, n) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === n && (n = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, n), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            }, processPixelRGB: function(t, e, n, s, r, o) {
                void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = this.width), void 0 === o && (o = this.height);
                for(var a = n + r, h = s + o, l = i.Color.createColor(), c = {r: 0, g: 0, b: 0, a: 0}, u = !1,
                        d = s; d < h; d++)for(var p = n; p < a; p++)i.Color.unpackPixel(this.getPixel32(p, d), l), c = t.call(e, l, p, d), c !== !1 && null !== c && void 0 !== c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            }, processPixel: function(t, e, i, n, s, r) {
                void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === r && (r = this.height);
                for(var o = i + s, a = n + r, h = 0, l = 0, c = !1,
                        u = n; u < a; u++)for(var d = i; d < o; d++)h = this.getPixel32(d, u), l = t.call(e, h, d, u), l !== h && (this.pixels[u * this.width + d] = l, c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            }, replaceRGB: function(t, e, n, s, r, o, a, h, l) {
                var c = 0, u = 0, d = this.width, p = this.height, f = i.Color.packPixel(t, e, n, s);
                void 0 !== l && l instanceof i.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                for(var g = 0; g < p; g++)for(var m = 0; m < d; m++)this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            }, setHSL: function(t, e, n, s) {
                var r = t || 0 === t, o = e || 0 === e, a = n || 0 === n;
                if(r || o || a) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for(var h = i.Color.createColor(),
                            l = s.y; l < s.bottom; l++)for(var c = s.x; c < s.right; c++)i.Color.unpackPixel(this.getPixel32(c, l), h, !0), r && (h.h = t), o && (h.s = e), a && (h.l = n), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            }, shiftHSL: function(t, e, n, s) {
                if(void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== n && null !== n || (n = !1), t || e || n) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for(var r = i.Color.createColor(),
                            o = s.y; o < s.bottom; o++)for(var a = s.x; a < s.right; a++)i.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), e && (r.s = this.game.math.clamp(r.s + e, 0, 1)), n && (r.l = this.game.math.clamp(r.l + n, 0, 1)), i.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            }, setPixel32: function(t, e, n, s, r, o, a) {
                return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = o << 24 | r << 16 | s << 8 | n : this.pixels[e * this.width + t] = n << 24 | s << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            }, setPixel: function(t, e, i, n, s, r) {
                return this.setPixel32(t, e, i, n, s, 255, r)
            }, getPixel: function(t, e, n) {
                n || (n = i.Color.createColor());
                var s = ~~(t + e * this.width);
                return s *= 4, n.r = this.data[s], n.g = this.data[++s], n.b = this.data[++s], n.a = this.data[++s], n
            }, getPixel32: function(t, e) {
                if(t >= 0 && t <= this.width && e >= 0 && e <= this.height)return this.pixels[e * this.width + t]
            }, getPixelRGB: function(t, e, n, s, r) {
                return i.Color.unpackPixel(this.getPixel32(t, e), n, s, r)
            }, getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            }, getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = i.Color.createColor(), n = 0, s = 0, r = 1, o = !1;
                1 === t ? (r = -1, s = this.height) : 3 === t && (r = -1, n = this.width);
                do i.Color.unpackPixel(this.getPixel32(n, s), e), 0 === t || 1 === t ? (n++, n === this.width && (n = 0, s += r, (s >= this.height || s <= 0) && (o = !0))) : 2 !== t && 3 !== t || (s++, s === this.height && (s = 0, n += r, (n >= this.width || n <= 0) && (o = !0))); while(0 === e.a && !o);
                return e.x = n, e.y = s, e
            }, getBounds: function(t) {
                return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            }, addToWorld: function(t, e, i, n, s, r) {
                s = s || 1, r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, n), o.scale.set(s, r), o
            }, copy: function(t, e, n, s, r, o, a, h, l, c, u, d, p, f, g, m, y) {
                if(void 0 !== t && null !== t || (t = this), (t instanceof i.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== o && null !== o || (o = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (o += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)); else {
                    if(this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas; else if("string" == typeof t) {
                        if(t = this.game.cache.getImage(t), null === t)return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if(void 0 !== e && null !== e || (e = 0), void 0 !== n && null !== n || (n = 0), s && (this._size.x = s), r && (this._size.y = r), void 0 !== o && null !== o || (o = e), void 0 !== a && null !== a || (a = n), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var v = this.context;
                    return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, m && (this.op = m), y && (o |= 0, a |= 0), v.translate(o, a), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + e, this._pos.y + n, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            }, copyTransform: function(t, e, n) {
                if(void 0 === e && (e = null), void 0 === n && (n = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha)return this;
                var s = t.worldTransform;
                if(this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y)return this;
                t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var r = s.tx, o = s.ty;
                t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), n && (r |= 0, o |= 0);
                var a = this.context;
                return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(s.a, s.b, s.c, s.d, r, o), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
            }, copyRect: function(t, e, i, n, s, r, o) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, n, e.width, e.height, 0, 0, 0, 1, 1, s, r, o)
            }, draw: function(t, e, i, n, s, r, o) {
                return this.copy(t, null, null, null, null, e, i, n, s, null, null, null, null, null, null, r, o)
            }, drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            }, drawGroupProxy: function(t, e, n) {
                if(t.hasOwnProperty("texture") && this.copyTransform(t, e, n), t.type === i.GROUP && t.exists) this.drawGroup(t, e, n); else if(t.hasOwnProperty("children") && t.children.length > 0)for(var s = 0; s < t.children.length; s++)t.children[s].exists && this.copyTransform(t.children[s], e, n)
            }, drawFull: function(t, e, n) {
                if(t.worldVisible === !1 || 0 === t.worldAlpha || t.hasOwnProperty("exists") && t.exists === !1)return this;
                if(t.type !== i.GROUP && t.type !== i.EMITTER)if(t.type === i.GRAPHICS) {
                    var s = t.getBounds();
                    this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, n);
                if(t.children)for(var r = 0; r < t.children.length; r++)this.drawFull(t.children[r], e, n);
                return this
            }, shadow: function(t, e, i, n) {
                var s = this.context;
                return void 0 === t || null === t ? s.shadowColor = "rgba(0,0,0,0)" : (s.shadowColor = t, s.shadowBlur = e || 5, s.shadowOffsetX = i || 10, s.shadowOffsetY = n || 10), this
            }, alphaMask: function(t, e, i, n) {
                return void 0 === n || null === n ? this.draw(e).blendSourceAtop() : this.draw(e, n.x, n.y, n.width, n.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            }, extract: function(t, e, i, n, s, r, o, a, h) {
                return void 0 === s && (s = 255), void 0 === r && (r = !1), void 0 === o && (o = e), void 0 === a && (a = i), void 0 === h && (h = n), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, c) {
                    return r.r === e && r.g === i && r.b === n && t.setPixel32(l, c, o, a, h, s, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            }, rect: function(t, e, i, n, s) {
                return "undefined" != typeof s && (this.context.fillStyle = s), this.context.fillRect(t, e, i, n), this
            }, text: function(t, e, i, n, s, r) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = "14px Courier"), void 0 === s && (s = "rgb(255,255,255)"), void 0 === r && (r = !0);
                var o = this.context, a = o.font;
                return o.font = n, r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = s, o.fillText(t, e, i), o.font = a, this
            }, circle: function(t, e, i, n) {
                var s = this.context;
                return void 0 !== n && (s.fillStyle = n), s.beginPath(), s.arc(t, e, i, 0, 2 * Math.PI, !1), s.closePath(), s.fill(), this
            }, line: function(t, e, i, n, s, r) {
                void 0 === s && (s = "#fff"), void 0 === r && (r = 1);
                var o = this.context;
                return o.beginPath(), o.moveTo(t, e), o.lineTo(i, n), o.lineWidth = r, o.strokeStyle = s, o.stroke(), o.closePath(), this
            }, textureLine: function(t, e, n) {
                if(void 0 === n && (n = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var s = t.length;
                    "no-repeat" === n && s > e.width && (s = e.width);
                    var r = this.context;
                    return r.fillStyle = r.createPattern(e, n), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(t.angle), r.fillRect(0, 0, s, e.height), r.restore(), this.dirty = !0, this
                }
            }, render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            }, destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            }, blendReset: function() {
                return this.op = "source-over", this
            }, blendSourceOver: function() {
                return this.op = "source-over", this
            }, blendSourceIn: function() {
                return this.op = "source-in", this
            }, blendSourceOut: function() {
                return this.op = "source-out", this
            }, blendSourceAtop: function() {
                return this.op = "source-atop", this
            }, blendDestinationOver: function() {
                return this.op = "destination-over", this
            }, blendDestinationIn: function() {
                return this.op = "destination-in", this
            }, blendDestinationOut: function() {
                return this.op = "destination-out", this
            }, blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            }, blendXor: function() {
                return this.op = "xor", this
            }, blendAdd: function() {
                return this.op = "lighter", this
            }, blendMultiply: function() {
                return this.op = "multiply", this
            }, blendScreen: function() {
                return this.op = "screen", this
            }, blendOverlay: function() {
                return this.op = "overlay", this
            }, blendDarken: function() {
                return this.op = "darken", this
            }, blendLighten: function() {
                return this.op = "lighten", this
            }, blendColorDodge: function() {
                return this.op = "color-dodge", this
            }, blendColorBurn: function() {
                return this.op = "color-burn", this
            }, blendHardLight: function() {
                return this.op = "hard-light", this
            }, blendSoftLight: function() {
                return this.op = "soft-light", this
            }, blendDifference: function() {
                return this.op = "difference", this
            }, blendExclusion: function() {
                return this.op = "exclusion", this
            }, blendHue: function() {
                return this.op = "hue", this
            }, blendSaturation: function() {
                return this.op = "saturation", this
            }, blendColor: function() {
                return this.op = "color", this
            }, blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(i.BitmapData.prototype, "smoothed", {
            get: function() {
                i.Canvas.getSmoothingEnabled(this.context)
            }, set: function(t) {
                i.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(i.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            }, set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), i.BitmapData.getTransform = function(t, e, i, n, s, r) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof n && (n = 1), "number" != typeof s && (s = 0), "number" != typeof r && (r = 0), {
                sx: i,
                sy: n,
                scaleX: i,
                scaleY: n,
                skewX: s,
                skewY: r,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, i.BitmapData.prototype.constructor = i.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new PIXI.Polygon([t, e])), this
        }, PIXI.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var s, r, o = 20, a = this.currentPath.shape.points;
            0 === a.length && this.moveTo(0, 0);
            for(var h = a[a.length - 2], l = a[a.length - 1], c = 0,
                    u = 1; u <= o; ++u)c = u / o, s = h + (t - h) * c, r = l + (e - l) * c, a.push(s + (t + (i - t) * c - s) * c, r + (e + (n - e) * c - r) * c);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, n, s, r) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for(var o, a, h, l, c, u = 20, d = this.currentPath.shape.points, p = d[d.length - 2], f = d[d.length - 1],
                    g = 0,
                    m = 1; m <= u; ++m)g = m / u, o = 1 - g, a = o * o, h = a * o, l = g * g, c = l * g, d.push(h * p + 3 * a * g * t + 3 * o * l * i + c * s, h * f + 3 * a * g * e + 3 * o * l * n + c * r);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(t, e, i, n, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var r = this.currentPath.shape.points, o = r[r.length - 2], a = r[r.length - 1], h = a - e, l = o - t,
                c = n - e, u = i - t, d = Math.abs(h * u - l * c);
            if(d < 1e-8 || 0 === s) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e); else {
                var p = h * h + l * l, f = c * c + u * u, g = h * c + l * u, m = s * Math.sqrt(p) / d,
                    y = s * Math.sqrt(f) / d, v = m * g / p, x = y * g / f, _ = m * u + y * l, b = m * c + y * h,
                    w = l * (y + v), T = h * (y + v), P = u * (m + x), C = c * (m + x), S = Math.atan2(T - b, w - _),
                    I = Math.atan2(C - b, P - _);
                this.arc(_ + t, b + e, s, S, I, l * c > u * h)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(t, e, i, n, s, r, o) {
            if(n === s)return this;
            void 0 === r && (r = !1), void 0 === o && (o = 40), !r && s <= n ? s += 2 * Math.PI : r && n <= s && (n += 2 * Math.PI);
            var a = r ? (n - s) * -1 : s - n, h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
            if(0 === a)return this;
            var l = t + Math.cos(n) * i, c = e + Math.sin(n) * i;
            r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
            for(var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d),
                    m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                var x = v + y * v, _ = d + n + p * x, b = Math.cos(_), w = -Math.sin(_);
                u.push((f * b + g * w) * i + t, (f * -w + g * b) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(t, e, i, n) {
            return this.drawShape(new PIXI.Rectangle(t, e, i, n)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, n, s) {
            return this.drawShape(new PIXI.RoundedRectangle(t, e, i, n, s)), this
        }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new PIXI.Circle(t, e, i)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, n) {
            return this.drawShape(new PIXI.Ellipse(t, e, i, n)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof i.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
            var e = t;
            if(!Array.isArray(e)) {
                e = new Array(arguments.length);
                for(var n = 0; n < e.length; ++n)e[n] = arguments[n]
            }
            return this.drawShape(new i.Polygon(e)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var n = this.getBounds();
            n.width += i, n.height += i;
            var s = new PIXI.CanvasBuffer(n.width * t, n.height * t), r = PIXI.Texture.fromCanvas(s.canvas, e);
            return r.baseTexture.resolution = t, s.context.scale(t, t), s.context.translate(-n.x, -n.y), PIXI.CanvasGraphics.renderGraphics(this, s.context), r
        }, PIXI.Graphics.prototype._renderCanvas = function(t) {
            if(this.visible !== !1 && 0 !== this.alpha && this.isMask !== !0) {
                if(this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap)return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context, i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var n = t.resolution, s = i.tx * t.resolution + t.shakeX, r = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * n, i.b * n, i.c * n, i.d * n, s, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                for(var o = 0; o < this.children.length; o++)this.children[o]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, PIXI.Graphics.prototype.getBounds = function(t) {
            if(!this._currentBounds) {
                if(!this.renderable)return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var e = this._localBounds, i = e.x, n = e.width + e.x, s = e.y, r = e.height + e.y,
                    o = t || this.worldTransform, a = o.a, h = o.b, l = o.c, c = o.d, u = o.tx, d = o.ty,
                    p = a * n + l * r + u, f = c * r + h * n + d, g = a * i + l * r + u, m = c * r + h * i + d,
                    y = a * i + l * s + u, v = c * s + h * i + d, x = a * n + l * s + u, _ = c * s + h * n + d, b = p,
                    w = f, T = p, P = f;
                T = g < T ? g : T, T = y < T ? y : T, T = x < T ? x : T, P = m < P ? m : P, P = v < P ? v : P, P = _ < P ? _ : P, b = g > b ? g : b, b = y > b ? y : b, b = x > b ? x : b, w = m > w ? m : w, w = v > w ? v : w, w = _ > w ? _ : w, this._bounds.x = T, this._bounds.width = b - T, this._bounds.y = P, this._bounds.height = w - P, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for(var e = 0; e < this.children.length; e++)this.children[e].updateTransform();
            var i = this.getBounds();
            for(this.worldTransform = t, e = 0; e < this.children.length; e++)this.children[e].updateTransform();
            return i
        }, PIXI.Graphics.prototype.containsPoint = function(t) {
            this.worldTransform.applyInverse(t, tempPoint);
            for(var e = this.graphicsData, i = 0; i < e.length; i++) {
                var n = e[i];
                if(n.fill && n.shape && n.shape.contains(tempPoint.x, tempPoint.y))return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0, e = -(1 / 0), n = 1 / 0, s = -(1 / 0);
            if(this.graphicsData.length)for(var r, o, a, h, l, c, u = 0; u < this.graphicsData.length; u++) {
                var d = this.graphicsData[u], p = d.type, f = d.lineWidth;
                if(r = d.shape, p === PIXI.Graphics.RECT || p === PIXI.Graphics.RREC) a = r.x - f / 2, h = r.y - f / 2, l = r.width + f, c = r.height + f, t = a < t ? a : t, e = a + l > e ? a + l : e, n = h < n ? h : n, s = h + c > s ? h + c : s; else if(p === PIXI.Graphics.CIRC) a = r.x, h = r.y, l = r.radius + f / 2, c = r.radius + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, n = h - c < n ? h - c : n, s = h + c > s ? h + c : s; else if(p === PIXI.Graphics.ELIP) a = r.x, h = r.y, l = r.width + f / 2, c = r.height + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, n = h - c < n ? h - c : n, s = h + c > s ? h + c : s; else {
                    o = r.points;
                    for(var g = 0; g < o.length; g++)o[g] instanceof i.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++), t = a - f < t ? a - f : t, e = a + f > e ? a + f : e, n = h - f < n ? h - f : n, s = h + f > s ? h + f : s
                }
            } else t = 0, e = 0, n = 0, s = 0;
            var m = this.boundsPadding;
            this._localBounds.x = t - m, this._localBounds.width = e - t + 2 * m, this._localBounds.y = n - m, this._localBounds.height = s - n + 2 * m
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if(this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height); else {
                var e = new PIXI.CanvasBuffer(t.width, t.height), i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -(t.x / t.width), this._cachedSprite.anchor.y = -(t.y / t.height), this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite, e = t.texture, i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone(), t.flatten());
            var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            }, set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(t, e, i, n, s, r, o) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = n, this.fillAlpha = s, this._fillTint = n, this.fill = r, this.shape = o, this.type = o.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var n = e && e.length, s = n ? e[0] * i : t.length, r = PIXI.EarCut.linkedList(t, 0, s, i, !0), o = [];
            if(!r)return o;
            var a, h, l, c, u, d, p;
            if(n && (r = PIXI.EarCut.eliminateHoles(t, e, r, i)), t.length > 80 * i) {
                a = l = t[0], h = c = t[1];
                for(var f = i; f < s; f += i)u = t[f], d = t[f + 1], u < a && (a = u), d < h && (h = d), u > l && (l = u), d > c && (c = d);
                p = Math.max(l - a, c - h)
            }
            return PIXI.EarCut.earcutLinked(r, o, i, a, h, p), o
        }, PIXI.EarCut.linkedList = function(t, e, i, n, s) {
            var r, o, a, h = 0;
            for(r = e, o = i - n; r < i; r += n)h += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
            if(s === h > 0)for(r = e; r < i; r += n)a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a); else for(r = i - n; r >= e; r -= n)a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
            return a
        }, PIXI.EarCut.filterPoints = function(t, e) {
            if(!t)return t;
            e || (e = t);
            var i, n = t;
            do if(i = !1, n.steiner || !PIXI.EarCut.equals(n, n.next) && 0 !== PIXI.EarCut.area(n.prev, n, n.next)) n = n.next; else {
                if(PIXI.EarCut.removeNode(n), n = e = n.prev, n === n.next)return null;
                i = !0
            } while(i || n !== e);
            return e
        }, PIXI.EarCut.earcutLinked = function(t, e, i, n, s, r, o) {
            if(t) {
                !o && r && PIXI.EarCut.indexCurve(t, n, s, r);
                for(var a, h,
                        l = t; t.prev !== t.next;)if(a = t.prev, h = t.next, r ? PIXI.EarCut.isEarHashed(t, n, s, r) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next; else if(t = h, t === l) {
                    o ? 1 === o ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, n, s, r, 2)) : 2 === o && PIXI.EarCut.splitEarcut(t, e, i, n, s, r) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, n, s, r, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(t) {
            var e = t.prev, i = t, n = t.next;
            if(PIXI.EarCut.area(e, i, n) >= 0)return !1;
            for(var s = t.next.next; s !== t.prev;) {
                if(PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && PIXI.EarCut.area(s.prev, s, s.next) >= 0)return !1;
                s = s.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(t, e, i, n) {
            var s = t.prev, r = t, o = t.next;
            if(PIXI.EarCut.area(s, r, o) >= 0)return !1;
            for(var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x,
                    h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y,
                    l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x,
                    c = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y,
                    u = PIXI.EarCut.zOrder(a, h, e, i, n), d = PIXI.EarCut.zOrder(l, c, e, i, n),
                    p = t.nextZ; p && p.z <= d;) {
                if(p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0)return !1;
                p = p.nextZ
            }
            for(p = t.prevZ; p && p.z >= u;) {
                if(p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0)return !1;
                p = p.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
            var n = t;
            do {
                var s = n.prev, r = n.next.next;
                PIXI.EarCut.intersects(s, n, n.next, r) && PIXI.EarCut.locallyInside(s, r) && PIXI.EarCut.locallyInside(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), PIXI.EarCut.removeNode(n), PIXI.EarCut.removeNode(n.next), n = t = r), n = n.next
            } while(n !== t);
            return n
        }, PIXI.EarCut.splitEarcut = function(t, e, i, n, s, r) {
            var o = t;
            do {
                for(var a = o.next.next; a !== o.prev;) {
                    if(o.i !== a.i && PIXI.EarCut.isValidDiagonal(o, a)) {
                        var h = PIXI.EarCut.splitPolygon(o, a);
                        return o = PIXI.EarCut.filterPoints(o, o.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(o, e, i, n, s, r), void PIXI.EarCut.earcutLinked(h, e, i, n, s, r)
                    }
                    a = a.next
                }
                o = o.next
            } while(o !== t)
        }, PIXI.EarCut.eliminateHoles = function(t, e, i, n) {
            var s, r, o, a, h, l = [];
            for(s = 0, r = e.length; s < r; s++)o = e[s] * n, a = s < r - 1 ? e[s + 1] * n : t.length, h = PIXI.EarCut.linkedList(t, o, a, n, !1), h === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
            for(l.sort(compareX), s = 0; s < l.length; s++)PIXI.EarCut.eliminateHole(l[s], i), i = PIXI.EarCut.filterPoints(i, i.next);
            return i
        }, PIXI.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, PIXI.EarCut.eliminateHole = function(t, e) {
            if(e = PIXI.EarCut.findHoleBridge(t, e)) {
                var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(t, e) {
            var i, n = e, s = t.x, r = t.y, o = -(1 / 0);
            do {
                if(r <= n.y && r >= n.next.y) {
                    var a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    a <= s && a > o && (o = a, i = n.x < n.next.x ? n : n.next)
                }
                n = n.next
            } while(n !== e);
            if(!i)return null;
            if(t.x === i.x)return i.prev;
            var h, l = i, c = 1 / 0;
            for(n = i.next; n !== l;)s >= n.x && n.x >= i.x && PIXI.EarCut.pointInTriangle(r < i.y ? s : o, r, i.x, i.y, r < i.y ? o : s, r, n.x, n.y) && (h = Math.abs(r - n.y) / (s - n.x), (h < c || h === c && n.x > i.x) && PIXI.EarCut.locallyInside(n, t) && (i = n, c = h)), n = n.next;
            return i
        }, PIXI.EarCut.indexCurve = function(t, e, i, n) {
            var s = t;
            do null === s.z && (s.z = PIXI.EarCut.zOrder(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while(s !== t);
            s.prevZ.nextZ = null, s.prevZ = null, PIXI.EarCut.sortLinked(s)
        }, PIXI.EarCut.sortLinked = function(t) {
            var e, i, n, s, r, o, a, h, l = 1;
            do {
                for(i = t, t = null, r = null, o = 0; i;) {
                    for(o++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ, n); e++);
                    for(h = l; a > 0 || h > 0 && n;)0 === a ? (s = n, n = n.nextZ, h--) : 0 !== h && n ? i.z <= n.z ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, h--) : (s = i, i = i.nextZ, a--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s;
                    i = n
                }
                r.nextZ = null, l *= 2
            } while(o > 1);
            return t
        }, PIXI.EarCut.zOrder = function(t, e, i, n, s) {
            return t = 32767 * (t - i) / s, e = 32767 * (e - n) / s, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
        }, PIXI.EarCut.getLeftmost = function(t) {
            var e = t, i = t;
            do e.x < i.x && (i = e), e = e.next; while(e !== t);
            return i
        }, PIXI.EarCut.pointInTriangle = function(t, e, i, n, s, r, o, a) {
            return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0
        }, PIXI.EarCut.isValidDiagonal = function(t, e) {
            return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
        }, PIXI.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, PIXI.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, PIXI.EarCut.intersects = function(t, e, i, n) {
            return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, n) > 0 && PIXI.EarCut.area(i, n, t) > 0 != PIXI.EarCut.area(i, n, e) > 0
        }, PIXI.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if(i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e))return !0;
                i = i.next
            } while(i !== t);
            return !1
        }, PIXI.EarCut.locallyInside = function(t, e) {
            return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
        }, PIXI.EarCut.middleInside = function(t, e) {
            var i = t, n = !1, s = (t.x + e.x) / 2, r = (t.y + e.y) / 2;
            do i.y > r != i.next.y > r && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; while(i !== t);
            return n
        }, PIXI.EarCut.splitPolygon = function(t, e) {
            var i = new PIXI.EarCut.Node(t.i, t.x, t.y), n = new PIXI.EarCut.Node(e.i, e.x, e.y), s = t.next,
                r = e.prev;
            return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n
        }, PIXI.EarCut.insertNode = function(t, e, i, n) {
            var s = new PIXI.EarCut.Node(t, e, i);
            return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
        }, PIXI.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, PIXI.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.CanvasGraphics = function() {
        }, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for(var n = 0; n < t.graphicsData.length; n++) {
                var s = t.graphicsData[n], r = s.shape, o = s._fillTint, a = s._lineTint;
                if(e.lineWidth = s.lineWidth, s.type === PIXI.Graphics.POLY) {
                    e.beginPath();
                    var h = r.points;
                    e.moveTo(h[0], h[1]);
                    for(var l = 1; l < h.length / 2; l++)e.lineTo(h[2 * l], h[2 * l + 1]);
                    r.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if(s.type === PIXI.Graphics.RECT) (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fillRect(r.x, r.y, r.width, r.height)), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(r.x, r.y, r.width, r.height)); else if(s.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke()); else if(s.type === PIXI.Graphics.ELIP) {
                    var c = 2 * r.width, u = 2 * r.height, d = r.x - c / 2, p = r.y - u / 2;
                    e.beginPath();
                    var f = .5522848, g = c / 2 * f, m = u / 2 * f, y = d + c, v = p + u, x = d + c / 2, _ = p + u / 2;
                    e.moveTo(d, _), e.bezierCurveTo(d, _ - m, x - g, p, x, p), e.bezierCurveTo(x + g, p, y, _ - m, y, _), e.bezierCurveTo(y, _ + m, x + g, v, x, v), e.bezierCurveTo(x - g, v, d, _ + m, d, _), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if(s.type === PIXI.Graphics.RREC) {
                    var b = r.x, w = r.y, T = r.width, P = r.height, C = r.radius, S = Math.min(T, P) / 2 | 0;
                    C = C > S ? S : C, e.beginPath(), e.moveTo(b, w + C), e.lineTo(b, w + P - C), e.quadraticCurveTo(b, w + P, b + C, w + P), e.lineTo(b + T - C, w + P), e.quadraticCurveTo(b + T, w + P, b + T, w + P - C), e.lineTo(b + T, w + C), e.quadraticCurveTo(b + T, w, b + T - C, w), e.lineTo(b + C, w), e.quadraticCurveTo(b, w, b, w + C), e.closePath(), (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if(0 !== i) {
                e.beginPath();
                for(var n = 0; n < i; n++) {
                    var s = t.graphicsData[n], r = s.shape;
                    if(s.type === PIXI.Graphics.POLY) {
                        var o = r.points;
                        e.moveTo(o[0], o[1]);
                        for(var a = 1; a < o.length / 2; a++)e.lineTo(o[2 * a], o[2 * a + 1]);
                        o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                    } else if(s.type === PIXI.Graphics.RECT) e.rect(r.x, r.y, r.width, r.height), e.closePath(); else if(s.type === PIXI.Graphics.CIRC) e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath(); else if(s.type === PIXI.Graphics.ELIP) {
                        var h = 2 * r.width, l = 2 * r.height, c = r.x - h / 2, u = r.y - l / 2, d = .5522848,
                            p = h / 2 * d, f = l / 2 * d, g = c + h, m = u + l, y = c + h / 2, v = u + l / 2;
                        e.moveTo(c, v), e.bezierCurveTo(c, v - f, y - p, u, y, u), e.bezierCurveTo(y + p, u, g, v - f, g, v), e.bezierCurveTo(g, v + f, y + p, m, y, m), e.bezierCurveTo(y - p, m, c, v + f, c, v), e.closePath()
                    } else if(s.type === PIXI.Graphics.RREC) {
                        var x = r.x, _ = r.y, b = r.width, w = r.height, T = r.radius, P = Math.min(b, w) / 2 | 0;
                        T = T > P ? P : T, e.moveTo(x, _ + T), e.lineTo(x, _ + w - T), e.quadraticCurveTo(x, _ + w, x + T, _ + w), e.lineTo(x + b - T, _ + w), e.quadraticCurveTo(x + b, _ + w, x + b, _ + w - T), e.lineTo(x + b, _ + T), e.quadraticCurveTo(x + b, _, x + b - T, _), e.lineTo(x + T, _), e.quadraticCurveTo(x, _, x, _ + T), e.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if(16777215 !== t.tint)for(var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255,
                                           n = (255 & t.tint) / 255, s = 0; s < t.graphicsData.length; s++) {
                var r = t.graphicsData[s], o = 0 | r.fillColor, a = 0 | r.lineColor;
                r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * n * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * n * 255
            }
        }, i.Graphics = function(t, e, n) {
            void 0 === e && (e = 0), void 0 === n && (n = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.Graphics.call(this), i.Component.Core.init.call(this, t, e, n, "", null)
        }, i.Graphics.prototype = Object.create(PIXI.Graphics.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Graphics.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for(var t = 0; t < this.children.length; t++)this.children[t].postUpdate()
        }, i.Graphics.prototype.destroy = function(t) {
            this.clear(), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var n = new i.Polygon(t);
            if(e) {
                var s = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    r = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    o = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y), a = o.cross(r);
                s.dot(a) > 0 && this.drawPolygon(n)
            } else this.drawPolygon(n)
        }, i.Graphics.prototype.drawTriangles = function(t, e, n) {
            void 0 === n && (n = !1);
            var s, r = new i.Point, o = new i.Point, a = new i.Point, h = [];
            if(e)if(t[0] instanceof i.Point)for(s = 0; s < e.length / 3; s++)h.push(t[e[3 * s]]), h.push(t[e[3 * s + 1]]), h.push(t[e[3 * s + 2]]), 3 === h.length && (this.drawTriangle(h, n), h = []); else for(s = 0; s < e.length; s++)r.x = t[2 * e[s]], r.y = t[2 * e[s] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, n), h = []); else if(t[0] instanceof i.Point)for(s = 0; s < t.length / 3; s++)this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], n); else for(s = 0; s < t.length / 6; s++)r.x = t[6 * s + 0], r.y = t[6 * s + 1], o.x = t[6 * s + 2], o.y = t[6 * s + 3], a.x = t[6 * s + 4], a.y = t[6 * s + 5], this.drawTriangle([r, o, a], n)
        }, i.RenderTexture = function(t, e, n, s, r, o) {
            void 0 === s && (s = ""), void 0 === r && (r = i.scaleModes.DEFAULT), void 0 === o && (o = 1), this.game = t, this.key = s, this.type = i.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, n, this.game.renderer, r, o), this.render = i.RenderTexture.prototype.render
        }, i.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, i, n) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderCanvas(t, this._tempMatrix, n)
        }, i.RenderTexture.prototype.renderRawXY = function(t, e, i, n) {
            this._tempMatrix.identity().translate(e, i), this.renderCanvas(t, this._tempMatrix, n)
        },i.RenderTexture.prototype.render = function(t, e, i) {
            void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderCanvas(t, this._tempMatrix, i)
        },i.Text = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = void 0 === s || null === s ? "" : s.toString(), r = i.Utils.extend({}, r), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, n, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(r), "" !== s && this.updateText()
        },i.Text.prototype = Object.create(i.Sprite.prototype),i.Text.prototype.constructor = i.Text,i.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        },i.Text.prototype.update = function() {
        },i.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t)
        },i.Text.prototype.setShadow = function(t, e, i, n, s, r) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === n && (n = 0), void 0 === s && (s = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = n, this.style.shadowStroke = s, this.style.shadowFill = r, this.dirty = !0, this
        },i.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1), t = t || {}, t.font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
            var i = this.fontToComponents(t.font);
            return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
        },i.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(/(?:\r\n|\r|\n)/), i = this.style.tabs, n = [], s = 0,
                r = this.determineFontProperties(this.style.font), o = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
            for(var a = 0; a < o; a++) {
                if(0 === i) {
                    var h = this.style.strokeThickness + this.padding.x;
                    h += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(e[a]) : this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                } else {
                    var l = e[a].split(/(?:\t)/), h = this.padding.x + this.style.strokeThickness;
                    if(Array.isArray(i))for(var c = 0, u = 0; u < l.length; u++) {
                        var d = 0;
                        d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width), u > 0 && (c += i[u - 1]), h = c + d
                    } else for(var u = 0; u < l.length; u++) {
                        h += this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width);
                        var p = this.game.math.snapToCeil(h, i) - h;
                        h += p
                    }
                }
                n[a] = Math.ceil(h), s = Math.max(s, n[a])
            }
            this.canvas.width = s * this._res;
            var f = r.fontSize + this.style.strokeThickness + this.padding.y, g = f * o, m = this._lineSpacing;
            m < 0 && Math.abs(m) > f && (m = -f), 0 !== m && (g += m > 0 ? m * e.length : m * (e.length - 1)), this.canvas.height = g * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
            var y, v;
            for(this._charCount = 0, a = 0; a < o; a++)y = this.style.strokeThickness / 2, v = this.style.strokeThickness / 2 + a * f + r.ascent, a > 0 && (v += m * a), "right" === this.style.align ? y += s - n[a] : "center" === this.style.align && (y += (s - n[a]) / 2), this.autoRound && (y = Math.round(y), v = Math.round(v)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], y, v) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], y, v) : this.renderTabLine(e[a], y, v, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], y, v) : this.renderTabLine(e[a], y, v, !0)));
            this.updateTexture(), this.dirty = !1
        },i.Text.prototype.renderTabLine = function(t, e, i, n) {
            var s = t.split(/(?:\t)/), r = this.style.tabs, o = 0;
            if(Array.isArray(r))for(var a = 0,
                                        h = 0; h < s.length; h++)h > 0 && (a += r[h - 1]), o = e + a, n ? this.context.fillText(s[h], o, i) : this.context.strokeText(s[h], o, i); else for(var h = 0; h < s.length; h++) {
                var l = Math.ceil(this.context.measureText(s[h]).width);
                o = this.game.math.snapToCeil(e, r), n ? this.context.fillText(s[h], o, i) : this.context.strokeText(s[h], o, i), e = o + l
            }
        },i.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        },i.Text.prototype.measureLine = function(t) {
            for(var e = 0, i = 0; i < t.length; i++) {
                var n = t[i];
                if(this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var s = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(n).width, this._charCount++
            }
            return Math.ceil(e)
        },i.Text.prototype.updateLine = function(t, e, i) {
            for(var n = 0; n < t.length; n++) {
                var s = t[n];
                if(this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var r = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(s, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(s, e, i)), e += this.context.measureText(s).width, this._charCount++
            }
        },i.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        },i.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        },i.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        },i.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        },i.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        },i.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        },i.Text.prototype.precalculateWordWrap = function(t) {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var e = this.runWordWrap(t);
            return e.split(/(?:\r\n|\r|\n)/)
        },i.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        },i.Text.prototype.advancedWordWrap = function(t) {
            for(var e = this.context, i = this.style.wordWrapWidth, n = "", s = t.replace(/ +/gi, " ").split(/\r?\n/gi),
                    r = s.length, o = 0; o < r; o++) {
                var a = s[o], h = "";
                a = a.replace(/^ *|\s*$/gi, "");
                var l = e.measureText(a).width;
                if(l < i) n += a + "\n"; else {
                    for(var c = i, u = a.split(" "), d = 0; d < u.length; d++) {
                        var p = u[d], f = p + " ", g = e.measureText(f).width;
                        if(g > c) {
                            if(0 === d) {
                                for(var m = f; m.length && (m = m.slice(0, -1), g = e.measureText(m).width, !(g <= c)););
                                if(!m.length)throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var y = p.substr(m.length);
                                u[d] = y, h += m
                            }
                            var v = u[d].length ? d : d + 1, x = u.slice(v).join(" ").replace(/[ \n]*$/gi, "");
                            s[o + 1] = x + " " + (s[o + 1] || ""), r = s.length;
                            break
                        }
                        h += f, c -= g
                    }
                    n += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return n = n.replace(/[\s|\n]*$/gi, "")
        },i.Text.prototype.basicWordWrap = function(t) {
            for(var e = "", i = t.split("\n"), n = 0; n < i.length; n++) {
                for(var s = this.style.wordWrapWidth, r = i[n].split(" "), o = 0; o < r.length; o++) {
                    var a = this.context.measureText(r[o]).width, h = a + this.context.measureText(" ").width;
                    h > s ? (o > 0 && (e += "\n"), e += r[o] + " ", s = this.style.wordWrapWidth - a) : (s -= h, e += r[o] + " ")
                }
                n < i.length - 1 && (e += "\n")
            }
            return e
        },i.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        },i.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if(e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t), {font: t}
        },i.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return e = t.fontStyle, e && "normal" !== e && i.push(e), e = t.fontVariant, e && "normal" !== e && i.push(e), e = t.fontWeight, e && "normal" !== e && i.push(e), e = t.fontSize, e && "medium" !== e && i.push(e), e = t.fontFamily, e && i.push(e), i.length || i.push(t.font), i.join(" ")
        },i.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
        },i.Text.prototype.parseList = function(t) {
            if(!Array.isArray(t))return this;
            for(var e = "",
                    i = 0; i < t.length; i++)Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        },i.Text.prototype.setTextBounds = function(t, e, n, s) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, n, s) : this.textBounds = new i.Rectangle(t, e, n, s), this.style.wordWrapWidth > n && (this.style.wordWrapWidth = n)), this.updateTexture(), this
        },i.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture, e = this.texture.crop, i = this.texture.frame, n = this.canvas.width,
                s = this.canvas.height;
            if(t.width = n, t.height = s, e.width = n, e.height = s, i.width = n, i.height = s, this.texture.width = n, this.texture.height = s, this._width = n, this._height = s, this.textBounds) {
                var r = this.textBounds.x, o = this.textBounds.y;
                "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
            }
            this.renderable = 0 !== n && 0 !== s, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        },i.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        },i.Text.prototype.determineFontProperties = function(t) {
            var e = i.Text.fontPropertiesCache[t];
            if(!e) {
                e = {};
                var n = i.Text.fontPropertiesCanvas, s = i.Text.fontPropertiesContext;
                s.font = t;
                var r = Math.ceil(s.measureText("|Mq").width), o = Math.ceil(s.measureText("|Mq").width), a = 2 * o;
                if(o = 1.4 * o | 0, n.width = r, n.height = a, s.fillStyle = "#f00", s.fillRect(0, 0, r, a), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|Mq", 0, o), !s.getImageData(0, 0, r, a))return e.ascent = o, e.descent = o + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e;
                var h, l, c = s.getImageData(0, 0, r, a).data, u = c.length, d = 4 * r, p = 0, f = !1;
                for(h = 0; h < o; h++) {
                    for(l = 0; l < d; l += 4)if(255 !== c[p + l]) {
                        f = !0;
                        break
                    }
                    if(f)break;
                    p += d
                }
                for(e.ascent = o - h, p = u - d, f = !1, h = a; h > o; h--) {
                    for(l = 0; l < d; l += 4)if(255 !== c[p + l]) {
                        f = !0;
                        break
                    }
                    if(f)break;
                    p -= d
                }
                e.descent = h - o, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e
            }
            return e
        },i.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        },Object.defineProperty(i.Text.prototype, "text", {
            get: function() {
                return this._text
            }, set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }),Object.defineProperty(i.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            }, set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            }, set: function(t) {
                t = t || "Arial", t = t.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            }, set: function(t) {
                t = t || "0", "number" == typeof t && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            }, set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            }, set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            }, set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }),Object.defineProperty(i.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            }, set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "align", {
            get: function() {
                return this.style.align
            }, set: function(t) {
                t !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "resolution", {
            get: function() {
                return this._res
            }, set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            }, set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            }, set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            }, set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            }, set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            }, set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            }, set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            }, set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            }, set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }),Object.defineProperty(i.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            }, set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            }, set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            }, set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            }, set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            }, set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            }, set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }),Object.defineProperty(i.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            }, set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }),Object.defineProperty(i.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            }, set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }),i.Text.fontPropertiesCache = {},i.Text.fontPropertiesCanvas = document.createElement("canvas"),i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"),i.TileSprite = function(t, e, n, s, r, o, a) {
            e = e || 0, n = n || 0, s = s || 256, r = r || 256, o = o || null, a = a || null, this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point;
            var h = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), s, r), i.Component.Core.init.call(this, t, e, n, o, a)
        },i.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype),i.TileSprite.prototype.constructor = i.TileSprite,i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]),i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate,i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate,i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate,i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate,i.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        },i.TileSprite.prototype.autoScroll = function(t, e) {
            this._scroll.set(t, e)
        },i.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        },i.TileSprite.prototype.destroy = function(t) {
            i.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
        },i.TileSprite.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        },i.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = ""
        },i.Device = new i.Device,i.Device.onInitialized = new i.Signal,i.Device.whenReady = function(t, e, i) {
            var n = this._readyCheck;
            if(this.deviceReadyAt || !n) t.call(e, this); else if(n._monitor || i) n._queue = n._queue || [], n._queue.push([t, e]); else {
                n._monitor = n.bind(this), n._queue = n._queue || [], n._queue.push([t, e]);
                var s = "undefined" != typeof window.cordova, r = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(n._monitor, 0) : s && !r ? document.addEventListener("deviceready", n._monitor, !1) : (document.addEventListener("DOMContentLoaded", n._monitor, !1), window.addEventListener("load", n._monitor, !1))
            }
        },i.Device._readyCheck = function() {
            var t = this._readyCheck;
            if(document.body) {
                if(!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for(var e; e = t._queue.shift();) {
                        var i = e[0], n = e[1];
                        i.call(n, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        },i.Device._initialize = function() {
            function t() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? l.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? l.kindle = !0 : /Android/.test(t) ? l.android = !0 : /CrOS/.test(t) ? l.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (l.iOS = !0, navigator.appVersion.match(/OS (\d+)/), l.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? l.linux = !0 : /Mac OS/.test(t) ? l.macOS = !0 : /Windows/.test(t) && (l.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (l.android = !1, l.iOS = !1, l.macOS = !1, l.windows = !0, l.windowsPhone = !0);
                var e = /Silk/.test(t);
                (l.windows || l.macOS || l.linux && !e || l.chromeOS) && (l.desktop = !0), (l.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (l.desktop = !1)
            }

            function e() {
                l.canvas = !!window.CanvasRenderingContext2D || l.cocoonJS;
                try {
                    l.localStorage = !!localStorage.getItem
                } catch(t) {
                    l.localStorage = !1
                }
                l.file = !!(window.File && window.FileReader && window.FileList && window.Blob), l.fileSystem = !!window.requestFileSystem, l.worker = !!window.Worker, l.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, l.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, l.getUserMedia = l.getUserMedia && !!navigator.getUserMedia && !!window.URL, l.firefox && l.firefoxVersion < 21 && (l.getUserMedia = !1), !l.iOS && (l.ie || l.firefox || l.chrome) && (l.canvasBitBltShift = !0), (l.safari || l.mobileSafari) && (l.canvasBitBltShift = !1)
            }

            function i() {
                ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (l.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (l.mspointer = !0), l.cocoonJS || ("onwheel" in window || l.ie && "WheelEvent" in window ? l.wheelEvent = "wheel" : "onmousewheel" in window ? l.wheelEvent = "mousewheel" : l.firefox && "MouseScrollEvent" in window && (l.wheelEvent = "DOMMouseScroll"))
            }

            function n() {
                for(var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"],
                        e = document.createElement("div"), i = 0; i < t.length; i++)if(e[t[i]]) {
                    l.fullscreen = !0, l.requestFullscreen = t[i];
                    break
                }
                var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                if(l.fullscreen)for(var i = 0; i < n.length; i++)if(document[n[i]]) {
                    l.cancelFullscreen = n[i];
                    break
                }
            }

            function s() {
                var t = navigator.userAgent;
                if(/Arora/.test(t) ? l.arora = !0 : /Edge\/\d+/.test(t) ? l.edge = !0 : /Chrome\/(\d+)/.test(t) && !l.windowsPhone ? (l.chrome = !0, l.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? l.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (l.firefox = !0, l.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && l.iOS ? l.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (l.ie = !0, l.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? l.midori = !0 : /Opera/.test(t) ? l.opera = !0 : /Safari\/(\d+)/.test(t) && !l.windowsPhone ? (l.safari = !0, /Version\/(\d+)\./.test(t) && (l.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (l.ie = !0, l.trident = !0, l.tridentVersion = parseInt(RegExp.$1, 10), l.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (l.silk = !0), navigator.standalone && (l.webApp = !0), "undefined" != typeof window.cordova && (l.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (l.node = !0), l.node && "object" == typeof process.versions && (l.nodeWebkit = !!process.versions["node-webkit"], l.electron = !!process.versions.electron), navigator.isCocoonJS && (l.cocoonJS = !0), l.cocoonJS)try {
                    l.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch(e) {
                    l.cocoonJSApp = !1
                }
                "undefined" != typeof window.ejecta && (l.ejecta = !0), /Crosswalk/.test(t) && (l.crosswalk = !0)
            }

            function r() {
                var t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t);
                return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
            }

            function o() {
                if(void 0 === Uint8ClampedArray)return !1;
                var t = PIXI.CanvasPool.create(this, 1, 1), e = t.getContext("2d");
                if(!e)return !1;
                var i = e.createImageData(1, 1);
                return PIXI.CanvasPool.remove(this), i.data instanceof Uint8ClampedArray
            }

            function a() {
                l.pixelRatio = window.devicePixelRatio || 1, l.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") !== -1, l.iPhone4 = 2 === l.pixelRatio && l.iPhone, l.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") !== -1, "undefined" != typeof Int8Array ? l.typedArray = !0 : l.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (l.littleEndian = r(), l.LITTLE_ENDIAN = l.littleEndian), l.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== l.littleEndian && o(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (l.vibration = !0)
            }

            function h() {
                var t, e = document.createElement("p"), i = {
                    webkitTransform: "-webkit-transform",
                    OTransform: "-o-transform",
                    msTransform: "-ms-transform",
                    MozTransform: "-moz-transform",
                    transform: "transform"
                };
                document.body.insertBefore(e, null);
                for(var n in i)void 0 !== e.style[n] && (e.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[n]));
                document.body.removeChild(e), l.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }

            var l = this;
            t(), s(), h(), a(), e(), n(), i()
        },i.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.profile(), console.profileEnd(), console.clear && console.clear(), !console.profiles)) && console.profiles.length > 0
        },i.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        },i.Canvas = {
            create: function(t, e, i, n, s) {
                e = e || 256, i = i || 256;
                var r = s ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                return "string" == typeof n && "" !== n && (r.id = n), r.width = e, r.height = i, r.style.display = "block", r
            }, setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            }, setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            }, setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            }, addToDOM: function(t, e, i) {
                var n;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? n = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (n = e)), n || (n = document.body), i && n.style && (n.style.overflow = "hidden"), n.appendChild(t), t
            }, removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            }, setTransform: function(t, e, i, n, s, r, o) {
                return t.setTransform(n, r, o, s, e, i), t
            }, setSmoothingEnabled: function(t, e) {
                var n = i.Canvas.getSmoothingPrefix(t);
                return n && (t[n] = e), t
            }, getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for(var i in e) {
                    var n = e[i] + "mageSmoothingEnabled";
                    if(n in t)return n
                }
                return null
            }, getSmoothingEnabled: function(t) {
                var e = i.Canvas.getSmoothingPrefix(t);
                if(e)return t[e]
            }, setImageRenderingCrisp: function(t) {
                for(var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"],
                        i = 0; i < e.length; i++)t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            }, setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        },i.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for(var i = ["ms", "moz", "webkit", "o"],
                    n = 0; n < i.length && !window.requestAnimationFrame; n++)window.requestAnimationFrame = window[i[n] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[n] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        },i.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            }, updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            }, updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            }, stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            }, isSetTimeOut: function() {
                return this._isSetTimeOut
            }, isRAF: function() {
                return this._isSetTimeOut === !1
            }
        },i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame,i.Math = {
            PI2: 2 * Math.PI,
            between: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for(var t = 0, e = arguments.length, i = 0; i < e; i++)t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.round(t * n) / n
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.floor(t * n) / n
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.ceil(t * n) / n
            },
            rotateToAngle: function(t, e, n) {
                return void 0 === n && (n = .05), t === e ? t : (Math.abs(e - t) <= n || Math.abs(e - t) >= i.Math.PI2 - n ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += n : e < t && (t -= n)), t)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                if(0 === i)return 0;
                var n = Math.floor((i - -180) / 360);
                return i - 360 * n
            },
            angleBetween: function(t, e, i, n) {
                return Math.atan2(n - e, i - t)
            },
            angleBetweenY: function(t, e, i, n) {
                return Math.atan2(i - t, n - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return t %= 2 * Math.PI, t >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var n = i - e;
                if(n <= 0)return 0;
                var s = (t - e) % n;
                return s < 0 && (s += n), s + e
            },
            wrapValue: function(t, e, i) {
                var n;
                return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), n = (t + e) % i
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if(1 === arguments.length && "object" == typeof arguments[0])var t = arguments[0]; else var t = arguments;
                for(var e = 1, i = 0, n = t.length; e < n; e++)t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if(1 === arguments.length && "object" == typeof arguments[0])var t = arguments[0]; else var t = arguments;
                for(var e = 1, i = 0, n = t.length; e < n; e++)t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if(2 === arguments.length && "object" == typeof arguments[1])var e = arguments[1]; else var e = arguments.slice(1);
                for(var i = 1, n = 0, s = e.length; i < s; i++)e[i][t] < e[n][t] && (n = i);
                return e[n][t]
            },
            maxProperty: function(t) {
                if(2 === arguments.length && "object" == typeof arguments[1])var e = arguments[1]; else var e = arguments.slice(1);
                for(var i = 1, n = 0, s = e.length; i < s; i++)e[i][t] > e[n][t] && (n = i);
                return e[n][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1, n = i * e, s = Math.floor(n);
                return e < 0 ? this.linear(t[0], t[1], n) : e > 1 ? this.linear(t[i], t[i - 1], i - n) : this.linear(t[s], t[s + 1 > i ? i : s + 1], n - s)
            },
            bezierInterpolation: function(t, e) {
                for(var i = 0, n = t.length - 1,
                        s = 0; s <= n; s++)i += Math.pow(1 - e, n - s) * Math.pow(e, s) * t[s] * this.bernstein(n, s);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1, n = i * e, s = Math.floor(n);
                return t[0] === t[i] ? (e < 0 && (s = Math.floor(n = i * (1 + e))), this.catmullRom(t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i], n - s)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -n) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], n - i) - t[i]) : this.catmullRom(t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2], n - s)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if(0 === t)return 1;
                for(var e = t; --t;)e *= t;
                return e
            },
            catmullRom: function(t, e, i, n, s) {
                var r = .5 * (i - t), o = .5 * (n - e), a = s * s, h = s * a;
                return (2 * e - 2 * i + r + o) * h + (-3 * e + 3 * i - 2 * r - o) * a + r * s + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, n) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1);
                for(var s = e, r = i, o = n * Math.PI / t, a = [], h = [],
                        l = 0; l < t; l++)r -= s * o, s += r * o, a[l] = r, h[l] = s;
                return {sin: h, cos: a, length: t}
            },
            distance: function(t, e, i, n) {
                var s = t - i, r = e - n;
                return Math.sqrt(s * s + r * r)
            },
            distanceSq: function(t, e, i, n) {
                var s = t - i, r = e - n;
                return s * s + r * r
            },
            distancePow: function(t, e, i, n, s) {
                return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, n, s) {
                return n + (t - e) * (s - n) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return t = Math.max(0, Math.min(1, (t - e) / (i - e))), t * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t = Math.max(0, Math.min(1, (t - e) / (i - e))), t * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        };
        var l = Math.PI / 180, c = 180 / Math.PI;
        i.Math.degToRad = function(t) {
            return t * l
        }, i.Math.radToDeg = function(t) {
            return t * c
        }, i.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, i.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            }, sow: function(t) {
                if(this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)for(var e = 0; e < t.length && null != t[e]; e++) {
                    var i = t[e];
                    this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                }
            }, hash: function(t) {
                var e, i, n;
                for(n = 4022871197, t = t.toString(), i = 0; i < t.length; i++)n += t.charCodeAt(i), e = .02519603282416938 * n, n = e >>> 0, e -= n, e *= n, n = e >>> 0, e -= n, n += 4294967296 * e;
                return 2.3283064365386963e-10 * (n >>> 0)
            }, integer: function() {
                return 4294967296 * this.rnd.apply(this)
            }, frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            }, real: function() {
                return this.integer() + this.frac()
            }, integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t);
            }, between: function(t, e) {
                return this.integerInRange(t, e)
            }, realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            }, normal: function() {
                return 1 - 2 * this.frac()
            }, uuid: function() {
                var t = "", e = "";
                for(e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            }, pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            }, sign: function() {
                return this.pick([-1, 1])
            }, weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            }, timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            }, angle: function() {
                return this.integerInRange(-180, 180)
            }, state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, n, s, r, o) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, n, s, r, o)
        }, i.QuadTree.prototype = {
            reset: function(t, e, i, n, s, r, o) {
                this.maxObjects = s || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: n,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(n / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(n / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            }, populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            }, populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            }, split: function() {
                this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            }, insert: function(t) {
                var e, i = 0;
                if(null != this.nodes[0] && (e = this.getIndex(t), e !== -1))return void this.nodes[e].insert(t);
                if(this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)for(null == this.nodes[0] && this.split(); i < this.objects.length;)e = this.getIndex(this.objects[i]), e !== -1 ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
            }, getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            }, retrieve: function(t) {
                if(t instanceof i.Rectangle)var e = this.objects, n = this.getIndex(t); else {
                    if(!t.body)return this._empty;
                    var e = this.objects, n = this.getIndex(t.body)
                }
                return this.nodes[0] && (n !== -1 ? e = e.concat(this.nodes[n].retrieve(t)) : (e = e.concat(this.nodes[0].retrieve(t)), e = e.concat(this.nodes[1].retrieve(t)), e = e.concat(this.nodes[2].retrieve(t)), e = e.concat(this.nodes[3].retrieve(t)))), e
            }, clear: function() {
                this.objects.length = 0;
                for(var t = this.nodes.length; t--;)this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) {
            this.game = t
        }, i.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            }, checkDomainName: function(t) {
                return window.location.hostname.indexOf(t) !== -1
            }, updateQueryString: function(t, e, i, n) {
                void 0 === i && (i = !1), void 0 !== n && "" !== n || (n = window.location.href);
                var s = "", r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                if(r.test(n)) s = "undefined" != typeof e && null !== e ? n.replace(r, "$1" + t + "=" + e + "$2$3") : n.replace(r, "$1$3").replace(/(&|\?)$/, ""); else if("undefined" != typeof e && null !== e) {
                    var o = n.indexOf("?") !== -1 ? "&" : "?", a = n.split("#");
                    n = a[0] + o + t + "=" + e, a[1] && (n += "#" + a[1]), s = n
                } else s = n;
                return i ? void(window.location.href = s) : s
            }, getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {}, i = location.search.substring(1).split("&");
                for(var n in i) {
                    var s = i[n].split("=");
                    if(s.length > 1) {
                        if(t && t === this.decodeURI(s[0]))return this.decodeURI(s[1]);
                        e[this.decodeURI(s[0])] = this.decodeURI(s[1])
                    }
                }
                return e
            }, decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) {
            this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: i.Easing.Power0,
                Power1: i.Easing.Power1,
                Power2: i.Easing.Power2,
                Power3: i.Easing.Power3,
                Power4: i.Easing.Power4,
                Linear: i.Easing.Linear.None,
                Quad: i.Easing.Quadratic.Out,
                Cubic: i.Easing.Cubic.Out,
                Quart: i.Easing.Quartic.Out,
                Quint: i.Easing.Quintic.Out,
                Sine: i.Easing.Sinusoidal.Out,
                Expo: i.Easing.Exponential.Out,
                Circ: i.Easing.Circular.Out,
                Elastic: i.Easing.Elastic.Out,
                Back: i.Easing.Back.Out,
                Bounce: i.Easing.Bounce.Out,
                "Quad.easeIn": i.Easing.Quadratic.In,
                "Cubic.easeIn": i.Easing.Cubic.In,
                "Quart.easeIn": i.Easing.Quartic.In,
                "Quint.easeIn": i.Easing.Quintic.In,
                "Sine.easeIn": i.Easing.Sinusoidal.In,
                "Expo.easeIn": i.Easing.Exponential.In,
                "Circ.easeIn": i.Easing.Circular.In,
                "Elastic.easeIn": i.Easing.Elastic.In,
                "Back.easeIn": i.Easing.Back.In,
                "Bounce.easeIn": i.Easing.Bounce.In,
                "Quad.easeOut": i.Easing.Quadratic.Out,
                "Cubic.easeOut": i.Easing.Cubic.Out,
                "Quart.easeOut": i.Easing.Quartic.Out,
                "Quint.easeOut": i.Easing.Quintic.Out,
                "Sine.easeOut": i.Easing.Sinusoidal.Out,
                "Expo.easeOut": i.Easing.Exponential.Out,
                "Circ.easeOut": i.Easing.Circular.Out,
                "Elastic.easeOut": i.Easing.Elastic.Out,
                "Back.easeOut": i.Easing.Back.Out,
                "Bounce.easeOut": i.Easing.Bounce.Out,
                "Quad.easeInOut": i.Easing.Quadratic.InOut,
                "Cubic.easeInOut": i.Easing.Cubic.InOut,
                "Quart.easeInOut": i.Easing.Quartic.InOut,
                "Quint.easeInOut": i.Easing.Quintic.InOut,
                "Sine.easeInOut": i.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": i.Easing.Exponential.InOut,
                "Circ.easeInOut": i.Easing.Circular.InOut,
                "Elastic.easeInOut": i.Easing.Elastic.InOut,
                "Back.easeInOut": i.Easing.Back.InOut,
                "Bounce.easeInOut": i.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, i.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            }, removeAll: function() {
                for(var t = 0; t < this._tweens.length; t++)this._tweens[t].pendingDelete = !0;
                this._add = []
            }, removeFrom: function(t, e) {
                void 0 === e && (e = !0);
                var n, s;
                if(Array.isArray(t))for(n = 0, s = t.length; n < s; n++)this.removeFrom(t[n]); else if(t.type === i.GROUP && e)for(var n = 0,
                                                                                                                                       s = t.children.length; n < s; n++)this.removeFrom(t.children[n]); else {
                    for(n = 0, s = this._tweens.length; n < s; n++)t === this._tweens[n].target && this.remove(this._tweens[n]);
                    for(n = 0, s = this._add.length; n < s; n++)t === this._add[n].target && this.remove(this._add[n])
                }
            }, add: function(t) {
                t._manager = this, this._add.push(t)
            }, create: function(t) {
                return new i.Tween(t, this.game, this)
            }, remove: function(t) {
                var e = this._tweens.indexOf(t);
                e !== -1 ? this._tweens[e].pendingDelete = !0 : (e = this._add.indexOf(t), e !== -1 && (this._add[e].pendingDelete = !0))
            }, update: function() {
                var t = this._add.length, e = this._tweens.length;
                if(0 === e && 0 === t)return !1;
                for(var i = 0; i < e;)this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            }, isTweening: function(t) {
                return this._tweens.some(function(e) {
                    return e.target === t
                })
            }, _pauseAll: function() {
                for(var t = this._tweens.length - 1; t >= 0; t--)this._tweens[t]._pause()
            }, _resumeAll: function() {
                for(var t = this._tweens.length - 1; t >= 0; t--)this._tweens[t]._resume()
            }, pauseAll: function() {
                for(var t = this._tweens.length - 1; t >= 0; t--)this._tweens[t].pause()
            }, resumeAll: function() {
                for(var t = this._tweens.length - 1; t >= 0; t--)this._tweens[t].resume(!0)
            }
        }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, n) {
            this.game = e, this.target = t, this.manager = n, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = n.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, i.Tween.prototype = {
            to: function(t, e, n, s, r, o, a) {
                return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== n && null !== n || (n = i.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof n && this.manager.easeMap[n] && (n = this.manager.easeMap[n]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).to(t, e, n, r, o, a)), s && this.start(), this)
            }, from: function(t, e, n, s, r, o, a) {
                return void 0 === e && (e = 1e3), void 0 !== n && null !== n || (n = i.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof n && this.manager.easeMap[n] && (n = this.manager.easeMap[n]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).from(t, e, n, r, o, a)), s && this.start(), this)
            }, start: function(t) {
                if(void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning)return this;
                for(var e = 0; e < this.timeline.length; e++)for(var i in this.timeline[e].vEnd)this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for(var e = 0; e < this.timeline.length; e++)this.timeline[e].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            }, stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            }, updateTweenData: function(t, e, i) {
                if(0 === this.timeline.length)return this;
                if(void 0 === i && (i = 0), i === -1)for(var n = 0; n < this.timeline.length; n++)this.timeline[n][t] = e; else this.timeline[i][t] = e;
                return this
            }, delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            }, repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
            }, repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            }, yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            }, yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            }, easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            }, interpolation: function(t, e, n) {
                return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, n), this.updateTweenData("interpolationContext", e, n)
            }, repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            }, chain: function() {
                for(var t = arguments.length; t--;)t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            }, loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            }, onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            }, pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            }, _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            }, resume: function() {
                if(this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for(var t = 0; t < this.timeline.length; t++)this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            }, _resume: function() {
                this._codePaused || this.resume()
            }, update: function(t) {
                if(this.pendingDelete || !this.target)return !1;
                if(this.isPaused)return !0;
                var e = this.timeline[this.current].update(t);
                if(e === i.TweenData.PENDING)return !0;
                if(e === i.TweenData.RUNNING)return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if(e === i.TweenData.LOOPED)return this.timeline[this.current].repeatCounter === -1 ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if(e === i.TweenData.COMPLETE) {
                    var n = !1;
                    return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, n = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, n = !0)), n ? this.repeatCounter === -1 ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            }, generateData: function(t, e) {
                if(null === this.game || null === this.target)return null;
                void 0 === t && (t = 60), void 0 === e && (e = []);
                for(var i = 0; i < this.timeline.length; i++)for(var n in this.timeline[i].vEnd)this.properties[n] = this.target[n] || 0, Array.isArray(this.properties[n]) || (this.properties[n] *= 1);
                for(var i = 0; i < this.timeline.length; i++)this.timeline[i].loadValues();
                for(var i = 0; i < this.timeline.length; i++)e = e.concat(this.timeline[i].generateData(t));
                return e
            }
        }, Object.defineProperty(i.Tween.prototype, "totalDuration", {
            get: function() {
                for(var t = 0, e = 0; e < this.timeline.length; e++)t += this.timeline[e].duration;
                return t
            }
        }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) {
            this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1
        }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = {
            to: function(t, e, i, n, s, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = n, this.repeatTotal = s, this.yoyo = r, this.isFrom = !1, this
            }, from: function(t, e, i, n, s, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = n, this.repeatTotal = s, this.yoyo = r, this.isFrom = !0, this
            }, start: function() {
                if(this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)for(var t in this.vStartCache)this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            }, loadValues: function() {
                for(var t in this.parent.properties) {
                    if(this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if(0 === this.vEnd[t].length)continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    "undefined" != typeof this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            }, update: function(t) {
                if(this.isRunning) {
                    if(t < this.startTime)return i.TweenData.RUNNING
                } else {
                    if(!(t >= this.startTime))return i.TweenData.PENDING;
                    this.isRunning = !0
                }
                var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                for(var n in this.vEnd) {
                    var s = this.vStart[n], r = this.vEnd[n];
                    Array.isArray(r) ? this.parent.target[n] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[n] = s + (r - s) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING
            }, generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [], i = !1, n = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= n, this.dt = Math.max(this.dt, 0)) : (this.dt += n, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var s = {};
                    for(var r in this.vEnd) {
                        var o = this.vStart[r], a = this.vEnd[r];
                        Array.isArray(a) ? s[r] = this.interpolationFunction(a, this.value) : s[r] = o + (a - o) * this.value
                    }
                    e.push(s), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while(!i);
                if(this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            }, repeat: function() {
                if(this.yoyo) {
                    if(this.inReverse && 0 === this.repeatCounter) {
                        for(var t in this.vStartCache)this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1, i.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if(0 === this.repeatCounter)return i.TweenData.COMPLETE;
                if(this.inReverse)for(var t in this.vStartCache)this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t]; else {
                    for(var t in this.vStartCache)this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED
            }
        }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            }, Quadratic: {
                In: function(t) {
                    return t * t
                }, Out: function(t) {
                    return t * (2 - t)
                }, InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            }, Cubic: {
                In: function(t) {
                    return t * t * t
                }, Out: function(t) {
                    return --t * t * t + 1
                }, InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            }, Quartic: {
                In: function(t) {
                    return t * t * t * t
                }, Out: function(t) {
                    return 1 - --t * t * t * t
                }, InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            }, Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                }, Out: function(t) {
                    return --t * t * t * t * t + 1
                }, InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            }, Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                }, Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                }, InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            }, Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                }, Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                }, InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
                }
            }, Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                }, Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                }, InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            }, Elastic: {
                In: function(t) {
                    var e, i = .1, n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)))
                }, Out: function(t) {
                    var e, i = .1, n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1)
                }, InOut: function(t) {
                    var e, i = .1, n = .4;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * .5 + 1)
                }
            }, Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                }, Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                }, InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? .5 * (t * t * ((e + 1) * t - e)) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            }, Bounce: {
                In: function(t) {
                    return 1 - i.Easing.Bounce.Out(1 - t)
                }, Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                }, InOut: function(t) {
                    return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) {
            this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, (!1)), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, i.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            }, add: function(t) {
                return this._timers.push(t), t
            }, create: function(t) {
                void 0 === t && (t = !0);
                var e = new i.Timer(this.game, t);
                return this._timers.push(e), e
            }, removeAll: function() {
                for(var t = 0; t < this._timers.length; t++)this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            }, refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            }, update: function(t) {
                var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            }, updateTimers: function() {
                for(var t = 0,
                        e = this._timers.length; t < e;)this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
            }, updateAdvancedTiming: function() {
                this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
            }, gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for(var t = this._timers.length; t--;)this._timers[t]._pause()
            }, gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for(var t = this._timers.length; t--;)this._timers[t]._resume()
            }, totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            }, elapsedSince: function(t) {
                return this.time - t
            }, elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            }, reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(i.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            }, set: function(t) {
                this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
            }
        }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) {
            void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = {
            create: function(t, e, n, s, r, o) {
                t = Math.round(t);
                var a = t;
                a += 0 === this._now ? this.game.time.time : this._now;
                var h = new i.TimerEvent(this, t, a, n, e, s, r, o);
                return this.events.push(h), this.order(), this.expired = !1, h
            }, add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            }, repeat: function(t, e, i, n) {
                return this.create(t, !1, e, i, n, Array.prototype.slice.call(arguments, 4))
            }, loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            }, start: function(t) {
                if(!this.running) {
                    this._started = this.game.time.time + (t || 0), this.running = !0;
                    for(var e = 0; e < this.events.length; e++)this.events[e].tick = this.events[e].delay + this._started
                }
            }, stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            }, remove: function(t) {
                for(var e = 0; e < this.events.length; e++)if(this.events[e] === t)return this.events[e].pendingDelete = !0, !0;
                return !1
            }, order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            }, sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            }, clearPendingEvents: function() {
                for(this._i = this.events.length; this._i--;)this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            }, update: function(t) {
                if(this.paused)return !0;
                if(this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for(; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;)this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), this.events[this._i].loop === !0 ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            }, pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            }, _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            }, adjustEvents: function(t) {
                for(var e = 0; e < this.events.length; e++)if(!this.events[e].pendingDelete) {
                    var i = this.events[e].tick - t;
                    i < 0 && (i = 0), this.events[e].tick = this._now + i
                }
                var n = this.nextTick - t;
                n < 0 ? this.nextTick = this._now : this.nextTick = this._now + n
            }, resume: function() {
                if(this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            }, _resume: function() {
                this._codePaused || this.resume()
            }, removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            }, destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(i.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(i.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(i.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, n, s, r, o, a) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = n - 1, this.loop = s, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
        }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, i.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if(void 0 === t)return !1;
                if(this.isLoaded)for(var i in this._anims)this._anims[i].updateFrameData(t);
                return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            }, copyFrameData: function(t, e) {
                if(this._frameData = t.clone(), this.isLoaded)for(var i in this._anims)this._anims[i].updateFrameData(this._frameData);
                return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            }, add: function(t, e, n, s, r) {
                return e = e || [], n = n || 60, void 0 === s && (s = !1), void 0 === r && (r = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, r, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, n, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
            }, validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for(var i = 0; i < t.length; i++)if(e === !0) {
                    if(t[i] > this._frameData.total)return !1
                } else if(this._frameData.checkFrameName(t[i]) === !1)return !1;
                return !0
            }, play: function(t, e, i, n) {
                if(this._anims[t])return this.currentAnim === this._anims[t] ? this.currentAnim.isPlaying === !1 ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, n)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, n))
            }, stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            }, update: function() {
                return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
            }, next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            }, previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            }, getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            }, refreshFrame: function() {
            }, destroy: function() {
                var t = null;
                for(var t in this._anims)this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            }, set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "name", {
            get: function() {
                if(this.currentAnim)return this.currentAnim.name
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frame", {
            get: function() {
                if(this.currentFrame)return this.currentFrame.index
            }, set: function(t) {
                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameName", {
            get: function() {
                if(this.currentFrame)return this.currentFrame.name
            }, set: function(t) {
                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) ? (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) : console.warn("Cannot set frameName: " + t)
            }
        }), i.Animation = function(t, e, n, s, r, o, a) {
            void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = s, this.name = n, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, i.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), "undefined" != typeof i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            }, restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            }, reverse: function() {
                return this.reversed = !this.reversed, this
            }, reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            }, setFrame: function(t, e) {
                var i;
                if(void 0 === e && (e = !1), "string" == typeof t)for(var n = 0; n < this._frames.length; n++)this._frameData.getFrame(this._frames[n]).name === t && (i = n); else if("number" == typeof t)if(e) i = t; else for(var n = 0; n < this._frames.length; n++)this._frames[n] === t && (i = n);
                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
            }, stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            }, onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            }, onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            }, update: function() {
                return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
            }, updateCurrentFrame: function(t, e) {
                if(void 0 === e && (e = !1), !this._frameData)return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            }, next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            }, previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            }, updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            }, destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            }, complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            }, set: function(t) {
                this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(i.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            }, set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(i.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(i.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            }, set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(i.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            }, set: function(t) {
                t > 0 && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(i.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            }, set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), i.Animation.generateFrameNames = function(t, e, n, s, r) {
            void 0 === s && (s = "");
            var o = [], a = "";
            if(e < n)for(var h = e; h <= n; h++)a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString(), a = t + a + s, o.push(a); else for(var h = e; h >= n; h--)a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString(), a = t + a + s, o.push(a);
            return o
        }, i.Frame = function(t, e, n, s, r, o) {
            this.index = t, this.x = e, this.y = n, this.width = s, this.height = r, this.name = o, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.distance = i.Math.distance(0, 0, s, r), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, i.Frame.prototype = {
            resize: function(t, e) {
                this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
            }, setTrim: function(t, e, i, n, s, r, o) {
                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = n, this.spriteSourceSizeY = s, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
            }, clone: function() {
                var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for(var e in this)this.hasOwnProperty(e) && (t[e] = this[e]);
                return t
            }, getRect: function(t) {
                return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }
        }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, i.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            }, getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            }, getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            }, checkFrameName: function(t) {
                return null != this._frameNames[t]
            }, clone: function() {
                for(var t = new i.FrameData,
                        e = 0; e < this._frames.length; e++)t._frames.push(this._frames[e].clone());
                for(var n in this._frameNames)this._frameNames.hasOwnProperty(n) && t._frameNames.push(this._frameNames[n]);
                return t
            }, getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for(var n = t; n <= e; n++)i.push(this._frames[n]);
                return i
            }, getFrames: function(t, e, i) {
                if(void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)for(var n = 0; n < this._frames.length; n++)i.push(this._frames[n]); else for(var n = 0; n < t.length; n++)e ? i.push(this.getFrame(t[n])) : i.push(this.getFrameByName(t[n]));
                return i
            }, getFrameIndexes: function(t, e, i) {
                if(void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)for(var n = 0; n < this._frames.length; n++)i.push(this._frames[n].index); else for(var n = 0; n < t.length; n++)e && this._frames[t[n]] ? i.push(this._frames[t[n]].index) : this.getFrameByName(t[n]) && i.push(this.getFrameByName(t[n]).index);
                return i
            }, destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), i.AnimationParser = {
            spriteSheet: function(t, e, n, s, r, o, a) {
                var h = e;
                if("string" == typeof e && (h = t.cache.getImage(e)), null === h)return null;
                var l = h.width, c = h.height;
                n <= 0 && (n = Math.floor(-l / Math.min(-1, n))), s <= 0 && (s = Math.floor(-c / Math.min(-1, s)));
                var u = Math.floor((l - o) / (n + a)), d = Math.floor((c - o) / (s + a)), p = u * d;
                if(r !== -1 && (p = r), 0 === l || 0 === c || l < n || c < s || 0 === p)return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                for(var f = new i.FrameData, g = o, m = o,
                        y = 0; y < p; y++)f.addFrame(new i.Frame(y, g, m, n, s, "")), g += n + a, g + n > l && (g = o, m += s + a);
                return f
            }, JSONData: function(t, e) {
                if(!e.frames)return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                var n, s, r = new i.FrameData, o = e.frames, a = 0;
                for(var h in o)s = o[h], n = r.addFrame(new i.Frame(a, s[0], s[1], s[2], s[3], h)), s[2] === s[4] && s[3] === s[5] || n.setTrim(s[2], s[4], s[5], s[6], s[7], s[2], s[3]), a += 1;
                return r
            }, JSONDataPyxel: function(t, e) {
                var n = ["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"];
                if(n.forEach(function(t) {
                        if(!e[t])return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
                    }), 1 !== e.layers.length)return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
                for(var s, r = new i.FrameData, o = e.tileheight, a = e.tilewidth, h = e.layers[0].tiles,
                        l = 0; l < h.length; l++)s = r.addFrame(new i.Frame(l, h[l].x, h[l].y, a, o, "frame_" + l)), s.setTrim(!1);
                return r
            }, JSONDataHash: function(t, e) {
                if(!e.frames)return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                var n, s = new i.FrameData, r = e.frames, o = 0;
                for(var a in r)n = s.addFrame(new i.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)), r[a].trimmed && n.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), o++;
                return s
            }, XMLData: function(t, e) {
                if(!e.getElementsByTagName("TextureAtlas"))return void console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                for(var n, s, r, o, a, h, l, c, u, d, p, f = new i.FrameData, g = e.getElementsByTagName("SubTexture"),
                        m = 0; m < g.length; m++)r = g[m].attributes, s = r.name.value, o = parseInt(r.x.value, 10), a = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), l = parseInt(r.height.value, 10), c = null, u = null, r.frameX && (c = Math.abs(parseInt(r.frameX.value, 10)), u = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), n = f.addFrame(new i.Frame(m, o, a, h, l, s)), null === c && null === u || n.setTrim(!0, h, l, c, u, d, p);
                return f
            }
        }, i.Cache = function(t) {
            this.game = t, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                renderTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
        }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.MISSING = null, i.Cache.prototype = {
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {canvas: e, context: i}
            }, addImage: function(t, e, n) {
                this.checkImageKey(t) && this.removeImage(t);
                var s = {
                    key: t,
                    url: e,
                    data: n,
                    base: new PIXI.BaseTexture(n),
                    frame: new i.Frame(0, 0, 0, n.width, n.height, t),
                    frameData: new i.FrameData
                };
                return s.frameData.addFrame(new i.Frame(0, 0, 0, n.width, n.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(s.base)), s
            }, addDefaultImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var e = this.addImage("__default", null, t);
                e.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(e.base)
            }, addMissingImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var e = this.addImage("__missing", null, t);
                i.Cache.MISSING = new PIXI.Texture(e.base)
            }, addText: function(t, e, i) {
                this._cache.text[t] = {url: e, data: i}, this._resolveURL(e, this._cache.text[t])
            }, addPhysicsData: function(t, e, i, n) {
                this._cache.physics[t] = {url: e, data: i, format: n}, this._resolveURL(e, this._cache.physics[t])
            }, addTilemap: function(t, e, i, n) {
                this._cache.tilemap[t] = {url: e, data: i, format: n}, this._resolveURL(e, this._cache.tilemap[t])
            }, addBinary: function(t, e) {
                this._cache.binary[t] = e
            }, addBitmapData: function(t, e, n) {
                return e.key = t, void 0 === n && (n = new i.FrameData, n.addFrame(e.textureFrame)), this._cache.bitmapData[t] = {
                    data: e,
                    frameData: n
                }, e
            }, addJSON: function(t, e, i) {
                this._cache.json[t] = {url: e, data: i}, this._resolveURL(e, this._cache.json[t])
            }, addXML: function(t, e, i) {
                this._cache.xml[t] = {url: e, data: i}, this._resolveURL(e, this._cache.xml[t])
            }, addRenderTexture: function(t, e) {
                this._cache.renderTexture[t] = {texture: e, frame: new i.Frame(0, 0, 0, e.width, e.height, "", "")}
            }, addSpriteSheet: function(t, e, n, s, r, o, a, h) {
                void 0 === o && (o = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                var l = {
                    key: t,
                    url: e,
                    data: n,
                    frameWidth: s,
                    frameHeight: r,
                    margin: a,
                    spacing: h,
                    base: new PIXI.BaseTexture(n),
                    frameData: i.AnimationParser.spriteSheet(this.game, n, s, r, o, a, h)
                };
                this._cache.image[t] = l, this._resolveURL(e, l)
            }, addTextureAtlas: function(t, e, n, s, r) {
                var o = {key: t, url: e, data: n, base: new PIXI.BaseTexture(n)};
                o.frameData = i.AnimationParser.JSONData(this.game, s, t), this._cache.image[t] = o, this._resolveURL(e, o)
            }, checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            }, checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            }, checkCanvasKey: function(t) {
                return this.checkKey(i.Cache.CANVAS, t)
            }, checkImageKey: function(t) {
                return this.checkKey(i.Cache.IMAGE, t)
            }, checkTextureKey: function(t) {
                return this.checkKey(i.Cache.TEXTURE, t)
            }, checkTextKey: function(t) {
                return this.checkKey(i.Cache.TEXT, t)
            }, checkPhysicsKey: function(t) {
                return this.checkKey(i.Cache.PHYSICS, t)
            }, checkTilemapKey: function(t) {
                return this.checkKey(i.Cache.TILEMAP, t)
            }, checkBinaryKey: function(t) {
                return this.checkKey(i.Cache.BINARY, t)
            }, checkBitmapDataKey: function(t) {
                return this.checkKey(i.Cache.BITMAPDATA, t)
            }, checkJSONKey: function(t) {
                return this.checkKey(i.Cache.JSON, t)
            }, checkXMLKey: function(t) {
                return this.checkKey(i.Cache.XML, t)
            }, checkRenderTextureKey: function(t) {
                return this.checkKey(i.Cache.RENDER_TEXTURE, t)
            }, getItem: function(t, e, i, n) {
                return this.checkKey(e, t) ? void 0 === n ? this._cacheMap[e][t] : this._cacheMap[e][t][n] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
            }, getCanvas: function(t) {
                return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas")
            }, getImage: function(t, e) {
                void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                var n = this.getItem(t, i.Cache.IMAGE, "getImage");
                return null === n && (n = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? n : n.data
            }, getTextureFrame: function(t) {
                return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame")
            }, getText: function(t) {
                return this.getItem(t, i.Cache.TEXT, "getText", "data")
            }, getPhysicsData: function(t, e, n) {
                var s = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data");
                if(null === s || void 0 === e || null === e)return s;
                if(s[e]) {
                    var r = s[e];
                    if(!r || !n)return r;
                    for(var o in r)if(o = r[o], o.fixtureKey === n)return o;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + n + " in " + t + '"')
                } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                return null
            }, getTilemapData: function(t) {
                return this.getItem(t, i.Cache.TILEMAP, "getTilemapData")
            }, getBinary: function(t) {
                return this.getItem(t, i.Cache.BINARY, "getBinary")
            }, getBitmapData: function(t) {
                return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data")
            }, getJSON: function(t, e) {
                var n = this.getItem(t, i.Cache.JSON, "getJSON", "data");
                return n ? e ? i.Utils.extend(!0, Array.isArray(n) ? [] : {}, n) : n : null
            }, getXML: function(t) {
                return this.getItem(t, i.Cache.XML, "getXML", "data")
            }, getRenderTexture: function(t) {
                return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture")
            }, getBaseTexture: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
            }, getFrame: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
            }, getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            }, getFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
            }, hasFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
            }, updateFrameData: function(t, e, n) {
                void 0 === n && (n = i.Cache.IMAGE), this._cacheMap[n][t] && (this._cacheMap[n][t].frameData = e)
            }, getFrameByIndex: function(t, e, i) {
                var n = this.getFrameData(t, i);
                return n ? n.getFrame(e) : null
            }, getFrameByName: function(t, e, i) {
                var n = this.getFrameData(t, i);
                return n ? n.getFrameByName(e) : null
            }, getURL: function(t) {
                var t = this._resolveURL(t);
                return t ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
            }, getKeys: function(t) {
                void 0 === t && (t = i.Cache.IMAGE);
                var e = [];
                if(this._cacheMap[t])for(var n in this._cacheMap[t])"__default" !== n && "__missing" !== n && e.push(n);
                return e
            }, removeCanvas: function(t) {
                delete this._cache.canvas[t]
            }, removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            }, removeText: function(t) {
                delete this._cache.text[t]
            }, removePhysics: function(t) {
                delete this._cache.physics[t]
            }, removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            }, removeBinary: function(t) {
                delete this._cache.binary[t]
            }, removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            }, removeJSON: function(t) {
                delete this._cache.json[t]
            }, removeXML: function(t) {
                delete this._cache.xml[t]
            }, removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            }, removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            }, removeTextureAtlas: function(t) {
                delete this._cache.atlas[t]
            }, clearGLTextures: function() {
                for(var t in this._cache.image)this._cache.image[t].base._glTextures = []
            }, _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            }, destroy: function() {
                for(var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for(var i in e)"__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            }
        }, i.Cache.prototype.constructor = i.Cache, i.Loader = function(t) {
            this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = {
            setPreloadSprite: function(t, e) {
                e = e || 0, this.preloadSprite = {
                    sprite: t,
                    direction: e,
                    width: t.width,
                    height: t.height,
                    rect: null
                }, 0 === e ? this.preloadSprite.rect = new i.Rectangle(0, 0, 1, t.height) : this.preloadSprite.rect = new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
            }, resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            }, checkKeyExists: function(t, e) {
                return this.getAssetIndex(t, e) > -1
            }, getAssetIndex: function(t, e) {
                for(var i = -1, n = 0; n < this._fileList.length; n++) {
                    var s = this._fileList[n];
                    if(s.type === t && s.key === e && (i = n, !s.loaded && !s.loading))break
                }
                return i
            }, getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return i > -1 && {index: i, file: this._fileList[i]}
            }, reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            }, addToFileList: function(t, e, i, n, s, r) {
                if(void 0 === s && (s = !1), void 0 === e || "" === e)return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                if(void 0 === i || null === i) {
                    if(!r)return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                    i = e + r
                }
                var o = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if(n)for(var a in n)o[a] = n[a];
                var h = this.getAssetIndex(t, e);
                if(s && h > -1) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                } else h === -1 && (this._fileList.push(o), this._totalFileCount++);
                return this
            }, replaceInFileList: function(t, e, i, n) {
                return this.addToFileList(t, e, i, n, !0)
            }, pack: function(t, e, i, n) {
                if(void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null), !e && !i)return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                var s = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: n
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), s.data = i || {}, s.loaded = !0);
                for(var r = 0; r < this._fileList.length + 1; r++) {
                    var o = this._fileList[r];
                    if(!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                        this._fileList.splice(r, 0, s), this._totalPackCount++;
                        break
                    }
                }
                return this
            }, image: function(t, e, i) {
                return this.addToFileList("image", t, e, void 0, i, ".png")
            }, images: function(t, e) {
                if(Array.isArray(e))for(var i = 0; i < t.length; i++)this.image(t[i], e[i]); else for(var i = 0; i < t.length; i++)this.image(t[i]);
                return this
            }, text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            }, json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            }, xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            }, script: function(t, e, i, n) {
                return void 0 === i && (i = !1), i !== !1 && void 0 === n && (n = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: n
                }, !1, ".js")
            }, binary: function(t, e, i, n) {
                return void 0 === i && (i = !1), i !== !1 && void 0 === n && (n = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: n
                }, !1, ".bin")
            }, spritesheet: function(t, e, i, n, s, r, o) {
                return void 0 === s && (s = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: n,
                    frameMax: s,
                    margin: r,
                    spacing: o
                }, !1, ".png")
            }, tilemap: function(t, e, n, s) {
                if(void 0 === e && (e = null), void 0 === n && (n = null), void 0 === s && (s = i.Tilemap.CSV), e || n || (e = s === i.Tilemap.CSV ? t + ".csv" : t + ".json"), n) {
                    switch(s) {
                        case i.Tilemap.CSV:
                            break;
                        case i.Tilemap.TILED_JSON:
                            "string" == typeof n && (n = JSON.parse(n))
                    }
                    this.cache.addTilemap(t, null, n, s)
                } else this.addToFileList("tilemap", t, e, {format: s});
                return this
            }, physics: function(t, e, n, s) {
                return void 0 === e && (e = null), void 0 === n && (n = null), void 0 === s && (s = i.Physics.LIME_CORONA_JSON), e || n || (e = t + ".json"), n ? ("string" == typeof n && (n = JSON.parse(n)), this.cache.addPhysicsData(t, null, n, s)) : this.addToFileList("physics", t, e, {format: s}), this
            }, bitmapFont: function(t, e, i, n, s, r) {
                if(void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === n && (n = null), null === i && null === n && (i = t + ".xml"), void 0 === s && (s = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: s,
                    ySpacing: r
                }); else if("string" == typeof n) {
                    var o, a;
                    try {
                        o = JSON.parse(n)
                    } catch(h) {
                        a = this.parseXml(n)
                    }
                    if(!a && !o)throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: o || a,
                        atlasType: o ? "json" : "xml",
                        xSpacing: s,
                        ySpacing: r
                    })
                }
                return this
            }, atlasJSONArray: function(t, e, n, s) {
                return this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            }, atlasJSONHash: function(t, e, n, s) {
                return this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_JSON_HASH)
            }, atlasXML: function(t, e, n, s) {
                return void 0 === n && (n = null), void 0 === s && (s = null), n || s || (n = t + ".xml"), this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_XML_STARLING)
            }, atlas: function(t, e, n, s, r) {
                if(void 0 !== e && null !== e || (e = t + ".png"), void 0 === n && (n = null), void 0 === s && (s = null), void 0 === r && (r = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), n || s || (n = r === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), n) this.addToFileList("textureatlas", t, e, {
                    atlasURL: n,
                    format: r
                }); else {
                    switch(r) {
                        case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof s && (s = JSON.parse(s));
                            break;
                        case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if("string" == typeof s) {
                                var o = this.parseXml(s);
                                if(!o)throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                s = o
                            }
                    }
                    this.addToFileList("textureatlas", t, e, {atlasURL: null, atlasData: s, format: r})
                }
                return this
            }, withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            }, addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            }, removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            }, removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            }, start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            }, processLoadQueue: function() {
                if(!this.isLoading)return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                for(var t = 0; t < this._flightQueue.length; t++) {
                    var e = this._flightQueue[t];
                    (e.loaded || e.error) && (this._flightQueue.splice(t, 1), t--, e.loading = !1, e.requestUrl = null, e.requestObject = null, e.error && this.onFileError.dispatch(e.key, e), "packfile" !== e.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, e.key, !e.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === e.type && e.error && (this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)))
                }
                for(var n = !1, s = this.enableParallel ? i.Math.clamp(this.maxParallelDownloads, 1, 12) : 1,
                        t = this._processingHead; t < this._fileList.length; t++) {
                    var e = this._fileList[t];
                    if("packfile" === e.type && !e.error && e.loaded && t === this._processingHead && (this.processPack(e), this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)), e.loaded || e.error ? t === this._processingHead && (this._processingHead = t + 1) : !e.loading && this._flightQueue.length < s && ("packfile" !== e.type || e.data ? n || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(e), e.loading = !0, this.onFileStart.dispatch(this.progress, e.key, e.url), this.loadFile(e)) : (this._flightQueue.push(e), e.loading = !0, this.loadFile(e))), !e.loaded && e.syncPoint && (n = !0), this._flightQueue.length >= s || n && this._loadedPackCount === this._totalPackCount)break
                }
                if(this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading(); else if(!this._flightQueue.length) {
                    console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                    var r = this;
                    setTimeout(function() {
                        r.finishedLoading(!0)
                    }, 2e3)
                }
            }, finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
            }, asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
            }, processPack: function(t) {
                var e = t.data[t.key];
                if(!e)return void console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key");
                for(var n = 0; n < e.length; n++) {
                    var s = e[n];
                    switch(s.type) {
                        case"image":
                            this.image(s.key, s.url, s.overwrite);
                            break;
                        case"text":
                            this.text(s.key, s.url, s.overwrite);
                            break;
                        case"json":
                            this.json(s.key, s.url, s.overwrite);
                            break;
                        case"xml":
                            this.xml(s.key, s.url, s.overwrite);
                            break;
                        case"script":
                            this.script(s.key, s.url, s.callback, t.callbackContext || this);
                            break;
                        case"binary":
                            this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                            break;
                        case"spritesheet":
                            this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                            break;
                        case"tilemap":
                            this.tilemap(s.key, s.url, s.data, i.Tilemap[s.format]);
                            break;
                        case"physics":
                            this.physics(s.key, s.url, s.data, i.Loader[s.format]);
                            break;
                        case"atlasJSONArray":
                            this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case"atlasJSONHash":
                            this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case"atlasXML":
                            this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                            break;
                        case"atlas":
                            this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, i.Loader[s.format])
                    }
                }
            }, transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            }, loadFile: function(t) {
                switch(t.type) {
                    case"packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case"image":
                    case"spritesheet":
                    case"textureatlas":
                        this.loadImageTag(t);
                        break;
                    case"json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                        break;
                    case"xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                        break;
                    case"tilemap":
                        t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                        break;
                    case"text":
                    case"script":
                    case"physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case"binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            }, loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            }, xhrLoad: function(t, e, i, n, s) {
                if(this.useXDomainRequest && window.XDomainRequest)return void this.xhrLoadWithXDR(t, e, i, n, s);
                var r = new XMLHttpRequest;
                r.open("GET", e, !0), r.responseType = i, this.headers.requestedWith !== !1 && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), s = s || this.fileError;
                var o = this;
                r.onload = function() {
                    try {
                        return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? s.call(o, t, r) : n.call(o, t, r)
                    } catch(e) {
                        o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.onerror = function() {
                    try {
                        return s.call(o, t, r)
                    } catch(e) {
                        o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = r, t.requestUrl = e, r.send()
            }, xhrLoadWithXDR: function(t, e, i, n, s) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0, console.warn("Phaser.Loader - using XDomainRequest outside of IE 9"));
                var r = new window.XDomainRequest;
                r.open("GET", e, !0), r.responseType = i, r.timeout = 3e3, s = s || this.fileError;
                var o = this;
                r.onerror = function() {
                    try {
                        return s.call(o, t, r)
                    } catch(e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.ontimeout = function() {
                    try {
                        return s.call(o, t, r)
                    } catch(e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.onprogress = function() {
                }, r.onload = function() {
                    try {
                        return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? s.call(o, t, r) : n.call(o, t, r)
                    } catch(e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = r, t.requestUrl = e, setTimeout(function() {
                    r.send()
                }, 0)
            }, fileError: function(t, e, i) {
                var n = t.requestUrl || this.transformUrl(t.url, t), s = "error loading asset from URL " + n;
                !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
            }, fileComplete: function(t, e) {
                var n = !0;
                switch(t.type) {
                    case"packfile":
                        var s = JSON.parse(e.responseText);
                        t.data = s || {};
                        break;
                    case"image":
                        this.cache.addImage(t.key, t.url, t.data);
                        break;
                    case"spritesheet":
                        this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                        break;
                    case"textureatlas":
                        if(null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format); else if(n = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete); else {
                            if(t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING)throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                            this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                        }
                        break;
                    case"text":
                        t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                        break;
                    case"physics":
                        var s = JSON.parse(e.responseText);
                        this.cache.addPhysicsData(t.key, t.url, s, t.format);
                        break;
                    case"script":
                        t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                        break;
                    case"binary":
                        t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                }
                n && this.asyncComplete(t)
            }, jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            }, csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            }, xmlLoadComplete: function(t, e) {
                var i = e.responseText, n = this.parseXml(i);
                if(!n) {
                    var s = e.responseType || e.contentType;
                    return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + s + ")"), void this.asyncComplete(t, "invalid XML")
                }
                "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, n, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, n), this.asyncComplete(t)
            }, parseXml: function(t) {
                var e;
                try {
                    if(window.DOMParser) {
                        var i = new DOMParser;
                        e = i.parseFromString(t, "text/xml")
                    } else e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t)
                } catch(n) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            }, updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            }, totalLoadedFiles: function() {
                return this._loadedFileCount
            }, totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            }, totalLoadedPacks: function() {
                return this._totalPackCount
            }, totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        },Object.defineProperty(i.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return i.Math.clamp(t || 0, 0, 100)
            }
        }),Object.defineProperty(i.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }),i.Loader.prototype.constructor = i.Loader,i.LoaderParser = {
            bitmapFont: function(t, e, i, n) {
                return this.xmlBitmapFont(t, e, i, n)
            }, xmlBitmapFont: function(t, e, i, n) {
                var s = {}, r = t.getElementsByTagName("info")[0], o = t.getElementsByTagName("common")[0];
                s.font = r.getAttribute("face"), s.size = parseInt(r.getAttribute("size"), 10), s.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) + n, s.chars = {};
                for(var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                    var l = parseInt(a[h].getAttribute("id"), 10);
                    s.chars[l] = {
                        x: parseInt(a[h].getAttribute("x"), 10),
                        y: parseInt(a[h].getAttribute("y"), 10),
                        width: parseInt(a[h].getAttribute("width"), 10),
                        height: parseInt(a[h].getAttribute("height"), 10),
                        xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i,
                        kerning: {}
                    }
                }
                var c = t.getElementsByTagName("kerning");
                for(h = 0; h < c.length; h++) {
                    var u = parseInt(c[h].getAttribute("first"), 10), d = parseInt(c[h].getAttribute("second"), 10),
                        p = parseInt(c[h].getAttribute("amount"), 10);
                    s.chars[d].kerning[u] = p
                }
                return this.finalizeBitmapFont(e, s)
            }, jsonBitmapFont: function(t, e, i, n) {
                var s = {
                    font: t.font.info._face,
                    size: parseInt(t.font.info._size, 10),
                    lineHeight: parseInt(t.font.common._lineHeight, 10) + n,
                    chars: {}
                };
                return t.font.chars["char"].forEach(function(t) {
                    var e = parseInt(t._id, 10);
                    s.chars[e] = {
                        x: parseInt(t._x, 10),
                        y: parseInt(t._y, 10),
                        width: parseInt(t._width, 10),
                        height: parseInt(t._height, 10),
                        xOffset: parseInt(t._xoffset, 10),
                        yOffset: parseInt(t._yoffset, 10),
                        xAdvance: parseInt(t._xadvance, 10) + i,
                        kerning: {}
                    }
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    s.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                }), this.finalizeBitmapFont(e, s)
            }, finalizeBitmapFont: function(t, e) {
                return Object.keys(e.chars).forEach(function(n) {
                    var s = e.chars[n];
                    s.texture = new PIXI.Texture(t, new i.Rectangle(s.x, s.y, s.width, s.height))
                }), e
            }
        },i.ScaleManager = function(t, e, n) {
            this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, n)
        },i.ScaleManager.EXACT_FIT = 0,i.ScaleManager.NO_SCALE = 1,i.ScaleManager.SHOW_ALL = 2,i.ScaleManager.RESIZE = 3,i.ScaleManager.USER_SCALE = 4,i.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                var e = this;
                this._orientationChange = function(t) {
                    return e.orientationChange(t)
                }, this._windowResize = function(t) {
                    return e.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return e.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return e.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            }, parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
            }, setupScale: function(t, e) {
                var n, s = new i.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? n = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (n = this.game.parent)), n ? (this.parentNode = n, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var r = 0, o = 0;
                "number" == typeof t ? r = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, r = s.width * this.parentScaleFactor.x), "number" == typeof e ? o = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o = s.height * this.parentScaleFactor.y), r = Math.floor(r), o = Math.floor(o), this._gameSize.setTo(0, 0, r, o), this.updateDimensions(r, o, !1)
            }, _gameResumed: function() {
                this.queueUpdate(!0)
            }, setGameSize: function(t, e) {
                this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
            }, setUserScale: function(t, e, i, n) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | n), this.queueUpdate(!0)
            }, setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            }, signalSizeChange: function() {
                if(!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width, e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                }
            }, setMinMax: function(t, e, i, n) {
                this.minWidth = t, this.minHeight = e, "undefined" != typeof i && (this.maxWidth = i), "undefined" != typeof n && (this.maxHeight = n)
            }, preUpdate: function() {
                if(!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var e = this._parentBounds.width, n = this._parentBounds.height,
                        s = this.getParentBounds(this._parentBounds), r = s.width !== e || s.height !== n,
                        o = this.updateOrientationState();
                    (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                    var a = 2 * this._updateThrottle;
                    this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            }, pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            }, updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            }, updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            }, forceOrientation: function(t, e) {
                void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
            }, classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            }, updateOrientationState: function() {
                var t = this.screenOrientation, e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation, n = e !== this.incorrectOrientation;
                return n && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || n) && this.onOrientationChange.dispatch(this, t, e), i || n
            }, orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            }, windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            }, scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            }, refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            }, updateLayout: function() {
                var t = this.currentScaleMode;
                if(t === i.ScaleManager.RESIZE)return void this.reflowGame();
                if(this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) {
                    var e = this.getParentBounds(this._tempBounds);
                    this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                }
                this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
            }, getParentBounds: function(t) {
                var e = t || new i.Rectangle, n = this.boundingParent, s = this.dom.visualBounds,
                    r = this.dom.layoutBounds;
                if(n) {
                    var o = n.getBoundingClientRect(),
                        a = n.offsetParent ? n.offsetParent.getBoundingClientRect() : n.getBoundingClientRect();
                    e.setTo(o.left - a.left, o.top - a.top, o.width, o.height);
                    var h = this.windowConstraints;
                    if(h.right) {
                        var l = "layout" === h.right ? r : s;
                        e.right = Math.min(e.right, l.width)
                    }
                    if(h.bottom) {
                        var l = "layout" === h.bottom ? r : s;
                        e.bottom = Math.min(e.bottom, l.height)
                    }
                } else e.setTo(0, 0, s.width, s.height);
                return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
            }, alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds), n = this.game.canvas, s = this.margin;
                if(t) {
                    s.left = s.right = 0;
                    var r = n.getBoundingClientRect();
                    if(this.width < i.width && !this.incorrectOrientation) {
                        var o = r.left - i.x, a = i.width / 2 - this.width / 2;
                        a = Math.max(a, 0);
                        var h = a - o;
                        s.left = Math.round(h)
                    }
                    n.style.marginLeft = s.left + "px", 0 !== s.left && (s.right = -(i.width - r.width - s.left), n.style.marginRight = s.right + "px")
                }
                if(e) {
                    s.top = s.bottom = 0;
                    var r = n.getBoundingClientRect();
                    if(this.height < i.height && !this.incorrectOrientation) {
                        var o = r.top - i.y, a = i.height / 2 - this.height / 2;
                        a = Math.max(a, 0);
                        var h = a - o;
                        s.top = Math.round(h)
                    }
                    n.style.marginTop = s.top + "px", 0 !== s.top && (s.bottom = -(i.height - r.height - s.top), n.style.marginBottom = s.bottom + "px")
                }
                s.x = s.left, s.y = s.top
            }, reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            }, reflowCanvas: function() {
                this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            }, resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            }, queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            }, reset: function(t) {
                t && this.grid && this.grid.reset()
            }, setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            }, setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds), n = i.width, s = i.height;
                e = t ? Math.max(s / this.game.height, n / this.game.width) : Math.min(s / this.game.height, n / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            }, setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            }, createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            }, startFullScreen: function(t, e) {
                if(this.isFullScreen)return !1;
                if(!this.compatibility.supportsFullScreen) {
                    var n = this;
                    return void setTimeout(function() {
                        n.fullScreenError()
                    }, 10)
                }
                if("when-not-mouse" === this.compatibility.clickTrampoline) {
                    var s = this.game.input;
                    if(s.activePointer && s.activePointer !== s.mousePointer && (e || e !== !1))return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                }
                void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t);
                var r = this.fullScreenTarget;
                r || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), r = this._createdFullScreenTarget);
                var o = {targetElement: r};
                if(this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, o), this._createdFullScreenTarget) {
                    var a = this.game.canvas, h = a.parentNode;
                    h.insertBefore(r, a), r.appendChild(a)
                }
                return r[this.game.device.requestFullscreen](), !0
            }, stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
            }, cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if(t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            }, prepScreenMode: function(t) {
                var e = !!this._createdFullScreenTarget, n = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && n !== this.game.canvas && (this._fullScreenRestore = {
                        targetWidth: n.style.width,
                        targetHeight: n.style.height
                    }, n.style.width = "100%", n.style.height = "100%") : (this._fullScreenRestore && (n.style.width = this._fullScreenRestore.targetWidth, n.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            }, fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            }, fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
            }, scaleSprite: function(t, e, i, n) {
                if(void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === n && (n = !1), !t || !t.scale)return t;
                if(t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0)return t;
                var s = e, r = t.height * e / t.width, o = t.width * i / t.height, a = i, h = o > e;
                return h = h ? n : !n, h ? (t.width = Math.floor(s), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)), t
            }, destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        },i.ScaleManager.prototype.constructor = i.ScaleManager,Object.defineProperty(i.ScaleManager.prototype, "boundingParent", {
            get: function() {
                if(this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget)return null;
                var t = this.game.canvas && this.game.canvas.parentNode;
                return t || null
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            }, set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            }, set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            }, set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            }, set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }),Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        });
        var u = function() {
        };
        return i.Utils.Debug = u, i.Utils.Debug.prototype = {
            isDisabled: !0,
            boot: u,
            preUpdate: u,
            reset: u,
            start: u,
            stop: u,
            line: u,
            cameraInfo: u,
            timer: u,
            pointer: u,
            spriteInputInfo: u,
            key: u,
            inputInfo: u,
            spriteBounds: u,
            ropeSegments: u,
            spriteInfo: u,
            spriteCoords: u,
            lineInfo: u,
            pixel: u,
            geom: u,
            rectangle: u,
            text: u,
            quadTree: u,
            body: u,
            bodyInfo: u,
            box2dWorld: u,
            box2dBody: u
        }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = {
            getOffset: function(t, e) {
                e = e || new i.Point;
                var n = t.getBoundingClientRect(), s = i.DOM.scrollY, r = i.DOM.scrollX,
                    o = document.documentElement.clientTop, a = document.documentElement.clientLeft;
                return e.x = n.left + r - a, e.y = n.top + s - o, e
            }, getBounds: function(t, e) {
                return void 0 === e && (e = 0), t = t && !t.nodeType ? t[0] : t, !(!t || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            }, calibrate: function(t, e) {
                e = +e || 0;
                var i = {width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0};
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            }, getAspectRatio: function(t) {
                t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t;
                var e = t.width, i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            }, inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            }, getScreenOrientation: function(t) {
                var e = window.screen, i = e.orientation || e.mozOrientation || e.msOrientation;
                if(i && "string" == typeof i.type)return i.type;
                if("string" == typeof i)return i;
                var n = "portrait-primary", s = "landscape-primary";
                if("screen" === t)return e.height > e.width ? n : s;
                if("viewport" === t)return this.visualBounds.height > this.visualBounds.width ? n : s;
                if("window.orientation" === t && "number" == typeof window.orientation)return 0 === window.orientation || 180 === window.orientation ? n : s;
                if(window.matchMedia) {
                    if(window.matchMedia("(orientation: portrait)").matches)return n;
                    if(window.matchMedia("(orientation: landscape)").matches)return s
                }
                return this.visualBounds.height > this.visualBounds.width ? n : s
            }, visualBounds: new i.Rectangle, layoutBounds: new i.Rectangle, documentBounds: new i.Rectangle
        }, i.Device.whenReady(function(t) {
            var e = window && "pageXOffset" in window ? function() {
                return window.pageXOffset
            } : function() {
                return document.documentElement.scrollLeft
            }, n = window && "pageYOffset" in window ? function() {
                return window.pageYOffset
            } : function() {
                return document.documentElement.scrollTop
            };
            Object.defineProperty(i.DOM, "scrollX", {get: e}), Object.defineProperty(i.DOM, "scrollY", {get: n}), Object.defineProperty(i.DOM.visualBounds, "x", {get: e}), Object.defineProperty(i.DOM.visualBounds, "y", {get: n}), Object.defineProperty(i.DOM.layoutBounds, "x", {value: 0}), Object.defineProperty(i.DOM.layoutBounds, "y", {value: 0});
            var s = t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight;
            if(s) {
                var r = function() {
                    return Math.max(window.innerWidth, document.documentElement.clientWidth)
                }, o = function() {
                    return Math.max(window.innerHeight, document.documentElement.clientHeight)
                };
                Object.defineProperty(i.DOM.visualBounds, "width", {get: r}), Object.defineProperty(i.DOM.visualBounds, "height", {get: o}), Object.defineProperty(i.DOM.layoutBounds, "width", {get: r}), Object.defineProperty(i.DOM.layoutBounds, "height", {get: o})
            } else Object.defineProperty(i.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(i.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth, e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight, e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(i.DOM.documentBounds, "x", {value: 0}), Object.defineProperty(i.DOM.documentBounds, "y", {value: 0}), Object.defineProperty(i.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(i.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), i.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, i.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            }, getIndex: function(t) {
                return this.list.indexOf(t)
            }, getByKey: function(t, e) {
                for(var i = this.list.length; i--;)if(this.list[i][t] === e)return this.list[i];
                return null
            }, exists: function(t) {
                return this.list.indexOf(t) > -1
            }, reset: function() {
                this.list.length = 0
            }, remove: function(t) {
                var e = this.list.indexOf(t);
                if(e > -1)return this.list.splice(e, 1), t
            }, setAll: function(t, e) {
                for(var i = this.list.length; i--;)this.list[i] && (this.list[i][t] = e)
            }, callAll: function(t) {
                for(var e = Array.prototype.slice.call(arguments, 1),
                        i = this.list.length; i--;)this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            }, removeAll: function(t) {
                void 0 === t && (t = !1);
                for(var e = this.list.length; e--;)if(this.list[e]) {
                    var i = this.remove(this.list[e]);
                    t && i.destroy()
                }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(i.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(i.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(i.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if(null === t)return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var n = e + Math.floor(Math.random() * i);
                return void 0 === t[n] ? null : t[n]
            }, removeRandomItem: function(t, e, i) {
                if(null == t)return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var n = e + Math.floor(Math.random() * i);
                if(n < t.length) {
                    var s = t.splice(n, 1);
                    return void 0 === s[0] ? null : s[0]
                }
                return null
            }, shuffle: function(t) {
                for(var e = t.length - 1; e > 0; e--) {
                    var i = Math.floor(Math.random() * (e + 1)), n = t[e];
                    t[e] = t[i], t[i] = n
                }
                return t
            }, transposeMatrix: function(t) {
                for(var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) {
                    n[s] = new Array(e);
                    for(var r = e - 1; r > -1; r--)n[s][r] = t[r][s]
                }
                return n
            }, rotateMatrix: function(t, e) {
                if("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || e === -270 || "rotateLeft" === e) t = i.ArrayUtils.transposeMatrix(t), t = t.reverse(); else if(e === -90 || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t); else if(180 === Math.abs(e) || "rotate180" === e) {
                    for(var n = 0; n < t.length; n++)t[n].reverse();
                    t = t.reverse()
                }
                return t
            }, findClosest: function(t, e) {
                if(!e.length)return NaN;
                if(1 === e.length || t < e[0])return e[0];
                for(var i = 1; e[i] < t;)i++;
                var n = e[i - 1], s = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return s - t <= t - n ? s : n
            }, rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            }, rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            }, rotate: function(t) {
                var e = t.shift();
                return t.push(e), e
            }, numberArray: function(t, e) {
                for(var i = [], n = t; n <= e; n++)i.push(n);
                return i
            }, numberArrayStep: function(t, e, n) {
                void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === n && (n = 1);
                for(var s = [], r = Math.max(i.Math.roundAwayFromZero((e - t) / (n || 1)), 0),
                        o = 0; o < r; o++)s.push(t), t += n;
                return s
            }
        }, i.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, i.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
            }, reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            }, remove: function(t) {
                return 1 === this.total ? (this.reset(), void(t.next = t.prev = null)) : (t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), void this.total--)
            }, callAll: function(t) {
                if(this.first && this.last) {
                    var e = this.first;
                    do e && e[t] && e[t].call(e), e = e.next; while(e !== this.last.next)
                }
            }
        }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = {
            texture: function(t, e, i, n, s) {
                void 0 === i && (i = 8), void 0 === n && (n = i), void 0 === s && (s = 0);
                var r = e[0].length * i, o = e.length * n;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(r, o), this.bmd.clear();
                for(var a = 0; a < e.length; a++)for(var h = e[a], l = 0; l < h.length; l++) {
                    var c = h[l];
                    "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[s][c], this.ctx.fillRect(l * i, a * n, i, n))
                }
                return this.bmd.generateTexture(t)
            }, grid: function(t, e, i, n, s, r) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                for(var o = 0; o < i; o += s)this.ctx.fillRect(0, o, e, 1);
                for(var a = 0; a < e; a += n)this.ctx.fillRect(a, 0, 1, i);
                return this.bmd.generateTexture(t)
            }
        }, i.Create.prototype.constructor = i.Create, i.Color = {
            packPixel: function(t, e, n, s) {
                return i.Device.LITTLE_ENDIAN ? (s << 24 | n << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | n << 8 | s) >>> 0
            }, unpackPixel: function(t, e, n, s) {
                return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== n && null !== n || (n = !1), void 0 !== s && null !== s || (s = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", n && i.Color.RGBtoHSL(e.r, e.g, e.b, e), s && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e
            }, fromRGBA: function(t, e) {
                return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
            }, toRGBA: function(t, e, i, n) {
                return t << 24 | e << 16 | i << 8 | n
            }, toABGR: function(t, e, i, n) {
                return (n << 24 | i << 16 | e << 8 | t) >>> 0
            }, RGBtoHSL: function(t, e, n, s) {
                s || (s = i.Color.createColor(t, e, n, 1)), t /= 255, e /= 255, n /= 255;
                var r = Math.min(t, e, n), o = Math.max(t, e, n);
                if(s.h = 0, s.s = 0, s.l = (o + r) / 2, o !== r) {
                    var a = o - r;
                    s.s = s.l > .5 ? a / (2 - o - r) : a / (o + r), o === t ? s.h = (e - n) / a + (e < n ? 6 : 0) : o === e ? s.h = (n - t) / a + 2 : o === n && (s.h = (t - e) / a + 4), s.h /= 6
                }
                return s
            }, HSLtoRGB: function(t, e, n, s) {
                if(s ? (s.r = n, s.g = n, s.b = n) : s = i.Color.createColor(n, n, n), 0 !== e) {
                    var r = n < .5 ? n * (1 + e) : n + e - n * e, o = 2 * n - r;
                    s.r = i.Color.hueToColor(o, r, t + 1 / 3), s.g = i.Color.hueToColor(o, r, t), s.b = i.Color.hueToColor(o, r, t - 1 / 3)
                }
                return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), i.Color.updateColor(s), s
            }, RGBtoHSV: function(t, e, n, s) {
                s || (s = i.Color.createColor(t, e, n, 255)), t /= 255, e /= 255, n /= 255;
                var r = Math.min(t, e, n), o = Math.max(t, e, n), a = o - r;
                return s.h = 0, s.s = 0 === o ? 0 : a / o, s.v = o, o !== r && (o === t ? s.h = (e - n) / a + (e < n ? 6 : 0) : o === e ? s.h = (n - t) / a + 2 : o === n && (s.h = (t - e) / a + 4), s.h /= 6), s
            }, HSVtoRGB: function(t, e, n, s) {
                void 0 === s && (s = i.Color.createColor(0, 0, 0, 1, t, e, 0, n));
                var r, o, a, h = Math.floor(6 * t), l = 6 * t - h, c = n * (1 - e), u = n * (1 - l * e),
                    d = n * (1 - (1 - l) * e);
                switch(h % 6) {
                    case 0:
                        r = n, o = d, a = c;
                        break;
                    case 1:
                        r = u, o = n, a = c;
                        break;
                    case 2:
                        r = c, o = n, a = d;
                        break;
                    case 3:
                        r = c, o = u, a = n;
                        break;
                    case 4:
                        r = d, o = c, a = n;
                        break;
                    case 5:
                        r = n, o = c, a = u
                }
                return s.r = Math.floor(255 * r), s.g = Math.floor(255 * o), s.b = Math.floor(255 * a), i.Color.updateColor(s), s
            }, hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            }, createColor: function(t, e, n, s, r, o, a, h) {
                var l = {
                    r: t || 0,
                    g: e || 0,
                    b: n || 0,
                    a: s || 1,
                    h: r || 0,
                    s: o || 0,
                    l: a || 0,
                    v: h || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return i.Color.updateColor(l)
            }, updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
            }, getColor32: function(t, e, i, n) {
                return t << 24 | e << 16 | i << 8 | n
            }, getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            }, RGBtoString: function(t, e, n, s, r) {
                return void 0 === s && (s = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + n).toString(16).slice(1) : "0x" + i.Color.componentToHex(s) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(n)
            }, hexToRGB: function(t) {
                var e = i.Color.hexToColor(t);
                if(e)return i.Color.getColor32(e.a, e.r, e.g, e.b)
            }, hexToColor: function(t, e) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, n) {
                    return e + e + i + i + n + n
                });
                var n = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if(n) {
                    var s = parseInt(n[1], 16), r = parseInt(n[2], 16), o = parseInt(n[3], 16);
                    e ? (e.r = s, e.g = r, e.b = o) : e = i.Color.createColor(s, r, o)
                }
                return e
            }, webToColor: function(t, e) {
                e || (e = i.Color.createColor());
                var n = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return n && (e.r = parseInt(n[1], 10), e.g = parseInt(n[2], 10), e.b = parseInt(n[3], 10), e.a = void 0 !== n[4] ? parseFloat(n[4]) : 1, i.Color.updateColor(e)), e
            }, valueToColor: function(t, e) {
                if(e || (e = i.Color.createColor()), "string" == typeof t)return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e));
                if("number" == typeof t) {
                    var n = i.Color.getRGB(t);
                    return e.r = n.r, e.g = n.g, e.b = n.b, e.a = n.a / 255, e
                }
                return e
            }, componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            }, HSVColorWheel: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 1);
                for(var n = [], s = 0; s <= 359; s++)n.push(i.Color.HSVtoRGB(s / 359, t, e));
                return n
            }, HSLColorWheel: function(t, e) {
                void 0 === t && (t = .5), void 0 === e && (e = .5);
                for(var n = [], s = 0; s <= 359; s++)n.push(i.Color.HSLtoRGB(s / 359, t, e));
                return n
            }, interpolateColor: function(t, e, n, s, r) {
                void 0 === r && (r = 255);
                var o = i.Color.getRGB(t), a = i.Color.getRGB(e), h = (a.red - o.red) * s / n + o.red,
                    l = (a.green - o.green) * s / n + o.green, c = (a.blue - o.blue) * s / n + o.blue;
                return i.Color.getColor32(r, h, l, c)
            }, interpolateColorWithRGB: function(t, e, n, s, r, o) {
                var a = i.Color.getRGB(t), h = (e - a.red) * o / r + a.red, l = (n - a.green) * o / r + a.green,
                    c = (s - a.blue) * o / r + a.blue;
                return i.Color.getColor(h, l, c)
            }, interpolateRGB: function(t, e, n, s, r, o, a, h) {
                var l = (s - t) * h / a + t, c = (r - e) * h / a + e, u = (o - n) * h / a + n;
                return i.Color.getColor(l, c, u)
            }, getRandomColor: function(t, e, n) {
                if(void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === n && (n = 255), e > 255 || t > e)return i.Color.getColor(255, 255, 255);
                var s = t + Math.round(Math.random() * (e - t)), r = t + Math.round(Math.random() * (e - t)),
                    o = t + Math.round(Math.random() * (e - t));
                return i.Color.getColor32(n, s, r, o)
            }, getRGB: function(t) {
                return t > 16777215 ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            }, getWebRGB: function(t) {
                if("object" == typeof t)return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var e = i.Color.getRGB(t);
                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
            }, getAlpha: function(t) {
                return t >>> 24
            }, getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            }, getRed: function(t) {
                return t >> 16 & 255
            }, getGreen: function(t) {
                return t >> 8 & 255
            }, getBlue: function(t) {
                return 255 & t
            }, blendNormal: function(t) {
                return t
            }, blendLighten: function(t, e) {
                return e > t ? e : t
            }, blendDarken: function(t, e) {
                return e > t ? t : e
            }, blendMultiply: function(t, e) {
                return t * e / 255
            }, blendAverage: function(t, e) {
                return (t + e) / 2
            }, blendAdd: function(t, e) {
                return Math.min(255, t + e)
            }, blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            }, blendDifference: function(t, e) {
                return Math.abs(t - e)
            }, blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            }, blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            }, blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            }, blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            }, blendSoftLight: function(t, e) {
                return e < 128 ? 2 * ((t >> 1) + 64) * (e / 255) : 255 - 2 * (255 - ((t >> 1) + 64)) * (255 - e) / 255
            }, blendHardLight: function(t, e) {
                return i.Color.blendOverlay(e, t)
            }, blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            }, blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            }, blendLinearDodge: function(t, e) {
                return i.Color.blendAdd(t, e)
            }, blendLinearBurn: function(t, e) {
                return i.Color.blendSubtract(t, e)
            }, blendLinearLight: function(t, e) {
                return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128))
            }, blendVividLight: function(t, e) {
                return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128))
            }, blendPinLight: function(t, e) {
                return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128))
            }, blendHardMix: function(t, e) {
                return i.Color.blendVividLight(t, e) < 128 ? 0 : 255
            }, blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            }, blendGlow: function(t, e) {
                return i.Color.blendReflect(e, t)
            }, blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, i.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, i.Physics.ARCADE = 0, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && this.config.arcade !== !0 || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("matter") && this.config.matter === !0 && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config))
            }, startSystem: function(t) {
                t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset())
            }, enable: function(t, e, n) {
                void 0 === e && (e = i.Physics.ARCADE), void 0 === n && (n = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
            }, preUpdate: function() {
                this.matter && this.matter.preUpdate()
            }, update: function() {
                this.matter && this.matter.update()
            }, setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            }, clear: function() {
                this.matter && this.matter.clear()
            }, reset: function() {
                this.matter && this.matter.reset()
            }, destroy: function() {
                this.matter && this.matter.destroy(), this.arcade = null, this.matter = null
            }
        }, i.Physics.prototype.constructor = i.Physics, i.Physics.Arcade = function(t) {
            this.game = t, this.gravity = new i.Point, this.bounds = new i.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = i.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new i.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, i.Physics.Arcade.prototype.constructor = i.Physics.Arcade, i.Physics.Arcade.SORT_NONE = 0, i.Physics.Arcade.LEFT_RIGHT = 1, i.Physics.Arcade.RIGHT_LEFT = 2, i.Physics.Arcade.TOP_BOTTOM = 3, i.Physics.Arcade.BOTTOM_TOP = 4, i.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, n) {
                this.bounds.setTo(t, e, i, n)
            }, setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            }, enable: function(t, e) {
                void 0 === e && (e = !0);
                var n = 1;
                if(Array.isArray(t))for(n = t.length; n--;)t[n] instanceof i.Group ? this.enable(t[n].children, e) : (this.enableBody(t[n]), e && t[n].hasOwnProperty("children") && t[n].children.length > 0 && this.enable(t[n], !0)); else t instanceof i.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
            }, enableBody: function(t) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.Arcade.Body(t), t.parent && t.parent instanceof i.Group && t.parent.addToHash(t))
            }, updateMotion: function(t) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            }, computeVelocity: function(t, e, i, n, s, r) {
                return void 0 === r && (r = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), n ? i += n * this.game.time.physicsElapsed : s && (s *= this.game.time.physicsElapsed, i - s > 0 ? i -= s : i + s < 0 ? i += s : i = 0), i > r ? i = r : i < -r && (i = -r), i
            }, overlap: function(t, e, i, n, s) {
                if(i = i || null, n = n || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))for(var r = 0; r < e.length; r++)this.collideHandler(t, e[r], i, n, s, !0); else if(Array.isArray(t) && !Array.isArray(e))for(var r = 0; r < t.length; r++)this.collideHandler(t[r], e, i, n, s, !0); else if(Array.isArray(t) && Array.isArray(e))for(var r = 0; r < t.length; r++)for(var o = 0; o < e.length; o++)this.collideHandler(t[r], e[o], i, n, s, !0); else this.collideHandler(t, e, i, n, s, !0);
                return this._total > 0
            }, collide: function(t, e, i, n, s) {
                if(i = i || null, n = n || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))for(var r = 0; r < e.length; r++)this.collideHandler(t, e[r], i, n, s, !1); else if(Array.isArray(t) && !Array.isArray(e))for(var r = 0; r < t.length; r++)this.collideHandler(t[r], e, i, n, s, !1); else if(Array.isArray(t) && Array.isArray(e))for(var r = 0; r < t.length; r++)for(var o = 0; o < e.length; o++)this.collideHandler(t[r], e[o], i, n, s, !1); else this.collideHandler(t, e, i, n, s, !1);
                return this._total > 0
            }, sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            }, sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            }, sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            }, sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            }, sort: function(t, e) {
                null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === i.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === i.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === i.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === i.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
            }, collideHandler: function(t, e, n, s, r, o) {
                return void 0 === e && t.physicsType === i.GROUP ? (this.sort(t), void this.collideGroupVsSelf(t, n, s, r, o)) : void(t && e && t.exists && e.exists && (this.sortDirection !== i.Physics.Arcade.SORT_NONE && (t.physicsType === i.GROUP && this.sort(t), e.physicsType === i.GROUP && this.sort(e)), t.physicsType === i.SPRITE ? e.physicsType === i.SPRITE ? this.collideSpriteVsSprite(t, e, n, s, r, o) : e.physicsType === i.GROUP ? this.collideSpriteVsGroup(t, e, n, s, r, o) : e.physicsType === i.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, n, s, r, o) : t.physicsType === i.GROUP ? e.physicsType === i.SPRITE ? this.collideSpriteVsGroup(e, t, n, s, r, o) : e.physicsType === i.GROUP ? this.collideGroupVsGroup(t, e, n, s, r, o) : e.physicsType === i.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, n, s, r, o) : t.physicsType === i.TILEMAPLAYER && (e.physicsType === i.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, n, s, r, o) : e.physicsType === i.GROUP && this.collideGroupVsTilemapLayer(e, t, n, s, r, o))))
            }, collideSpriteVsSprite: function(t, e, i, n, s, r) {
                return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0)
            }, collideSpriteVsGroup: function(t, e, n, s, r, o) {
                if(0 !== e.length && t.body)if(this.skipQuadTree || t.body.skipQuadTree)for(var a = {},
                                                                                                h = 0; h < e.hash.length; h++) {
                    var l = e.hash[h];
                    if(l && l.exists && l.body) {
                        if(a = l.body.getBounds(a), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                            if(t.body.right < a.x)break;
                            if(a.right < t.body.x)continue
                        } else if(this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                            if(t.body.x > a.right)break;
                            if(a.x > t.body.right)continue
                        } else if(this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                            if(t.body.bottom < a.y)break;
                            if(a.bottom < t.body.y)continue
                        } else if(this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                            if(t.body.y > a.bottom)break;
                            if(a.y > t.body.bottom)continue
                        }
                        this.collideSpriteVsSprite(t, l, n, s, r, o)
                    }
                } else {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                    for(var c = this.quadTree.retrieve(t),
                            h = 0; h < c.length; h++)this.separate(t.body, c[h], s, r, o) && (n && n.call(r, t, c[h].sprite), this._total++)
                }
            }, collideGroupVsSelf: function(t, e, n, s, r) {
                if(0 !== t.length)for(var o = 0; o < t.hash.length; o++) {
                    var a = {}, h = t.hash[o];
                    if(h && h.exists && h.body) {
                        a = h.body.getBounds(a);
                        for(var l = o + 1; l < t.hash.length; l++) {
                            var c = {}, u = t.hash[l];
                            if(u && u.exists && u.body) {
                                if(c = u.body.getBounds(c), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                    if(a.right < c.x)break;
                                    if(c.right < a.x)continue
                                } else if(this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                    if(a.x > c.right)continue;
                                    if(c.x > a.right)break
                                } else if(this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                    if(a.bottom < c.y)continue;
                                    if(c.bottom < a.y)break
                                } else if(this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                    if(a.y > c.bottom)continue;
                                    if(c.y > h.body.bottom)break
                                }
                                this.collideSpriteVsSprite(h, u, e, n, s, r)
                            }
                        }
                    }
                }
            }, collideGroupVsGroup: function(t, e, n, s, r, o) {
                if(0 !== t.length && 0 !== e.length)for(var a = 0; a < t.children.length; a++)t.children[a].exists && (t.children[a].physicsType === i.GROUP ? this.collideGroupVsGroup(t.children[a], e, n, s, r, o) : this.collideSpriteVsGroup(t.children[a], e, n, s, r, o))
            }, separate: function(t, e, i, n, s) {
                if(!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e))return !1;
                if(i && i.call(n, t.sprite, e.sprite) === !1)return !1;
                if(t.isCircle && e.isCircle)return this.separateCircle(t, e, s);
                if(t.isCircle !== e.isCircle) {
                    var r = t.isCircle ? e : t, o = t.isCircle ? t : e,
                        a = {x: r.x, y: r.y, right: r.right, bottom: r.bottom},
                        h = {x: o.x + o.radius, y: o.y + o.radius};
                    if((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right))return this.separateCircle(t, e, s)
                }
                var l = !1, c = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, s), this.intersects(t, e) && (c = this.separateY(t, e, s))) : (c = this.separateY(t, e, s), this.intersects(t, e) && (l = this.separateX(t, e, s)));
                var u = l || c;
                return u && (s ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), u
            }, intersects: function(t, e) {
                return t !== e && (t.isCircle ? e.isCircle ? i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
            }, circleBodyIntersects: function(t, e) {
                var n = i.Math.clamp(t.center.x, e.left, e.right), s = i.Math.clamp(t.center.y, e.top, e.bottom),
                    r = (t.center.x - n) * (t.center.x - n), o = (t.center.y - s) * (t.center.y - s);
                return r + o <= t.radius * t.radius
            }, separateCircle: function(t, e, n) {
                this.getOverlapX(t, e), this.getOverlapY(t, e);
                var s = e.center.x - t.center.x, r = e.center.y - t.center.y, o = Math.atan2(r, s), a = 0;
                if(t.isCircle !== e.isCircle) {
                    var h = {
                        x: e.isCircle ? t.position.x : e.position.x,
                        y: e.isCircle ? t.position.y : e.position.y,
                        right: e.isCircle ? t.right : e.right,
                        bottom: e.isCircle ? t.bottom : e.bottom
                    }, l = {
                        x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                        y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                        radius: t.isCircle ? t.radius : e.radius
                    };
                    l.y < h.y ? l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), a *= -1
                } else a = t.radius + e.radius - i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                if(n || 0 === a || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX)return 0 !== a && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== a;
                var c = {
                        x: t.velocity.x * Math.cos(o) + t.velocity.y * Math.sin(o),
                        y: t.velocity.x * Math.sin(o) - t.velocity.y * Math.cos(o)
                    }, u = {
                        x: e.velocity.x * Math.cos(o) + e.velocity.y * Math.sin(o),
                        y: e.velocity.x * Math.sin(o) - e.velocity.y * Math.cos(o)
                    }, d = ((t.mass - e.mass) * c.x + 2 * e.mass * u.x) / (t.mass + e.mass),
                    p = (2 * t.mass * c.x + (e.mass - t.mass) * u.x) / (t.mass + e.mass);
                return t.immovable || (t.velocity.x = (d * Math.cos(o) - c.y * Math.sin(o)) * t.bounce.x, t.velocity.y = (c.y * Math.cos(o) + d * Math.sin(o)) * t.bounce.y), e.immovable || (e.velocity.x = (p * Math.cos(o) - u.y * Math.sin(o)) * e.bounce.x, e.velocity.y = (u.y * Math.cos(o) + p * Math.sin(o)) * e.bounce.y), Math.abs(o) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - a * Math.cos(o), t.y += t.velocity.y * this.game.time.physicsElapsed - a * Math.sin(o)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + a * Math.cos(o), e.y += e.velocity.y * this.game.time.physicsElapsed + a * Math.sin(o)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
            }, getOverlapX: function(t, e, i) {
                var n = 0, s = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (n = t.right - e.x, n > s && !i || t.checkCollision.right === !1 || e.checkCollision.left === !1 ? n = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0)) : t.deltaX() < e.deltaX() && (n = t.x - e.width - e.x, -n > s && !i || t.checkCollision.left === !1 || e.checkCollision.right === !1 ? n = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = n, e.overlapX = n, n
            }, getOverlapY: function(t, e, i) {
                var n = 0, s = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (n = t.bottom - e.y, n > s && !i || t.checkCollision.down === !1 || e.checkCollision.up === !1 ? n = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0)) : t.deltaY() < e.deltaY() && (n = t.y - e.bottom, -n > s && !i || t.checkCollision.up === !1 || e.checkCollision.down === !1 ? n = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = n, e.overlapY = n, n
            }, separateX: function(t, e, i) {
                var n = this.getOverlapX(t, e, i);
                if(i || 0 === n || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX)return 0 !== n || t.embedded && e.embedded;
                var s = t.velocity.x, r = e.velocity.x;
                if(t.immovable || e.immovable) t.immovable ? (e.x += n, e.velocity.x = s - r * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= n, t.velocity.x = r - s * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)); else {
                    n *= .5, t.x -= n, e.x += n;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1), h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + a * e.bounce.x
                }
                return !0
            }, separateY: function(t, e, i) {
                var n = this.getOverlapY(t, e, i);
                if(i || 0 === n || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY)return 0 !== n || t.embedded && e.embedded;
                var s = t.velocity.y, r = e.velocity.y;
                if(t.immovable || e.immovable) t.immovable ? (e.y += n, e.velocity.y = s - r * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= n, t.velocity.y = r - s * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)); else {
                    n *= .5, t.y -= n, e.y += n;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1), h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + a * e.bounce.y
                }
                return !0
            }, getObjectsUnderPointer: function(t, e, i, n) {
                if(0 !== e.length && t.exists)return this.getObjectsAtLocation(t.x, t.y, e, i, n, t)
            }, getObjectsAtLocation: function(t, e, n, s, r, o) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(n);
                for(var a = new i.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(a),
                        c = 0; c < l.length; c++)l[c].hitTest(t, e) && (s && s.call(r, o, l[c].sprite), h.push(l[c].sprite));
                return h
            }, moveToObject: function(t, e, i, n) {
                void 0 === i && (i = 60), void 0 === n && (n = 0);
                var s = Math.atan2(e.y - t.y, e.x - t.x);
                return n > 0 && (i = this.distanceBetween(t, e) / (n / 1e3)), t.body.velocity.x = Math.cos(s) * i, t.body.velocity.y = Math.sin(s) * i, s
            }, moveToPointer: function(t, e, i, n) {
                void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === n && (n = 0);
                var s = this.angleToPointer(t, i);
                return n > 0 && (e = this.distanceToPointer(t, i) / (n / 1e3)), t.body.velocity.x = Math.cos(s) * e, t.body.velocity.y = Math.sin(s) * e, s
            }, moveToXY: function(t, e, i, n, s) {
                void 0 === n && (n = 60), void 0 === s && (s = 0);
                var r = Math.atan2(i - t.y, e - t.x);
                return s > 0 && (n = this.distanceToXY(t, e, i) / (s / 1e3)), t.body.velocity.x = Math.cos(r) * n, t.body.velocity.y = Math.sin(r) * n, r
            }, velocityFromAngle: function(t, e, n) {
                return void 0 === e && (e = 60), n = n || new i.Point, n.setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
            }, velocityFromRotation: function(t, e, n) {
                return void 0 === e && (e = 60), n = n || new i.Point, n.setTo(Math.cos(t) * e, Math.sin(t) * e)
            }, accelerationFromRotation: function(t, e, n) {
                return void 0 === e && (e = 60), n = n || new i.Point, n.setTo(Math.cos(t) * e, Math.sin(t) * e)
            }, accelerateToObject: function(t, e, i, n, s) {
                void 0 === i && (i = 60), void 0 === n && (n = 1e3), void 0 === s && (s = 1e3);
                var r = this.angleBetween(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(n, s), r
            }, accelerateToPointer: function(t, e, i, n, s) {
                void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === n && (n = 1e3), void 0 === s && (s = 1e3);
                var r = this.angleToPointer(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(n, s), r
            }, accelerateToXY: function(t, e, i, n, s, r) {
                void 0 === n && (n = 60), void 0 === s && (s = 1e3), void 0 === r && (r = 1e3);
                var o = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(Math.cos(o) * n, Math.sin(o) * n), t.body.maxVelocity.setTo(s, r), o
            }, distanceBetween: function(t, e, i) {
                void 0 === i && (i = !1);
                var n = i ? t.world.x - e.world.x : t.x - e.x, s = i ? t.world.y - e.world.y : t.y - e.y;
                return Math.sqrt(n * n + s * s)
            }, distanceToXY: function(t, e, i, n) {
                void 0 === n && (n = !1);
                var s = n ? t.world.x - e : t.x - e, r = n ? t.world.y - i : t.y - i;
                return Math.sqrt(s * s + r * r)
            }, distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                var n = i ? t.world.x - e.worldX : t.x - e.worldX, s = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(n * n + s * s)
            }, angleBetween: function(t, e, i) {
                return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
            }, angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX, n = e.centerY - t.centerY;
                return Math.atan2(n, i)
            }, angleToXY: function(t, e, i, n) {
                return void 0 === n && (n = !1), n ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            }, angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            }, worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        }, i.Physics.Arcade.Body = function(t) {
            this.sprite = t, this.game = t.game, this.type = i.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new i.Point, this.position = new i.Point(t.x, t.y), this.prev = new i.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new i.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new i.Point, this.newVelocity = new i.Point, this.deltaMax = new i.Point, this.acceleration = new i.Point, this.drag = new i.Point, this.allowGravity = !0, this.gravity = new i.Point, this.bounce = new i.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new i.Point(1e4, 1e4), this.friction = new i.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = i.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                any: !0,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {none: !0, up: !1, down: !1, left: !1, right: !1}, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new i.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new i.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
        }, i.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if(this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x), i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            }, preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            }, updateMovement: function() {
                var t = 0, e = 0 !== this.overlapX || 0 !== this.overlapY;
                if(this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback)var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || t >= 1 || void 0 !== i && i !== !0) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
            }, stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            }, postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = i.LEFT : this.deltaX() > 0 && (this.facing = i.RIGHT), this.deltaY() < 0 ? this.facing = i.UP : this.deltaY() > 0 && (this.facing = i.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            }, checkWorldBounds: function() {
                var t = this.position, e = this.game.physics.arcade.bounds, i = this.game.physics.arcade.checkCollision,
                    n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if(this.isCircle) {
                    var r = {
                        x: this.center.x - this.radius,
                        y: this.center.y - this.radius,
                        right: this.center.x + this.radius,
                        bottom: this.center.y + this.radius
                    };
                    r.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= n, this.blocked.left = !0) : r.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= n, this.blocked.right = !0), r.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= s, this.blocked.up = !0) : r.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= s, this.blocked.down = !0)
                } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            }, moveFrom: function(t, e, i) {
                if(void 0 === e && (e = this.speed), 0 === e)return !1;
                var n;
                return void 0 === i ? (n = this.angle, i = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(n) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(n) * e) : this.velocity.set(Math.cos(n) * e, Math.sin(n) * e), this.isMoving = !0, !0
            }, moveTo: function(t, e, n) {
                var s = e / (t / 1e3);
                if(0 === s)return !1;
                var r;
                return void 0 === n ? (r = this.angle, n = this.game.math.radToDeg(r)) : r = this.game.math.degToRad(n), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new i.Line, this.moveEnd = new i.Point), this.moveTarget.fromAngle(this.x, this.y, r, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === n || 180 === n ? this.velocity.set(Math.cos(r) * s, 0) : 90 === n || 270 === n ? this.velocity.set(0, Math.sin(r) * s) : this.velocity.set(Math.cos(r) * s, Math.sin(r) * s), this.isMoving = !0, !0
            }, setSize: function(t, e, i, n) {
                void 0 === i && (i = this.offset.x), void 0 === n && (n = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, n), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
            }, setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
            }, reset: function(t, e) {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            }, getBounds: function(t) {
                return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
            }, hitTest: function(t, e) {
                return this.isCircle ? i.Circle.contains(this, t, e) : i.Rectangle.contains(this, t, e)
            }, onFloor: function() {
                return this.blocked.down
            }, onCeiling: function() {
                return this.blocked.up
            }, onWall: function() {
                return this.blocked.left || this.blocked.right
            }, deltaAbsX: function() {
                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
            }, deltaAbsY: function() {
                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
            }, deltaX: function() {
                return this.position.x - this.prev.x
            }, deltaY: function() {
                return this.position.y - this.prev.y
            }, deltaZ: function() {
                return this.rotation - this.preRotation
            }, destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof i.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(i.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            }, set: function(t) {
                this.position.x = t
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            }, set: function(t) {
                this.position.y = t
            }
        }), i.Physics.Arcade.Body.render = function(t, e, i, n) {
            void 0 === n && (n = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), n ? t.fill() : t.stroke()) : n ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }, i.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }, i.Physics.Arcade.Body.prototype.constructor = i.Physics.Arcade.Body, i.Physics.Arcade.TilemapCollision = function() {
        }, i.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16, collideSpriteVsTilemapLayer: function(t, e, i, n, s, r) {
                if(t.body) {
                    var o = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if(0 !== o.length)for(var a = 0; a < o.length; a++)n ? n.call(s, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(s, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(s, t, o[a]))
                }
            }, collideGroupVsTilemapLayer: function(t, e, i, n, s, r) {
                if(0 !== t.length)for(var o = 0; o < t.children.length; o++)t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, n, s, r)
            }, separateTile: function(t, e, i, n, s) {
                if(!e.enable)return !1;
                var r = n.fixedToCamera ? 0 : n.position.x, o = n.fixedToCamera ? 0 : n.position.y;
                if(!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o))return !1;
                if(s)return !0;
                if(i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i))return !1;
                if("undefined" != typeof i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i))return !1;
                if(!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom))return !1;
                var a = 0, h = 0, l = 0, c = 1;
                if(e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                    if((i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, n), 0 !== a && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)))return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, n))
                } else {
                    if((i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, n), 0 !== h && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)))return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, n))
                }
                return 0 !== a || 0 !== h
            }, tileCheckX: function(t, e, i) {
                var n = 0, s = i.fixedToCamera ? 0 : i.position.x;
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - s < e.right && (n = t.x - s - e.right, n < -this.TILE_BIAS && (n = 0)) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - s > e.left && (n = t.right - s - e.left, n > this.TILE_BIAS && (n = 0)), 0 !== n && (t.customSeparateX ? t.overlapX = n : this.processTileSeparationX(t, n)), n
            }, tileCheckY: function(t, e, i) {
                var n = 0, s = i.fixedToCamera ? 0 : i.position.y;
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - s < e.bottom && (n = t.y - s - e.bottom, n < -this.TILE_BIAS && (n = 0)) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - s > e.top && (n = t.bottom - s - e.top, n > this.TILE_BIAS && (n = 0)), 0 !== n && (t.customSeparateY ? t.overlapY = n : this.processTileSeparationY(t, n)), n
            }, processTileSeparationX: function(t, e) {
                e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            }, processTileSeparationY: function(t, e) {
                e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        }, i.Utils.mixinPrototype(i.Physics.Arcade.prototype, i.Physics.Arcade.TilemapCollision.prototype), i.Particle = function(t, e, n, s, r) {
            i.Sprite.call(this, t, e, n, s, r), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, i.Particle.prototype = Object.create(i.Sprite.prototype), i.Particle.prototype.constructor = i.Particle, i.Particle.prototype.update = function() {
            this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, i.Particle.prototype.onEmit = function() {
        }, i.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, i.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, i.Particle.prototype.reset = function(t, e, n) {
            return i.Component.Reset.prototype.reset.call(this, t, e, n), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, i.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, i.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.name] = t, t
            }, remove: function(t) {
                delete this.emitters[t.name]
            }, update: function() {
                for(var t in this.emitters)this.emitters[t].exists && this.emitters[t].update()
            }
        }, i.Particles.prototype.constructor = i.Particles, i.Particles.Arcade = {}, i.Particles.Arcade.Emitter = function(t, e, n, s) {
            this.maxParticles = s || 50, i.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = i.EMITTER, this.physicsType = i.GROUP, this.area = new i.Rectangle(e, n, 1, 1), this.minParticleSpeed = new i.Point((-100), (-100)), this.maxParticleSpeed = new i.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = i.Particle, this.particleDrag = new i.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new i.Point, this.on = !1, this.particleAnchor = new i.Point(.5, .5), this.blendMode = i.blendModes.NORMAL, this.emitX = e, this.emitY = n, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new i.Point(1, 1), this._maxParticleScale = new i.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, i.Particles.Arcade.Emitter.prototype = Object.create(i.Group.prototype), i.Particles.Arcade.Emitter.prototype.constructor = i.Particles.Arcade.Emitter, i.Particles.Arcade.Emitter.prototype.update = function() {
            if(this.on && this.game.time.time >= this._timer)if(this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)if(this._flowQuantity > 0) {
                for(var t = 0; t < this._flowQuantity; t++)if(this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal)) {
                    this.on = !1;
                    break
                }
            } else this.emitParticle() && (this._counter++, this._flowTotal !== -1 && this._counter >= this._flowTotal && (this.on = !1)); else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
            for(var t = this.children.length; t--;)this.children[t].exists && this.children[t].update()
        }, i.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, n, s) {
            void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === n && (n = !1), void 0 === s && (s = !1);
            var r, o = 0, a = t, h = e;
            for(this._frames = e, i > this.maxParticles && (this.maxParticles = i); o < i;)Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), r = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(r, !1), n ? (r.body.checkCollision.any = !0, r.body.checkCollision.none = !1) : r.body.checkCollision.none = !0, r.body.collideWorldBounds = s, r.body.skipQuadTree = !0, r.exists = !1, r.visible = !1, r.anchor.copyFrom(this.particleAnchor), this.add(r), o++;
            return this
        }, i.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, i.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, i.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
        }, i.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, n, s) {
            return void 0 !== i && 0 !== i || (i = 1), void 0 === n && (n = -1), void 0 === s && (s = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = n, s ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
        }, i.Particles.Arcade.Emitter.prototype.start = function(t, e, i, n, s) {
            if(void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === n && (n = 0), void 0 === s && (s = !1), n > this.maxParticles && (n = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || s)for(var r = 0; r < n; r++)this.emitParticle(); else this.on = !0, this._quantity = n, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }, i.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, n) {
            void 0 === t && (t = null), void 0 === e && (e = null);
            var s = this.getFirstExists(!1);
            if(null === s)return !1;
            var r = this.game.rnd;
            void 0 !== i && void 0 !== n ? s.loadTexture(i, n) : void 0 !== i && s.loadTexture(i);
            var o = this.emitX, a = this.emitY;
            null !== t ? o = t : this.width > 1 && (o = r.between(this.left, this.right)), null !== e ? a = e : this.height > 1 && (a = r.between(this.top, this.bottom)), s.reset(o, a), s.angle = 0, s.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(s) : this.particleSendToBack && this.sendToBack(s), this.autoScale ? s.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? s.scale.set(r.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || s.scale.set(r.realInRange(this._minParticleScale.x, this._maxParticleScale.x), r.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === n && (Array.isArray(this._frames) ? s.frame = this.game.rnd.pick(this._frames) : s.frame = this._frames), this.autoAlpha ? s.setAlphaData(this.alphaData) : s.alpha = r.realInRange(this.minParticleAlpha, this.maxParticleAlpha), s.blendMode = this.blendMode;
            var h = s.body;
            return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = r.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = r.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = r.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, s.onEmit(), !0
        }, i.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), i.Group.prototype.destroy.call(this, !0, !1)
        }, i.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t, this.area.height = e, this
        }, i.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
        }, i.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
        }, i.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
        }, i.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, n, s, r) {
            if(void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 0), void 0 === s && (s = i.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, n > 0 && t !== e) {
                var o = {v: t}, a = this.game.make.tween(o).to({v: e}, n, s);
                a.yoyo(r), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.setScale = function(t, e, n, s, r, o, a) {
            if(void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === s && (s = 1), void 0 === r && (r = 0), void 0 === o && (o = i.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, n), this._maxParticleScale.set(e, s), this.autoScale = !1, r > 0 && (t !== e || n !== s)) {
                var h = {x: t, y: n}, l = this.game.make.tween(h).to({x: e, y: s}, r, o);
                l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
        }, Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            }, set: function(t) {
                this.area.width = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            }, set: function(t) {
                this.area.height = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            }, set: function(t) {
                this.emitX = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            }, set: function(t) {
                this.emitY = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = i.POLYGON, PIXI.Graphics.RECT = i.RECTANGLE, PIXI.Graphics.CIRC = i.CIRCLE, PIXI.Graphics.ELIP = i.ELLIPSE, PIXI.Graphics.RREC = i.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", function() {
            return e.Phaser = i
        }()) : e.Phaser = i, i
    }.call(this);
    var spine = {
        radDeg: 180 / Math.PI,
        degRad: Math.PI / 180,
        Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
        Uint32Array: "undefined" == typeof Uint32Array ? Array : Uint32Array,
        Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array
    };
    spine.temp = new spine.Float32Array(2), spine.BoneData = function(t, e) {
        this.name = t, this.parent = e
    }, spine.BoneData.prototype = {
        length: 0,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        inheritScale: !0,
        inheritRotation: !0
    }, spine.BlendMode = {normal: 0, additive: 1, multiply: 2, screen: 3}, spine.SlotData = function(t, e) {
        this.name = t, this.boneData = e
    }, spine.SlotData.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        attachmentName: null,
        blendMode: spine.BlendMode.normal
    }, spine.IkConstraintData = function(t) {
        this.name = t, this.bones = []
    }, spine.IkConstraintData.prototype = {
        target: null,
        bendDirection: 1,
        mix: 1
    }, spine.TransformConstraintData = function(t) {
        this.name = t
    }, spine.TransformConstraintData.prototype = {
        bone: null,
        target: null,
        translateMix: 1,
        x: 0,
        y: 0
    }, spine.Bone = function(t, e, i) {
        this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose()
    }, spine.Bone.yDown = !1, spine.Bone.prototype = {
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        a: 0,
        b: 0,
        worldX: 0,
        c: 0,
        d: 0,
        worldY: 0,
        worldSignX: 1,
        worldSignY: 1,
        update: function() {
            this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
        },
        updateWorldTransformWith: function() {
            this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
        },
        updateWorldTransform: function(t, e, i, n, s) {
            this.appliedRotation = i, this.appliedScaleX = n, this.appliedScaleY = s, i *= spine.degRad;
            var r = Math.cos(i), o = Math.sin(i), a = r * n, h = -o * s, l = o * n, c = r * s, u = this.parent;
            if(!u) {
                var d = this.skeleton;
                return d.flipX && (t = -t, a = -a, h = -h), d.flipY != spine.Bone.yDown && (e = -e, l = -l, c = -c), this.a = a, this.b = h, this.c = l, this.d = c, this.worldX = t, this.worldY = e, this.worldSignX = n < 0 ? -1 : 1, void(this.worldSignY = s < 0 ? -1 : 1)
            }
            var p = u.a, f = u.b, g = u.c, m = u.d;
            if(this.worldX = p * t + f * e + u.worldX, this.worldY = g * t + m * e + u.worldY, this.worldSignX = u.worldSignX * (n < 0 ? -1 : 1), this.worldSignY = u.worldSignY * (s < 0 ? -1 : 1), this.data.inheritRotation && this.data.inheritScale) this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c; else {
                if(this.data.inheritRotation) {
                    p = 1, f = 0, g = 0, m = 1;
                    do {
                        i = u.appliedRotation * spine.degRad, r = Math.cos(i), o = Math.sin(i);
                        var y = p * r + f * o;
                        if(f = p * -o + f * r, p = y, y = g * r + m * o, m = g * -o + m * r, g = y, !u.data.inheritRotation)break;
                        u = u.parent
                    } while(u);
                    this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c
                } else if(this.data.inheritScale) {
                    p = 1, f = 0, g = 0, m = 1;
                    do {
                        i = u.appliedRotation * spine.degRad, r = Math.cos(i), o = Math.sin(i);
                        var v = u.appliedScaleX, x = u.appliedScaleY, _ = r * v, b = -o * x, w = o * v, T = r * x,
                            y = p * _ + f * w;
                        if(f = p * b + f * T, p = y, y = g * _ + m * w, m = g * b + m * T, g = y, v < 0 && (i = -i), r = Math.cos(-i), o = Math.sin(-i), y = p * r + f * o, f = p * -o + f * r, p = y, y = g * r + m * o, m = g * -o + m * r, g = y, !u.data.inheritScale)break;
                        u = u.parent
                    } while(u);
                    this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c
                } else this.a = a, this.b = h, this.c = l, this.d = c;
                this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY != spine.Bone.yDown && (this.c = -this.c, this.d = -this.d)
            }
        },
        setToSetupPose: function() {
            var t = this.data;
            this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY
        },
        getWorldRotationX: function() {
            return Math.atan2(this.c, this.a) * spine.radDeg
        },
        getWorldRotationY: function() {
            return Math.atan2(this.d, this.b) * spine.radDeg
        },
        getWorldScaleX: function() {
            return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX
        },
        getWorldScaleY: function() {
            return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY
        },
        worldToLocal: function(t) {
            var e = t[0] - this.worldX, i = t[1] - this.worldY, n = this.a, s = this.b, r = this.c, o = this.d,
                a = 1 / (n * o - s * r);
            return t[0] = e * o * a - i * s * a, t[1] = i * n * a - e * r * a, t
        },
        localToWorld: function(t) {
            var e = t[0], i = t[1];
            return t[0] = e * this.a + i * this.b + this.worldX, t[1] = e * this.c + i * this.d + this.worldY, t
        }
    }, spine.Slot = function(t, e) {
        this.data = t, this.bone = e, this.attachmentVertices = new spine.Float32Array, this.setToSetupPose()
    }, spine.Slot.prototype = {
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        _attachmentTime: 0,
        attachment: null,
        setAttachment: function(t) {
            this.attachment != t && (this.attachment = t, this._attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
        },
        setAttachmentTime: function(t) {
            this._attachmentTime = this.bone.skeleton.time - t
        },
        getAttachmentTime: function() {
            return this.bone.skeleton.time - this._attachmentTime
        },
        setToSetupPose: function() {
            var t = this.data;
            if(this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, t.attachmentName) {
                for(var e = this.bone.skeleton.data.slots, i = 0, n = e.length; i < n; i++)if(e[i] == t) {
                    this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(i, t.attachmentName));
                    break
                }
            } else this.setAttachment(null)
        }
    }, spine.IkConstraint = function(t, e) {
        this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = [];
        for(var i = 0, n = t.bones.length; i < n; i++)this.bones[i] = e.findBone(t.bones[i].name);
        this.target = e.findBone(t.target.name)
    }, spine.IkConstraint.prototype = {
        apply: function() {
            this.update()
        }, update: function() {
            var t = this.target, e = this.bones;
            switch(e.length) {
                case 1:
                    spine.IkConstraint.apply1(e[0], t.worldX, t.worldY, this.mix);
                    break;
                case 2:
                    spine.IkConstraint.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix)
            }
        }
    }, spine.IkConstraint.apply1 = function(t, e, i, n) {
        var s = t.parent ? t.parent.getWorldRotationX() : 0, r = t.rotation,
            o = Math.atan2(i - t.worldY, e - t.worldX) * spine.radDeg - s;
        t.worldSignX != t.worldSignY != (t.skeleton.flipX != (t.skeleton.flipY != spine.Bone.yDown)) && (o = 360 - o), o > 180 ? o -= 360 : o < -180 && (o += 360), t.updateWorldTransform(t.x, t.y, r + (o - r) * n, t.appliedScaleX, t.appliedScaleY)
    }, spine.IkConstraint.apply2 = function(t, e, i, n, s, r) {
        if(0 != r) {
            var o, a, h, l = t.x, c = t.y, u = t.appliedScaleX, d = t.appliedScaleY;
            u < 0 ? (u = -u, o = 180, h = -1) : (o = 0, h = 1), d < 0 && (d = -d, h = -h);
            var p = e.x, f = e.y, g = e.appliedScaleX, m = Math.abs(u - d) <= 1e-4;
            m || 0 == f || (e.worldX = t.a * p + t.worldX, e.worldY = t.c * p + t.worldY, f = 0), g < 0 ? (g = -g, a = 180) : a = 0;
            var y, v, x, _, b = t.parent;
            if(b) {
                var w = b.a, T = b.b, P = b.c, C = b.d, S = 1 / (w * C - T * P), I = b.worldX, O = b.worldY, A = i - I,
                    M = n - O;
                y = (A * C - M * T) * S - l, v = (M * w - A * P) * S - c, A = e.worldX - I, M = e.worldY - O, x = (A * C - M * T) * S - l, _ = (M * w - A * P) * S - c
            } else y = i - l, v = n - c, x = e.worldX - l, _ = e.worldY - c;
            var k, E, R = Math.sqrt(x * x + _ * _), D = e.data.length * g;
            t:if(m) {
                D *= u;
                var L = (y * y + v * v - R * R - D * D) / (2 * R * D);
                L < -1 ? L = -1 : L > 1 && (L = 1), E = Math.acos(L) * s;
                var w = R + D * L, B = D * Math.sin(E);
                k = Math.atan2(v * w - y * B, y * w + v * B)
            } else {
                var w = u * D, T = d * D, F = Math.atan2(v, y), U = w * w, X = T * T, j = R * R, G = y * y + v * v,
                    N = X * j + U * G - U * X, H = -2 * X * R, W = X - U, C = H * H - 4 * W * N;
                if(C >= 0) {
                    var Y = Math.sqrt(C);
                    H < 0 && (Y = -Y), Y = -(H + Y) / 2;
                    var V = Y / W, z = N / Y, q = Math.abs(V) < Math.abs(z) ? V : z;
                    if(q * q <= G) {
                        var M = Math.sqrt(G - q * q) * s;
                        k = F - Math.atan2(M, q), E = Math.atan2(M / d, (q - R) / u);
                        break t
                    }
                }
                var J = 0, K = Number.MAX_VALUE, Q = 0, Z = 0, $ = 0, tt = 0, et = 0, it = 0, A = R + w, nt = A * A;
                nt > tt && ($ = 0, tt = nt, et = A), A = R - w, nt = A * A, nt < K && (J = Math.PI, K = nt, Q = A);
                var st = Math.acos(-w * R / (U - X));
                A = w * Math.cos(st) + R;
                var M = T * Math.sin(st);
                nt = A * A + M * M, nt < K && (J = st, K = nt, Q = A, Z = M), nt > tt && ($ = st, tt = nt, et = A, it = M), G <= (K + tt) / 2 ? (k = F - Math.atan2(Z * s, Q), E = J * s) : (k = F - Math.atan2(it * s, et), E = $ * s)
            }
            var rt = Math.atan2(f, p) * h;
            k = (k - rt) * spine.radDeg + o, E = (E + rt) * spine.radDeg * h + a, k > 180 ? k -= 360 : k < -180 && (k += 360), E > 180 ? E -= 360 : E < -180 && (E += 360);
            var ot = t.rotation;
            t.updateWorldTransform(l, c, ot + (k - ot) * r, t.appliedScaleX, t.appliedScaleY), ot = e.rotation, e.updateWorldTransform(p, f, ot + (E - ot) * r, e.appliedScaleX, e.appliedScaleY)
        }
    }, spine.TransformConstraint = function(t, e) {
        this.data = t, this.translateMix = t.translateMix, this.x = t.x, this.y = t.y, this.bone = e.findBone(t.bone.name), this.target = e.findBone(t.target.name)
    }, spine.TransformConstraint.prototype = {
        apply: function() {
            this.update()
        }, update: function() {
            var t = this.translateMix;
            if(t > 0) {
                var e = spine.temp;
                e[0] = x, e[1] = y, this.target.localToWorld(e);
                var i = this.bone;
                i.worldX += (e[0] - i.worldX) * t, i.worldY += (e[1] - i.worldY) * t
            }
        }
    }, spine.Skin = function(t) {
        this.name = t, this.attachments = {}
    }, spine.Skin.prototype = {
        addAttachment: function(t, e, i) {
            this.attachments[t + ":" + e] = i
        }, getAttachment: function(t, e) {
            return this.attachments[t + ":" + e]
        }, _attachAll: function(t, e) {
            for(var i in e.attachments) {
                var n = i.indexOf(":"), s = parseInt(i.substring(0, n)), r = i.substring(n + 1), o = t.slots[s];
                if(o.attachment && o.attachment.name == r) {
                    var a = this.getAttachment(s, r);
                    a && o.setAttachment(a)
                }
            }
        }
    }, spine.Animation = function(t, e, i) {
        this.name = t, this.timelines = e, this.duration = i
    }, spine.Animation.prototype = {
        apply: function(t, e, i, n, s) {
            n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
            for(var r = this.timelines, o = 0, a = r.length; o < a; o++)r[o].apply(t, e, i, s, 1)
        }, mix: function(t, e, i, n, s, r) {
            n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
            for(var o = this.timelines, a = 0, h = o.length; a < h; a++)o[a].apply(t, e, i, s, r)
        }
    }, spine.Animation.binarySearch = function(t, e, i) {
        var n = 0, s = Math.floor(t.length / i) - 2;
        if(!s)return i;
        for(var r = s >>> 1; ;) {
            if(t[(r + 1) * i] <= e ? n = r + 1 : s = r, n == s)return (n + 1) * i;
            r = n + s >>> 1
        }
    }, spine.Animation.binarySearch1 = function(t, e) {
        var i = 0, n = t.length - 2;
        if(!n)return 1;
        for(var s = n >>> 1; ;) {
            if(t[s + 1] <= e ? i = s + 1 : n = s, i == n)return i + 1;
            s = i + n >>> 1
        }
    }, spine.Animation.linearSearch = function(t, e, i) {
        for(var n = 0, s = t.length - i; n <= s; n += i)if(t[n] > e)return n;
        return -1
    }, spine.Curves = function(t) {
        var e = 19 * (t - 1);
        this.curves = new spine.Float32Array(e), this.curves.length = e
    }, spine.Curves.prototype = {
        setLinear: function(t) {
            this.curves[19 * t] = 0
        }, setStepped: function(t) {
            this.curves[19 * t] = 1
        }, setCurve: function(t, e, i, n, s) {
            var r = .1, o = r * r, a = o * r, h = 3 * r, l = 3 * o, c = 6 * o, u = 6 * a, d = 2 * -e + n,
                p = 2 * -i + s, f = 3 * (e - n) + 1, g = 3 * (i - s) + 1, m = e * h + d * l + f * a,
                y = i * h + p * l + g * a, v = d * c + f * u, x = p * c + g * u, _ = f * u, b = g * u, w = 19 * t,
                T = this.curves;
            T[w++] = 2;
            for(var P = m, C = y,
                    S = w + 19 - 1; w < S; w += 2)T[w] = P, T[w + 1] = C, m += v, y += x, v += _, x += b, P += m, C += y
        }, getCurvePercent: function(t, e) {
            e = e < 0 ? 0 : e > 1 ? 1 : e;
            var i = this.curves, n = 19 * t, s = i[n];
            if(0 === s)return e;
            if(1 == s)return 0;
            n++;
            for(var r = 0, o = n, a = n + 19 - 1; n < a; n += 2)if(r = i[n], r >= e) {
                var h, l;
                return n == o ? (h = 0, l = 0) : (h = i[n - 2], l = i[n - 1]), l + (i[n + 1] - l) * (e - h) / (r - h)
            }
            var c = i[n - 1];
            return c + (1 - c) * (e - r) / (1 - r)
        }
    }, spine.RotateTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(2 * t), this.frames.length = 2 * t
    }, spine.RotateTimeline.prototype = {
        boneIndex: 0, getFrameCount: function() {
            return this.frames.length / 2
        }, setFrame: function(t, e, i) {
            t *= 2, this.frames[t] = e, this.frames[t + 1] = i
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o = t.bones[this.boneIndex];
                if(i >= r[r.length - 2]) {
                    for(var a = o.data.rotation + r[r.length - 1] - o.rotation; a > 180;)a -= 360;
                    for(; a < -180;)a += 360;
                    return void(o.rotation += a * s)
                }
                var h = spine.Animation.binarySearch(r, i, 2), l = r[h - 1], c = r[h], u = 1 - (i - c) / (r[h - 2] - c);
                u = this.curves.getCurvePercent(h / 2 - 1, u);
                for(var a = r[h + 1] - l; a > 180;)a -= 360;
                for(; a < -180;)a += 360;
                for(a = o.data.rotation + (l + a * u) - o.rotation; a > 180;)a -= 360;
                for(; a < -180;)a += 360;
                o.rotation += a * s
            }
        }
    }, spine.TranslateTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
    }, spine.TranslateTimeline.prototype = {
        boneIndex: 0, getFrameCount: function() {
            return this.frames.length / 3
        }, setFrame: function(t, e, i, n) {
            t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o = t.bones[this.boneIndex];
                if(i >= r[r.length - 3])return o.x += (o.data.x + r[r.length - 2] - o.x) * s, void(o.y += (o.data.y + r[r.length - 1] - o.y) * s);
                var a = spine.Animation.binarySearch(r, i, 3), h = r[a - 2], l = r[a - 1], c = r[a],
                    u = 1 - (i - c) / (r[a + -3] - c);
                u = this.curves.getCurvePercent(a / 3 - 1, u), o.x += (o.data.x + h + (r[a + 1] - h) * u - o.x) * s, o.y += (o.data.y + l + (r[a + 2] - l) * u - o.y) * s
            }
        }
    }, spine.ScaleTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
    }, spine.ScaleTimeline.prototype = {
        boneIndex: 0, getFrameCount: function() {
            return this.frames.length / 3
        }, setFrame: function(t, e, i, n) {
            t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o = t.bones[this.boneIndex];
                if(i >= r[r.length - 3])return o.scaleX += (o.data.scaleX * r[r.length - 2] - o.scaleX) * s, void(o.scaleY += (o.data.scaleY * r[r.length - 1] - o.scaleY) * s);
                var a = spine.Animation.binarySearch(r, i, 3), h = r[a - 2], l = r[a - 1], c = r[a],
                    u = 1 - (i - c) / (r[a + -3] - c);
                u = this.curves.getCurvePercent(a / 3 - 1, u), o.scaleX += (o.data.scaleX * (h + (r[a + 1] - h) * u) - o.scaleX) * s, o.scaleY += (o.data.scaleY * (l + (r[a + 2] - l) * u) - o.scaleY) * s
            }
        }
    }, spine.ColorTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(5 * t), this.frames.length = 5 * t
    }, spine.ColorTimeline.prototype = {
        slotIndex: 0, getFrameCount: function() {
            return this.frames.length / 5
        }, setFrame: function(t, e, i, n, s, r) {
            t *= 5, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n, this.frames[t + 3] = s, this.frames[t + 4] = r
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o, a, h, l;
                if(i >= r[r.length - 5]) {
                    var c = r.length - 1;
                    o = r[c - 3], a = r[c - 2], h = r[c - 1], l = r[c]
                } else {
                    var u = spine.Animation.binarySearch(r, i, 5), d = r[u - 4], p = r[u - 3], f = r[u - 2],
                        g = r[u - 1], m = r[u], y = 1 - (i - m) / (r[u - 5] - m);
                    y = this.curves.getCurvePercent(u / 5 - 1, y), o = d + (r[u + 1] - d) * y, a = p + (r[u + 2] - p) * y, h = f + (r[u + 3] - f) * y, l = g + (r[u + 4] - g) * y
                }
                var v = t.slots[this.slotIndex];
                s < 1 ? (v.r += (o - v.r) * s, v.g += (a - v.g) * s, v.b += (h - v.b) * s, v.a += (l - v.a) * s) : (v.r = o, v.g = a, v.b = h, v.a = l)
            }
        }
    }, spine.AttachmentTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.attachmentNames = [], this.attachmentNames.length = t
    }, spine.AttachmentTimeline.prototype = {
        slotIndex: 0, getFrameCount: function() {
            return this.frames.length
        }, setFrame: function(t, e, i) {
            this.frames[t] = e, this.attachmentNames[t] = i
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(i < r[0])return void(e > i && this.apply(t, e, Number.MAX_VALUE, null, 0));
            e > i && (e = -1);
            var o = i >= r[r.length - 1] ? r.length - 1 : spine.Animation.binarySearch1(r, i) - 1;
            if(!(r[o] < e)) {
                var a = this.attachmentNames[o];
                t.slots[this.slotIndex].setAttachment(a ? t.getAttachmentBySlotIndex(this.slotIndex, a) : null)
            }
        }
    }, spine.EventTimeline = function(t) {
        this.frames = new spine.Float32Array(t), this.frames.length = t, this.events = [], this.events.length = t
    }, spine.EventTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length
        }, setFrame: function(t, e) {
            this.frames[t] = e.time, this.events[t] = e
        }, apply: function(t, e, i, n, s) {
            if(n) {
                var r = this.frames, o = r.length;
                if(e > i) this.apply(t, e, Number.MAX_VALUE, n, s), e = -1; else if(e >= r[o - 1])return;
                if(!(i < r[0])) {
                    var a;
                    if(e < r[0]) a = 0; else {
                        a = spine.Animation.binarySearch1(r, e);
                        for(var h = r[a]; a > 0 && r[a - 1] == h;)a--
                    }
                    for(var l = this.events; a < o && i >= r[a]; a++)n[n.length] = l[a]
                }
            }
        }
    }, spine.DrawOrderTimeline = function(t) {
        this.frames = new spine.Float32Array(t), this.frames.length = t, this.drawOrders = [], this.drawOrders.length = t
    }, spine.DrawOrderTimeline.prototype = {
        getFrameCount: function() {
            return this.frames.length
        }, setFrame: function(t, e, i) {
            this.frames[t] = e, this.drawOrders[t] = i
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o;
                o = i >= r[r.length - 1] ? r.length - 1 : spine.Animation.binarySearch1(r, i) - 1;
                var a = t.drawOrder, h = t.slots, l = this.drawOrders[o];
                if(l)for(var c = 0, u = l.length; c < u; c++)a[c] = t.slots[l[c]]; else for(var c = 0,
                                                                                                u = h.length; c < u; c++)a[c] = h[c]
            }
        }
    }, spine.FfdTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.frameVertices = [], this.frameVertices.length = t
    }, spine.FfdTimeline.prototype = {
        slotIndex: 0, attachment: 0, getFrameCount: function() {
            return this.frames.length
        }, setFrame: function(t, e, i) {
            this.frames[t] = e, this.frameVertices[t] = i
        }, apply: function(t, e, i, n, s) {
            var r = t.slots[this.slotIndex], o = r.attachment;
            if(o && (o == this.attachment || o.inheritFFD && o.parentMesh == this.attachment)) {
                var a = this.frames;
                if(!(i < a[0])) {
                    var h = this.frameVertices, l = h[0].length, c = r.attachmentVertices;
                    if(c.length != l && (r.attachmentVertices = c = new spine.Float32Array(l), s = 1), i >= a[a.length - 1]) {
                        var u = h[a.length - 1];
                        if(s < 1)for(var d = 0; d < l; d++)c[d] += (u[d] - c[d]) * s; else for(var d = 0; d < l; d++)c[d] = u[d]
                    } else {
                        var p = spine.Animation.binarySearch1(a, i), f = a[p], g = 1 - (i - f) / (a[p - 1] - f);
                        g = this.curves.getCurvePercent(p - 1, g < 0 ? 0 : g > 1 ? 1 : g);
                        var m = h[p - 1], y = h[p];
                        if(s < 1)for(var d = 0; d < l; d++) {
                            var v = m[d];
                            c[d] += (v + (y[d] - v) * g - c[d]) * s
                        } else for(var d = 0; d < l; d++) {
                            var v = m[d];
                            c[d] = v + (y[d] - v) * g
                        }
                    }
                }
            }
        }
    }, spine.IkConstraintTimeline = function(t) {
        this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
    }, spine.IkConstraintTimeline.prototype = {
        ikConstraintIndex: 0, getFrameCount: function() {
            return this.frames.length / 3
        }, setFrame: function(t, e, i, n) {
            t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
        }, apply: function(t, e, i, n, s) {
            var r = this.frames;
            if(!(i < r[0])) {
                var o = t.ikConstraints[this.ikConstraintIndex];
                if(i >= r[r.length - 3])return o.mix += (r[r.length - 2] - o.mix) * s, void(o.bendDirection = r[r.length - 1]);
                var a = spine.Animation.binarySearch(r, i, 3), h = r[a + -2], l = r[a],
                    c = 1 - (i - l) / (r[a + -3] - l);
                c = this.curves.getCurvePercent(a / 3 - 1, c);
                var u = h + (r[a + 1] - h) * c;
                o.mix += (u - o.mix) * s, o.bendDirection = r[a + -1]
            }
        }
    }, spine.SkeletonData = function() {
        this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = []
    }, spine.SkeletonData.prototype = {
        name: null,
        defaultSkin: null,
        width: 0,
        height: 0,
        version: null,
        hash: null,
        findBone: function(t) {
            for(var e = this.bones, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        },
        findBoneIndex: function(t) {
            for(var e = this.bones, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return i;
            return -1
        },
        findSlot: function(t) {
            for(var e = this.slots, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return slot[i];
            return null
        },
        findSlotIndex: function(t) {
            for(var e = this.slots, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return i;
            return -1
        },
        findSkin: function(t) {
            for(var e = this.skins, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        },
        findEvent: function(t) {
            for(var e = this.events, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        },
        findAnimation: function(t) {
            for(var e = this.animations, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        },
        findIkConstraint: function(t) {
            for(var e = this.ikConstraints, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        },
        findTransformConstraints: function(t) {
            for(var e = this.transformConstraints, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        }
    }, spine.Skeleton = function(t) {
        this.data = t, this.bones = [];
        for(var e = 0, i = t.bones.length; e < i; e++) {
            var n = t.bones[e], s = n.parent ? this.bones[t.bones.indexOf(n.parent)] : null;
            this.bones[e] = new spine.Bone(n, this, s)
        }
        this.slots = [], this.drawOrder = [];
        for(var e = 0, i = t.slots.length; e < i; e++) {
            var r = t.slots[e], o = this.bones[t.bones.indexOf(r.boneData)], a = new spine.Slot(r, o);
            this.slots[e] = a, this.drawOrder[e] = a
        }
        this.ikConstraints = [];
        for(var e = 0,
                i = t.ikConstraints.length; e < i; e++)this.ikConstraints[e] = new spine.IkConstraint(t.ikConstraints[e], this);
        this.transformConstraints = [];
        for(var e = 0,
                i = t.transformConstraints.length; e < i; e++)this.transformConstraints[e] = new spine.TransformConstraint(t.transformConstraints[e], this);
        this.cache = [], this.updateCache()
    }, spine.Skeleton.prototype = {
        x: 0, y: 0, skin: null, r: 1, g: 1, b: 1, a: 1, time: 0, flipX: !1, flipY: !1, updateCache: function() {
            var t = this.bones, e = this.cache, i = this.ikConstraints, n = this.transformConstraints, s = i.length,
                r = n.length;
            e.length = 0;
            for(var o = 0, a = t.length; o < a; o++) {
                var h = t[o];
                e[e.length] = h;
                for(var l = 0; l < s; l++) {
                    var c = i[l];
                    if(h == c.bones[c.bones.length - 1]) {
                        e[e.length] = c;
                        break
                    }
                }
            }
            for(var o = 0; o < r; o++)for(var u = n[o], l = e.length - 1; l >= 0; l--) {
                var d = e[l];
                if(d == u.bone || d == u.target) {
                    e.splice(l + 1, 0, u);
                    break
                }
            }
        }, updateWorldTransform: function() {
            for(var t = this.cache, e = 0, i = t.length; e < i; e++)t[e].update()
        }, setToSetupPose: function() {
            this.setBonesToSetupPose(), this.setSlotsToSetupPose()
        }, setBonesToSetupPose: function() {
            for(var t = this.bones, e = 0, i = t.length; e < i; e++)t[e].setToSetupPose();
            for(var n = this.ikConstraints, e = 0, i = n.length; e < i; e++) {
                var s = n[e];
                s.bendDirection = s.data.bendDirection, s.mix = s.data.mix
            }
            for(var r = this.transformConstraints, e = 0, i = r.length; e < i; e++) {
                var s = r[e];
                s.translateMix = s.data.translateMix, s.x = s.data.x, s.y = s.data.y
            }
        }, setSlotsToSetupPose: function() {
            for(var t = this.slots, e = this.drawOrder, i = 0,
                    n = t.length; i < n; i++)e[i] = t[i], t[i].setToSetupPose(i)
        }, getRootBone: function() {
            return this.bones.length ? this.bones[0] : null
        }, findBone: function(t) {
            for(var e = this.bones, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return e[i];
            return null
        }, findBoneIndex: function(t) {
            for(var e = this.bones, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return i;
            return -1
        }, findSlot: function(t) {
            for(var e = this.slots, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return e[i];
            return null
        }, findSlotIndex: function(t) {
            for(var e = this.slots, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return i;
            return -1
        }, setSkinByName: function(t) {
            var e = this.data.findSkin(t);
            if(!e)throw"Skin not found: " + t;
            this.setSkin(e)
        }, setSkin: function(t) {
            if(t)if(this.skin) t._attachAll(this, this.skin); else for(var e = this.slots, i = 0,
                                                                           n = e.length; i < n; i++) {
                var s = e[i], r = s.data.attachmentName;
                if(r) {
                    var o = t.getAttachment(i, r);
                    o && s.setAttachment(o)
                }
            }
            this.skin = t
        }, getAttachmentBySlotName: function(t, e) {
            return this.getAttachmentBySlotIndex(this.data.findSlotIndex(t), e)
        }, getAttachmentBySlotIndex: function(t, e) {
            if(this.skin) {
                var i = this.skin.getAttachment(t, e);
                if(i)return i
            }
            return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
        }, setAttachment: function(t, e) {
            for(var i = this.slots, n = 0, s = i.length; n < s; n++) {
                var r = i[n];
                if(r.data.name == t) {
                    var o = null;
                    if(e && (o = this.getAttachmentBySlotIndex(n, e), !o))throw"Attachment not found: " + e + ", for slot: " + t;
                    return void r.setAttachment(o)
                }
            }
            throw"Slot not found: " + t
        }, findIkConstraint: function(t) {
            for(var e = this.ikConstraints, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return e[i];
            return null
        }, findTransformConstraint: function(t) {
            for(var e = this.transformConstraints, i = 0, n = e.length; i < n; i++)if(e[i].data.name == t)return e[i];
            return null
        }, update: function(t) {
            this.time += t
        }
    }, spine.EventData = function(t) {
        this.name = t
    }, spine.EventData.prototype = {intValue: 0, floatValue: 0, stringValue: null}, spine.Event = function(t, e) {
        this.time = t, this.data = e
    }, spine.Event.prototype = {intValue: 0, floatValue: 0, stringValue: null}, spine.AttachmentType = {
        region: 0,
        boundingbox: 1,
        mesh: 2,
        weightedmesh: 3,
        linkedmesh: 4,
        weightedlinkedmesh: 5
    }, spine.RegionAttachment = function(t) {
        this.name = t, this.offset = new spine.Float32Array(8), this.offset.length = 8, this.uvs = new spine.Float32Array(8), this.uvs.length = 8
    }, spine.RegionAttachment.prototype = {
        type: spine.AttachmentType.region,
        x: 0,
        y: 0,
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        width: 0,
        height: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        rendererObject: null,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        setUVs: function(t, e, i, n, s) {
            var r = this.uvs;
            s ? (r[2] = t, r[3] = n, r[4] = t, r[5] = e, r[6] = i, r[7] = e, r[0] = i, r[1] = n) : (r[0] = t, r[1] = n, r[2] = t, r[3] = e, r[4] = i, r[5] = e, r[6] = i, r[7] = n)
        },
        updateOffset: function() {
            var t = this.width / this.regionOriginalWidth * this.scaleX,
                e = this.height / this.regionOriginalHeight * this.scaleY,
                i = -this.width / 2 * this.scaleX + this.regionOffsetX * t,
                n = -this.height / 2 * this.scaleY + this.regionOffsetY * e, s = i + this.regionWidth * t,
                r = n + this.regionHeight * e, o = this.rotation * spine.degRad, a = Math.cos(o), h = Math.sin(o),
                l = i * a + this.x, c = i * h, u = n * a + this.y, d = n * h, p = s * a + this.x, f = s * h,
                g = r * a + this.y, m = r * h, y = this.offset;
            y[0] = l - d, y[1] = u + c, y[2] = l - m, y[3] = g + c, y[4] = p - m, y[5] = g + f, y[6] = p - d, y[7] = u + f
        },
        computeVertices: function(t, e, i, n) {
            t += i.worldX, e += i.worldY;
            var s = i.a, r = i.b, o = i.c, a = i.d, h = this.offset;
            n[0] = h[0] * s + h[1] * r + t, n[1] = h[0] * o + h[1] * a + e, n[2] = h[2] * s + h[3] * r + t, n[3] = h[2] * o + h[3] * a + e, n[4] = h[4] * s + h[5] * r + t, n[5] = h[4] * o + h[5] * a + e, n[6] = h[6] * s + h[7] * r + t, n[7] = h[6] * o + h[7] * a + e
        }
    }, spine.MeshAttachment = function(t) {
        this.name = t
    }, spine.MeshAttachment.prototype = {
        type: spine.AttachmentType.mesh,
        vertices: null,
        uvs: null,
        regionUVs: null,
        triangles: null,
        hullLength: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        inheritFFD: !0,
        parentMesh: null,
        rendererObject: null,
        regionU: 0,
        regionV: 0,
        regionU2: 0,
        regionV2: 0,
        regionRotate: !1,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        edges: null,
        width: 0,
        height: 0,
        updateUVs: function() {
            var t = this.regionU2 - this.regionU, e = this.regionV2 - this.regionV, i = this.regionUVs.length;
            if(this.uvs && this.uvs.length == i || (this.uvs = new spine.Float32Array(i)), this.regionRotate)for(var n = 0; n < i; n += 2)this.uvs[n] = this.regionU + this.regionUVs[n + 1] * t, this.uvs[n + 1] = this.regionV + e - this.regionUVs[n] * e; else for(var n = 0; n < i; n += 2)this.uvs[n] = this.regionU + this.regionUVs[n] * t, this.uvs[n + 1] = this.regionV + this.regionUVs[n + 1] * e
        },
        computeWorldVertices: function(t, e, i, n) {
            var s = i.bone;
            t += s.worldX, e += s.worldY;
            var r = s.a, o = s.b, a = s.c, h = s.d, l = this.vertices, c = l.length;
            i.attachmentVertices.length == c && (l = i.attachmentVertices);
            for(var u = 0; u < c; u += 2) {
                var d = l[u], p = l[u + 1];
                n[u] = d * r + p * o + t, n[u + 1] = d * a + p * h + e
            }
        },
        setParentMesh: function(t) {
            this.parentMesh = t, t && (this.vertices = t.vertices, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
        }
    }, spine.WeightedMeshAttachment = function(t) {
        this.name = t
    }, spine.WeightedMeshAttachment.prototype = {
        type: spine.AttachmentType.weightedmesh,
        bones: null,
        weights: null,
        uvs: null,
        regionUVs: null,
        triangles: null,
        hullLength: 0,
        r: 1,
        g: 1,
        b: 1,
        a: 1,
        path: null,
        inheritFFD: !0,
        parentMesh: null,
        rendererObject: null,
        regionU: 0,
        regionV: 0,
        regionU2: 0,
        regionV2: 0,
        regionRotate: !1,
        regionOffsetX: 0,
        regionOffsetY: 0,
        regionWidth: 0,
        regionHeight: 0,
        regionOriginalWidth: 0,
        regionOriginalHeight: 0,
        edges: null,
        width: 0,
        height: 0,
        updateUVs: function(t, e, i, n, s) {
            var r = this.regionU2 - this.regionU, o = this.regionV2 - this.regionV, a = this.regionUVs.length;
            if(this.uvs && this.uvs.length == a || (this.uvs = new spine.Float32Array(a)), this.regionRotate)for(var h = 0; h < a; h += 2)this.uvs[h] = this.regionU + this.regionUVs[h + 1] * r, this.uvs[h + 1] = this.regionV + o - this.regionUVs[h] * o; else for(var h = 0; h < a; h += 2)this.uvs[h] = this.regionU + this.regionUVs[h] * r, this.uvs[h + 1] = this.regionV + this.regionUVs[h + 1] * o
        },
        computeWorldVertices: function(t, e, i, n) {
            var s, r, o, a, h, l, c, u = i.bone.skeleton.bones, d = this.weights, p = this.bones, f = 0, g = 0, m = 0,
                y = 0, v = p.length;
            if(i.attachmentVertices.length)for(var x = i.attachmentVertices; g < v; f += 2) {
                for(r = 0, o = 0, s = p[g++] + g; g < s; g++, m += 3, y += 2)a = u[p[g]], h = d[m] + x[y], l = d[m + 1] + x[y + 1], c = d[m + 2], r += (h * a.a + l * a.b + a.worldX) * c, o += (h * a.c + l * a.d + a.worldY) * c;
                n[f] = r + t, n[f + 1] = o + e
            } else for(; g < v; f += 2) {
                for(r = 0, o = 0, s = p[g++] + g; g < s; g++, m += 3)a = u[p[g]], h = d[m], l = d[m + 1], c = d[m + 2], r += (h * a.a + l * a.b + a.worldX) * c, o += (h * a.c + l * a.d + a.worldY) * c;
                n[f] = r + t, n[f + 1] = o + e
            }
        },
        setParentMesh: function(t) {
            this.parentMesh = t, t && (this.bones = t.bones, this.weights = t.weights, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
        }
    }, spine.BoundingBoxAttachment = function(t) {
        this.name = t, this.vertices = new spine.Float32Array
    }, spine.BoundingBoxAttachment.prototype = {
        type: spine.AttachmentType.boundingbox,
        computeWorldVertices: function(t, e, i, n) {
            t += i.worldX, e += i.worldY;
            for(var s = i.a, r = i.b, o = i.c, a = i.d, h = this.vertices, l = 0, c = h.length; l < c; l += 2) {
                var u = h[l], d = h[l + 1];
                n[l] = u * s + d * r + t, n[l + 1] = u * o + d * a + e
            }
        }
    }, spine.AnimationStateData = function(t) {
        this.skeletonData = t, this.animationToMixTime = {}
    }, spine.AnimationStateData.prototype = {
        defaultMix: 0, setMixByName: function(t, e, i) {
            var n = this.skeletonData.findAnimation(t);
            if(!n)throw"Animation not found: " + t;
            var s = this.skeletonData.findAnimation(e);
            if(!s)throw"Animation not found: " + e;
            this.setMix(n, s, i)
        }, setMix: function(t, e, i) {
            this.animationToMixTime[t.name + ":" + e.name] = i
        }, getMix: function(t, e) {
            var i = t.name + ":" + e.name;
            return this.animationToMixTime.hasOwnProperty(i) ? this.animationToMixTime[i] : this.defaultMix
        }
    }, spine.TrackEntry = function() {
    }, spine.TrackEntry.prototype = {
        next: null,
        previous: null,
        animation: null,
        loop: !1,
        delay: 0,
        time: 0,
        lastTime: -1,
        endTime: 0,
        timeScale: 1,
        mixTime: 0,
        mixDuration: 0,
        mix: 1,
        onStart: null,
        onEnd: null,
        onComplete: null,
        onEvent: null
    }, spine.AnimationState = function(t) {
        this.data = t, this.tracks = [], this.events = []
    }, spine.AnimationState.prototype = {
        onStart: null, onEnd: null, onComplete: null, onEvent: null, timeScale: 1, update: function(t) {
            t *= this.timeScale;
            for(var e = 0; e < this.tracks.length; e++) {
                var i = this.tracks[e];
                if(i) {
                    if(i.time += t * i.timeScale, i.previous) {
                        var n = t * i.previous.timeScale;
                        i.previous.time += n, i.mixTime += n
                    }
                    var s = i.next;
                    s ? (s.time = i.lastTime - s.delay, s.time >= 0 && this.setCurrent(e, s)) : !i.loop && i.lastTime >= i.endTime && this.clearTrack(e)
                }
            }
        }, apply: function(t) {
            for(var e = 0; e < this.tracks.length; e++) {
                var i = this.tracks[e];
                if(i) {
                    this.events.length = 0;
                    var n = i.time, s = i.lastTime, r = i.endTime, o = i.loop;
                    !o && n > r && (n = r);
                    var a = i.previous;
                    if(a) {
                        var h = a.time;
                        !a.loop && h > a.endTime && (h = a.endTime), a.animation.apply(t, h, h, a.loop, null);
                        var l = i.mixTime / i.mixDuration * i.mix;
                        l >= 1 && (l = 1, i.previous = null), i.animation.mix(t, i.lastTime, n, o, this.events, l)
                    } else 1 == i.mix ? i.animation.apply(t, i.lastTime, n, o, this.events) : i.animation.mix(t, i.lastTime, n, o, this.events, i.mix);
                    for(var c = 0, u = this.events.length; c < u; c++) {
                        var d = this.events[c];
                        i.onEvent && i.onEvent(e, d), this.onEvent && this.onEvent(e, d)
                    }
                    if(o ? s % r > n % r : s < r && n >= r) {
                        var p = Math.floor(n / r);
                        i.onComplete && i.onComplete(e, p), this.onComplete && this.onComplete(e, p)
                    }
                    i.lastTime = i.time
                }
            }
        }, clearTracks: function() {
            for(var t = 0, e = this.tracks.length; t < e; t++)this.clearTrack(t);
            this.tracks.length = 0
        }, clearTrack: function(t) {
            if(!(t >= this.tracks.length)) {
                var e = this.tracks[t];
                e && (e.onEnd && e.onEnd(t), this.onEnd && this.onEnd(t), this.tracks[t] = null)
            }
        }, _expandToIndex: function(t) {
            if(t < this.tracks.length)return this.tracks[t];
            for(; t >= this.tracks.length;)this.tracks[this.tracks.length] = null;
            return null
        }, setCurrent: function(t, e) {
            var i = this._expandToIndex(t);
            if(i) {
                var n = i.previous;
                i.previous = null, i.onEnd && i.onEnd(t), this.onEnd && this.onEnd(t), e.mixDuration = this.data.getMix(i.animation, e.animation), e.mixDuration > 0 && (e.mixTime = 0, n && i.mixTime / i.mixDuration < .5 ? e.previous = n : e.previous = i)
            }
            this.tracks[t] = e, e.onStart && e.onStart(t), this.onStart && this.onStart(t)
        }, setAnimationByName: function(t, e, i) {
            var n = this.data.skeletonData.findAnimation(e);
            if(!n)throw"Animation not found: " + e;
            return this.setAnimation(t, n, i)
        }, setAnimation: function(t, e, i) {
            var n = new spine.TrackEntry;
            return n.animation = e, n.loop = i, n.endTime = e.duration, this.setCurrent(t, n), n
        }, addAnimationByName: function(t, e, i, n) {
            var s = this.data.skeletonData.findAnimation(e);
            if(!s)throw"Animation not found: " + e;
            return this.addAnimation(t, s, i, n)
        }, addAnimation: function(t, e, i, n) {
            var s = new spine.TrackEntry;
            s.animation = e, s.loop = i, s.endTime = e.duration;
            var r = this._expandToIndex(t);
            if(r) {
                for(; r.next;)r = r.next;
                r.next = s
            } else this.tracks[t] = s;
            return n <= 0 && (r ? n += r.endTime - this.data.getMix(r.animation, e) : n = 0), s.delay = n, s
        }, getCurrent: function(t) {
            return t >= this.tracks.length ? null : this.tracks[t]
        }
    }, spine.SkeletonJson = function(t) {
        this.attachmentLoader = t, this.linkedMeshes = []
    }, spine.SkeletonJson.prototype = {
        scale: 1, readSkeletonData: function(t, e) {
            var i = new spine.SkeletonData;
            i.name = e;
            var n = t.skeleton;
            n && (i.hash = n.hash, i.version = n.spine, i.width = n.width || 0, i.height = n.height || 0);
            for(var s = t.bones, r = 0, o = s.length; r < o; r++) {
                var a = s[r], h = null;
                if(a.parent && (h = i.findBone(a.parent), !h))throw"Parent bone not found: " + a.parent;
                var l = new spine.BoneData(a.name, h);
                l.length = (a.length || 0) * this.scale, l.x = (a.x || 0) * this.scale, l.y = (a.y || 0) * this.scale, l.rotation = a.rotation || 0, l.scaleX = a.hasOwnProperty("scaleX") ? a.scaleX : 1, l.scaleY = a.hasOwnProperty("scaleY") ? a.scaleY : 1, l.inheritScale = !a.hasOwnProperty("inheritScale") || a.inheritScale, l.inheritRotation = !a.hasOwnProperty("inheritRotation") || a.inheritRotation, i.bones[r] = l
            }
            var c = t.ik;
            if(c)for(var r = 0, o = c.length; r < o; r++) {
                for(var u = c[r], d = new spine.IkConstraintData(u.name), s = u.bones, p = 0,
                        f = s.length; p < f; p++) {
                    var g = i.findBone(s[p]);
                    if(!g)throw"IK bone not found: " + s[p];
                    d.bones[p] = g
                }
                if(d.target = i.findBone(u.target), !d.target)throw"Target bone not found: " + u.target;
                d.bendDirection = !u.hasOwnProperty("bendPositive") || u.bendPositive ? 1 : -1, d.mix = u.hasOwnProperty("mix") ? u.mix : 1, i.ikConstraints[r] = d
            }
            var m = t.transform;
            if(m)for(var r = 0, o = m.length; r < o; r++) {
                var y = m[r], v = new spine.TransformConstraintData(y.name);
                if(v.bone = i.findBone(y.bone), !v.bone)throw"Bone not found: " + y.bone;
                if(v.target = i.findBone(y.target), !v.target)throw"Target bone not found: " + y.target;
                v.mix = y.hasOwnProperty("translateMix") ? u.translateMix : 1, v.x = (y.x || 0) * this.scale, v.y = (y.y || 0) * this.scale, i.transformConstraints[r] = v
            }
            for(var x = t.slots, r = 0, o = x.length; r < o; r++) {
                var _ = x[r], l = i.findBone(_.bone);
                if(!l)throw"Slot bone not found: " + _.bone;
                var b = new spine.SlotData(_.name, l), w = _.color;
                w && (b.r = this.toColor(w, 0), b.g = this.toColor(w, 1), b.b = this.toColor(w, 2), b.a = this.toColor(w, 3)), b.attachmentName = _.attachment, b.blendMode = spine.BlendMode[_.blend || "normal"], i.slots[r] = b
            }
            var T = t.skins;
            for(var P in T)if(T.hasOwnProperty(P)) {
                var C = T[P], S = new spine.Skin(P);
                for(var I in C)if(C.hasOwnProperty(I)) {
                    var O = i.findSlotIndex(I), A = C[I];
                    for(var M in A)if(A.hasOwnProperty(M)) {
                        var k = this.readAttachment(S, O, M, A[M]);
                        k && S.addAttachment(O, M, k)
                    }
                }
                i.skins[i.skins.length] = S, "default" == S.name && (i.defaultSkin = S)
            }
            for(var r = 0, o = this.linkedMeshes.length; r < o; r++) {
                var E = this.linkedMeshes[r], S = E.skin ? i.findSkin(E.skin) : i.defaultSkin;
                if(!S)throw"Skin not found: " + E.skin;
                var h = S.getAttachment(E.slotIndex, E.parent);
                if(!h)throw"Parent mesh not found: " + E.parent;
                E.mesh.setParentMesh(h), E.mesh.updateUVs()
            }
            this.linkedMeshes.length = 0;
            var R = t.events;
            for(var D in R)if(R.hasOwnProperty(D)) {
                var L = R[D], B = new spine.EventData(D);
                B.intValue = L["int"] || 0, B.floatValue = L["float"] || 0, B.stringValue = L.string || null, i.events[i.events.length] = B
            }
            var F = t.animations;
            for(var U in F)F.hasOwnProperty(U) && this.readAnimation(U, F[U], i);
            return i
        }, readAttachment: function(t, e, i, n) {
            i = n.name || i;
            var s = n.type || "region";
            "skinnedmesh" == s && (s = "weightedmesh"), s = spine.AttachmentType[s];
            var r = n.path || i, o = this.scale;
            switch(s) {
                case spine.AttachmentType.region:
                    var a = this.attachmentLoader.newRegionAttachment(t, i, r);
                    if(!a)return null;
                    a.path = r, a.x = (n.x || 0) * o, a.y = (n.y || 0) * o, a.scaleX = n.hasOwnProperty("scaleX") ? n.scaleX : 1, a.scaleY = n.hasOwnProperty("scaleY") ? n.scaleY : 1, a.rotation = n.rotation || 0, a.width = (n.width || 0) * o, a.height = (n.height || 0) * o;
                    var h = n.color;
                    return h && (a.r = this.toColor(h, 0), a.g = this.toColor(h, 1), a.b = this.toColor(h, 2), a.a = this.toColor(h, 3)), a.updateOffset(), a;
                case spine.AttachmentType.mesh:
                case spine.AttachmentType.linkedmesh:
                    var l = this.attachmentLoader.newMeshAttachment(t, i, r);
                    return l ? (l.path = r, h = n.color, h && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, n.parent ? (l.inheritFFD = !n.hasOwnProperty("ffd") || n.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                        mesh: l,
                        skin: n.skin,
                        slotIndex: e,
                        parent: n.parent
                    }) : (l.vertices = this.getFloatArray(n, "vertices", o), l.triangles = this.getUint32Array(n, "triangles"), l.regionUVs = this.getFloatArray(n, "uvs", 1), l.updateUVs(), l.hullLength = 2 * (n.hull || 0), n.edges && (l.edges = this.getUint16Array(n, "edges"))), l) : null;
                case spine.AttachmentType.weightedmesh:
                case spine.AttachmentType.weightedlinkedmesh:
                    var l = this.attachmentLoader.newWeightedMeshAttachment(t, i, r);
                    if(!l)return null;
                    if(l.path = r, h = n.color, h && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, n.parent) l.inheritFFD = !n.hasOwnProperty("ffd") || n.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                        mesh: l,
                        skin: n.skin,
                        slotIndex: e,
                        parent: n.parent
                    }; else {
                        for(var c = this.getFloatArray(n, "uvs", 1), u = this.getFloatArray(n, "vertices", 1),
                                d = new spine.Float32Array(3 * c.length * 3), p = new spine.Uint32Array(3 * c.length),
                                f = 0, g = 0, m = 0, y = u.length; f < y;) {
                            var v = 0 | u[f++];
                            p[g++] = v;
                            for(var x = f + 4 * v; f < x;)p[g++] = u[f], d[m++] = u[f + 1] * o, d[m++] = u[f + 2] * o, d[m++] = u[f + 3], f += 4
                        }
                        l.bones = p, l.weights = d, l.triangles = this.getUint32Array(n, "triangles"), l.regionUVs = c, l.updateUVs(), l.hullLength = 2 * (n.hull || 0), n.edges && (l.edges = this.getUint16Array(n, "edges"))
                    }
                    return l;
                case spine.AttachmentType.boundingbox:
                    for(var _ = this.attachmentLoader.newBoundingBoxAttachment(t, i), u = n.vertices, f = 0,
                            y = u.length; f < y; f++)_.vertices[f] = u[f] * o;
                    return _
            }
            throw"Unknown attachment type: " + s
        }, readAnimation: function(t, e, i) {
            var n = [], s = 0, r = e.slots;
            for(var o in r)if(r.hasOwnProperty(o)) {
                var a = r[o], h = i.findSlotIndex(o);
                for(var l in a)if(a.hasOwnProperty(l)) {
                    var c = a[l];
                    if("color" == l) {
                        var u = new spine.ColorTimeline(c.length);
                        u.slotIndex = h;
                        for(var d = 0, p = 0, f = c.length; p < f; p++) {
                            var g = c[p], m = g.color, y = this.toColor(m, 0), v = this.toColor(m, 1),
                                x = this.toColor(m, 2), _ = this.toColor(m, 3);
                            u.setFrame(d, g.time, y, v, x, _), this.readCurve(u, d, g), d++
                        }
                        n[n.length] = u, s = Math.max(s, u.frames[5 * u.getFrameCount() - 5])
                    } else {
                        if("attachment" != l)throw"Invalid timeline type for a slot: " + l + " (" + o + ")";
                        var u = new spine.AttachmentTimeline(c.length);
                        u.slotIndex = h;
                        for(var d = 0, p = 0, f = c.length; p < f; p++) {
                            var g = c[p];
                            u.setFrame(d++, g.time, g.name)
                        }
                        n[n.length] = u, s = Math.max(s, u.frames[u.getFrameCount() - 1])
                    }
                }
            }
            var b = e.bones;
            for(var w in b)if(b.hasOwnProperty(w)) {
                var T = i.findBoneIndex(w);
                if(T == -1)throw"Bone not found: " + w;
                var P = b[w];
                for(var l in P)if(P.hasOwnProperty(l)) {
                    var c = P[l];
                    if("rotate" == l) {
                        var u = new spine.RotateTimeline(c.length);
                        u.boneIndex = T;
                        for(var d = 0, p = 0, f = c.length; p < f; p++) {
                            var g = c[p];
                            u.setFrame(d, g.time, g.angle), this.readCurve(u, d, g), d++
                        }
                        n[n.length] = u, s = Math.max(s, u.frames[2 * u.getFrameCount() - 2])
                    } else {
                        if("translate" != l && "scale" != l)throw"Invalid timeline type for a bone: " + l + " (" + w + ")";
                        var u, C = 1;
                        "scale" == l ? u = new spine.ScaleTimeline(c.length) : (u = new spine.TranslateTimeline(c.length), C = this.scale), u.boneIndex = T;
                        for(var d = 0, p = 0, f = c.length; p < f; p++) {
                            var g = c[p], S = (g.x || 0) * C, I = (g.y || 0) * C;
                            u.setFrame(d, g.time, S, I), this.readCurve(u, d, g), d++
                        }
                        n[n.length] = u, s = Math.max(s, u.frames[3 * u.getFrameCount() - 3])
                    }
                }
            }
            var O = e.ik;
            for(var A in O)if(O.hasOwnProperty(A)) {
                var M = i.findIkConstraint(A), c = O[A], u = new spine.IkConstraintTimeline(c.length);
                u.ikConstraintIndex = i.ikConstraints.indexOf(M);
                for(var d = 0, p = 0, f = c.length; p < f; p++) {
                    var g = c[p], k = g.hasOwnProperty("mix") ? g.mix : 1,
                        E = !g.hasOwnProperty("bendPositive") || g.bendPositive ? 1 : -1;
                    u.setFrame(d, g.time, k, E), this.readCurve(u, d, g), d++
                }
                n[n.length] = u, s = Math.max(s, u.frames[3 * u.getFrameCount() - 3])
            }
            var R = e.ffd;
            for(var D in R) {
                var L = i.findSkin(D), a = R[D];
                for(o in a) {
                    var h = i.findSlotIndex(o), B = a[o];
                    for(var F in B) {
                        var c = B[F], u = new spine.FfdTimeline(c.length), U = L.getAttachment(h, F);
                        if(!U)throw"FFD attachment not found: " + F;
                        u.slotIndex = h, u.attachment = U;
                        var X, j = U.type == spine.AttachmentType.mesh;
                        X = j ? U.vertices.length : U.weights.length / 3 * 2;
                        for(var d = 0, p = 0, f = c.length; p < f; p++) {
                            var G, g = c[p];
                            if(g.vertices) {
                                var N = g.vertices, G = new spine.Float32Array(X);
                                G.length = X;
                                var H = g.offset || 0, W = N.length;
                                if(1 == this.scale)for(var Y = 0; Y < W; Y++)G[Y + H] = N[Y]; else for(var Y = 0; Y < W; Y++)G[Y + H] = N[Y] * this.scale;
                                if(j)for(var V = U.vertices, Y = 0, W = G.length; Y < W; Y++)G[Y] += V[Y]
                            } else j ? G = U.vertices : (G = new spine.Float32Array(X), G.length = X);
                            u.setFrame(d, g.time, G), this.readCurve(u, d, g), d++
                        }
                        n[n.length] = u, s = Math.max(s, u.frames[u.getFrameCount() - 1])
                    }
                }
            }
            var z = e.drawOrder;
            if(z || (z = e.draworder), z) {
                for(var u = new spine.DrawOrderTimeline(z.length), q = i.slots.length, d = 0, p = 0,
                        f = z.length; p < f; p++) {
                    var J = z[p], K = null;
                    if(J.offsets) {
                        K = new spine.Uint32Array(q), K.length = q;
                        for(var Y = q - 1; Y >= 0; Y--)K[Y] = 4294967295;
                        var Q = J.offsets, Z = new spine.Uint32Array(q - Q.length);
                        Z.length = q - Q.length;
                        for(var $ = 0, tt = 0, Y = 0, W = Q.length; Y < W; Y++) {
                            var et = Q[Y], h = i.findSlotIndex(et.slot);
                            if(h == -1)throw"Slot not found: " + et.slot;
                            for(; $ != h;)Z[tt++] = $++;
                            K[$ + et.offset] = $++
                        }
                        for(; $ < q;)Z[tt++] = $++;
                        for(var Y = q - 1; Y >= 0; Y--)4294967295 == K[Y] && (K[Y] = Z[--tt])
                    }
                    u.setFrame(d++, J.time, K)
                }
                n[n.length] = u, s = Math.max(s, u.frames[u.getFrameCount() - 1])
            }
            var it = e.events;
            if(it) {
                for(var u = new spine.EventTimeline(it.length), d = 0, p = 0, f = it.length; p < f; p++) {
                    var nt = it[p], st = i.findEvent(nt.name);
                    if(!st)throw"Event not found: " + nt.name;
                    var rt = new spine.Event(nt.time, st);
                    rt.intValue = nt.hasOwnProperty("int") ? nt["int"] : st.intValue, rt.floatValue = nt.hasOwnProperty("float") ? nt["float"] : st.floatValue, rt.stringValue = nt.hasOwnProperty("string") ? nt.string : st.stringValue, u.setFrame(d++, rt)
                }
                n[n.length] = u, s = Math.max(s, u.frames[u.getFrameCount() - 1])
            }
            i.animations[i.animations.length] = new spine.Animation(t, n, s)
        }, readCurve: function(t, e, i) {
            var n = i.curve;
            n ? "stepped" == n ? t.curves.setStepped(e) : n instanceof Array && t.curves.setCurve(e, n[0], n[1], n[2], n[3]) : t.curves.setLinear(e)
        }, toColor: function(t, e) {
            if(8 != t.length)throw"Color hexidecimal length must be 8, recieved: " + t;
            return parseInt(t.substring(2 * e, 2 * e + 2), 16) / 255
        }, getFloatArray: function(t, e, i) {
            var n = t[e], s = new spine.Float32Array(n.length), r = 0, o = n.length;
            if(1 == i)for(; r < o; r++)s[r] = n[r]; else for(; r < o; r++)s[r] = n[r] * i;
            return s
        }, getUint32Array: function(t, e) {
            for(var i = t[e], n = new spine.Uint32Array(i.length), s = 0, r = i.length; s < r; s++)n[s] = 0 | i[s];
            return n
        }, getUint16Array: function(t, e) {
            for(var i = t[e], n = new spine.Uint16Array(i.length), s = 0, r = i.length; s < r; s++)n[s] = 0 | i[s];
            return n
        }
    }, spine.Atlas = function(t, e) {
        this.textureLoader = e, this.pages = [], this.regions = [];
        var i = [];
        i.length = 4;
        var n = new spine.AtlasPage;
        n.name = t.meta.image, n.uWrap = spine.Atlas.TextureWrap.clampToEdge, n.vWrap = spine.Atlas.TextureWrap.clampToEdge, n.uWrap = n.vWrap = spine.Atlas.TextureWrap.repeat, e.load(n, n.name, this), this.pages[this.pages.length] = n;
        var s, r, o, a, h, l;
        for(var c in t.frames)s = t.frames[c], r = new spine.AtlasRegion, r.name = c.replace(".png", ""), r.page = n, r.rotate = !1, o = s[0], a = s[1], h = s[2], l = s[3], r.u = o / n.width, r.v = a / n.height, r.rotate ? (r.u2 = (o + l) / n.width, r.v2 = (a + h) / n.height) : (r.u2 = (o + h) / n.width, r.v2 = (a + l) / n.height), r.x = o, r.y = a, r.width = Math.abs(h), r.height = Math.abs(l), r.originalWidth = s[4], r.originalHeight = s[5], r.offsetX = s[6], r.offsetY = s[7], r.index = -1, this.regions[this.regions.length] = r
    }, spine.Atlas.prototype = {
        findRegion: function(t) {
            for(var e = this.regions, i = 0, n = e.length; i < n; i++)if(e[i].name == t)return e[i];
            return null
        }, dispose: function() {
            for(var t = this.pages, e = 0, i = t.length; e < i; e++)this.textureLoader.unload(t[e].rendererObject)
        }, updateUVs: function(t) {
            for(var e = this.regions, i = 0, n = e.length; i < n; i++) {
                var s = e[i];
                s.page == t && (s.u = s.x / t.width, s.v = s.y / t.height, s.rotate ? (s.u2 = (s.x + s.height) / t.width, s.v2 = (s.y + s.width) / t.height) : (s.u2 = (s.x + s.width) / t.width, s.v2 = (s.y + s.height) / t.height))
            }
        }
    }, spine.Atlas.Format = {
        alpha: 0,
        intensity: 1,
        luminanceAlpha: 2,
        rgb565: 3,
        rgba4444: 4,
        rgb888: 5,
        rgba8888: 6
    }, spine.Atlas.TextureFilter = {
        nearest: 0,
        linear: 1,
        mipMap: 2,
        mipMapNearestNearest: 3,
        mipMapLinearNearest: 4,
        mipMapNearestLinear: 5,
        mipMapLinearLinear: 6
    }, spine.Atlas.TextureWrap = {mirroredRepeat: 0, clampToEdge: 1, repeat: 2}, spine.AtlasPage = function() {
    }, spine.AtlasPage.prototype = {
        name: null,
        format: null,
        minFilter: null,
        magFilter: null,
        uWrap: null,
        vWrap: null,
        rendererObject: null,
        width: 0,
        height: 0
    }, spine.AtlasRegion = function() {
    }, spine.AtlasRegion.prototype = {
        page: null,
        name: null,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        u: 0,
        v: 0,
        u2: 0,
        v2: 0,
        offsetX: 0,
        offsetY: 0,
        originalWidth: 0,
        originalHeight: 0,
        index: 0,
        rotate: !1,
        splits: null,
        pads: null
    }, spine.AtlasReader = function(t) {
        this.lines = t.split(/\r\n|\r|\n/)
    }, spine.AtlasReader.prototype = {
        index: 0, trim: function(t) {
            return t.replace(/^\s+|\s+$/g, "")
        }, readLine: function() {
            return this.index >= this.lines.length ? null : this.lines[this.index++]
        }, readValue: function() {
            var t = this.readLine(), e = t.indexOf(":");
            if(e == -1)throw"Invalid line: " + t;
            return this.trim(t.substring(e + 1))
        }, readTuple: function(t) {
            var e = this.readLine(), i = e.indexOf(":");
            if(i == -1)throw"Invalid line: " + e;
            for(var n = 0, s = i + 1; n < 3; n++) {
                var r = e.indexOf(",", s);
                if(r == -1)break;
                t[n] = this.trim(e.substr(s, r - s)), s = r + 1
            }
            return t[n] = this.trim(e.substring(s)), n + 1
        }
    }, spine.AtlasAttachmentLoader = function(t) {
        this.atlas = t
    }, spine.AtlasAttachmentLoader.prototype = {
        newRegionAttachment: function(t, e, i) {
            var n = this.atlas.findRegion(i);
            if(!n)throw"Region not found in atlas: " + i + " (region attachment: " + e + ")";
            var s = new spine.RegionAttachment(e);
            return s.rendererObject = n, s.setUVs(n.u, n.v, n.u2, n.v2, n.rotate), s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
        }, newMeshAttachment: function(t, e, i) {
            var n = this.atlas.findRegion(i);
            if(!n)throw"Region not found in atlas: " + i + " (mesh attachment: " + e + ")";
            var s = new spine.MeshAttachment(e);
            return s.rendererObject = n, s.regionU = n.u, s.regionV = n.v, s.regionU2 = n.u2, s.regionV2 = n.v2, s.regionRotate = n.rotate, s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
        }, newWeightedMeshAttachment: function(t, e, i) {
            var n = this.atlas.findRegion(i);
            if(!n)throw"Region not found in atlas: " + i + " (weighted mesh attachment: " + e + ")";
            var s = new spine.WeightedMeshAttachment(e);
            return s.rendererObject = n, s.regionU = n.u, s.regionV = n.v, s.regionU2 = n.u2, s.regionV2 = n.v2, s.regionRotate = n.rotate, s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
        }, newBoundingBoxAttachment: function(t, e) {
            return new spine.BoundingBoxAttachment(e)
        }
    }, spine.SkeletonBounds = function() {
        this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
    }, spine.SkeletonBounds.prototype = {
        minX: 0, minY: 0, maxX: 0, maxY: 0, update: function(t, e) {
            var i = t.slots, n = i.length, s = t.x, r = t.y, o = this.boundingBoxes, a = this.polygonPool,
                h = this.polygons;
            o.length = 0;
            for(var l = 0, c = h.length; l < c; l++)a[a.length] = h[l];
            h.length = 0;
            for(var l = 0; l < n; l++) {
                var u = i[l], d = u.attachment;
                if(d.type == spine.AttachmentType.boundingbox) {
                    o[o.length] = d;
                    var p, f = a.length;
                    f > 0 ? (p = a[f - 1], a.splice(f - 1, 1)) : p = new spine.Float32Array, h[h.length] = p, p.length = d.vertices.length, d.computeWorldVertices(s, r, u.bone, p)
                }
            }
            e && this.aabbCompute()
        }, aabbCompute: function() {
            for(var t = this.polygons, e = Number.MAX_VALUE, i = Number.MAX_VALUE, n = -Number.MAX_VALUE,
                    s = -Number.MAX_VALUE, r = 0, o = t.length; r < o; r++)for(var a = t[r], h = 0,
                                                                                   l = a.length; h < l; h += 2) {
                var c = a[h], u = a[h + 1];
                e = Math.min(e, c), i = Math.min(i, u), n = Math.max(n, c), s = Math.max(s, u)
            }
            this.minX = e, this.minY = i, this.maxX = n, this.maxY = s
        }, aabbContainsPoint: function(t, e) {
            return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
        }, aabbIntersectsSegment: function(t, e, i, n) {
            var s = this.minX, r = this.minY, o = this.maxX, a = this.maxY;
            if(t <= s && i <= s || e <= r && n <= r || t >= o && i >= o || e >= a && n >= a)return !1;
            var h = (n - e) / (i - t), l = h * (s - t) + e;
            if(l > r && l < a)return !0;
            if(l = h * (o - t) + e, l > r && l < a)return !0;
            var c = (r - e) / h + t;
            return c > s && c < o || (c = (a - e) / h + t, c > s && c < o)
        }, aabbIntersectsSkeleton: function(t) {
            return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
        }, containsPoint: function(t, e) {
            for(var i = this.polygons, n = 0,
                    s = i.length; n < s; n++)if(this.polygonContainsPoint(i[n], t, e))return this.boundingBoxes[n];
            return null
        }, intersectsSegment: function(t, e, i, n) {
            for(var s = this.polygons, r = 0,
                    o = s.length; r < o; r++)if(s[r].intersectsSegment(t, e, i, n))return this.boundingBoxes[r];
            return null
        }, polygonContainsPoint: function(t, e, i) {
            for(var n = t.length, s = n - 2, r = !1, o = 0; o < n; o += 2) {
                var a = t[o + 1], h = t[s + 1];
                if(a < i && h >= i || h < i && a >= i) {
                    var l = t[o];
                    l + (i - a) / (h - a) * (t[s] - l) < e && (r = !r)
                }
                s = o
            }
            return r
        }, polygonIntersectsSegment: function(t, e, i, n, s) {
            for(var r = t.length, o = e - n, a = i - s, h = e * s - i * n, l = t[r - 2], c = t[r - 1],
                    u = 0; u < r; u += 2) {
                var d = t[u], p = t[u + 1], f = l * p - c * d, g = l - d, m = c - p, y = o * m - a * g,
                    v = (h * g - o * f) / y;
                if((v >= l && v <= d || v >= d && v <= l) && (v >= e && v <= n || v >= n && v <= e)) {
                    var x = (h * m - a * f) / y;
                    if((x >= c && x <= p || x >= p && x <= c) && (x >= i && x <= s || x >= s && x <= i))return !0
                }
                l = d, c = p
            }
            return !1
        }, getPolygon: function(t) {
            var e = this.boundingBoxes.indexOf(t);
            return e == -1 ? null : this.polygons[e]
        }, getWidth: function() {
            return this.maxX - this.minX
        }, getHeight: function() {
            return this.maxY - this.minY
        }
    };
    var __extends = this && this.__extends || function(t, e) {
            function i() {
                this.constructor = t
            }

            for(var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);
            t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
        }, Fabrique;
    !function(t) {
        var e;
        !function(e) {
            var i = function(e) {
                function i(t, i) {
                    e.call(this, t, i), this.addSpineCache(), this.addSpineFactory(), this.addSpineLoader()
                }

                return __extends(i, e), i.prototype.addSpineLoader = function() {
                    Phaser.Loader.prototype.spine = function(t, e, i, n) {
                        void 0 === t && console.warn("Phaser.SpineLoader: keys is missing."), void 0 === i && console.warn("Phaser.SpineLoader: atlas key is missing."), void 0 === e && console.warn("Phaser.SpineLoader: textureURL is missing.");
                        var s = {
                            keys: t,
                            atlas: i,
                            basePath: "" === e.substring(0, e.lastIndexOf("/")) ? "." : e.substring(0, e.lastIndexOf("/")),
                            variants: void 0
                        };
                        void 0 === n ? n = [""] : s.variants = n, this.image(e.substring(e.lastIndexOf("/") + 1), e), this.game.cache.addSpine(t, s)
                    }
                }, i.prototype.addSpineFactory = function() {
                    Phaser.GameObjectFactory.prototype.spine = function(e, i, n, s, r) {
                        void 0 === r && (r = this.world);
                        var o = new t.Spine(this.game, n, s);
                        return o.setToSetupPose(), o.position.x = e, o.position.y = i, r.add(o)
                    }
                }, i.prototype.addSpineCache = function() {
                    Phaser.Cache.prototype.spine = {}, Phaser.Cache.prototype.addSpine = function(t, e) {
                        var i = this;
                        t.forEach(function(t) {
                            i.spine[t] = e
                        })
                    }, Phaser.Cache.prototype.getSpine = function(t) {
                        return this.spine.hasOwnProperty(t) || console.warn('Phaser.Cache.getSpine: Key "' + t + '" not found in Cache.'), this.spine[t]
                    }
                }, i.RESOLUTION_REGEXP = /@(.+)x/, i
            }(Phaser.Plugin);
            e.Spine = i
        }(e = t.Plugins || (t.Plugins = {}))
    }(Fabrique || (Fabrique = {})), PIXI.Strip.prototype.postUpdate = function() {
    }, spine.Bone.yDown = !0;
    var Fabrique;
    !function(t) {
        var e = function(e) {
            function i(i, n, s) {
                e.call(this, i), this.imageScale = 1;
                var r = this.game.cache.getSpine(n);
                void 0 !== s && r.variants.indexOf(s) !== -1 ? this.imageScale = this.getScaleFromVariant(s) : r.variants && r.variants.length >= 1 && (this.imageScale = this.getScaleFromVariant(r.variants[0]));
                var o = new t.SpineTextureLoader(i), a = new spine.Atlas(embedded[r.atlas], o),
                    h = new spine.AtlasAttachmentLoader(a), l = new spine.SkeletonJson(h);
                if(this.skeletonData = l.readSkeletonData(embedded[n]), !this.skeletonData)throw new Error("Spine data must be preloaded using Loader.spine");
                this.skeleton = new spine.Skeleton(this.skeletonData), this.skeleton.updateWorldTransform(), this.stateData = new spine.AnimationStateData(this.skeletonData), this.state = new spine.AnimationState(this.stateData), this.slotContainers = [];
                for(var c = 0, u = this.skeleton.slots.length; c < u; c++) {
                    var d = this.skeleton.slots[c], p = d.attachment, f = new Phaser.Group(i);
                    if(this.slotContainers.push(f), this.add(f), p instanceof spine.RegionAttachment) {
                        var g = p.rendererObject.name, m = this.createSprite(d, p);
                        d.currentSprite = m, d.currentSpriteName = g, f.add(m)
                    } else {
                        if(!(p instanceof spine.WeightedMeshAttachment))continue;
                        var y = this.createMesh(d, p);
                        d.currentMesh = y, d.currentMeshName = p.name, f.add(y)
                    }
                }
                this.autoUpdate = !0
            }

            return __extends(i, e), Object.defineProperty(i.prototype, "autoUpdate", {
                get: function() {
                    return this.updateTransform === t.Spine.prototype.autoUpdateTransform
                }, set: function(e) {
                    this.updateTransform = e ? t.Spine.prototype.autoUpdateTransform : PIXI.DisplayObjectContainer.prototype.updateTransform
                }, enumerable: !0, configurable: !0
            }), i.prototype.getScaleFromVariant = function(e) {
                var i = t.Plugins.Spine.RESOLUTION_REGEXP.exec(e);
                return i ? parseFloat(i[1]) : 1
            }, i.prototype.update = function(t) {
                if(void 0 !== t) {
                    this.state.update(t), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
                    for(var e = this.skeleton.drawOrder, i = this.skeleton.slots, n = 0,
                            s = e.length; n < s; n++)void 0 !== e[n].currentSprite && (this.children[n] = e[n].currentSprite.parent);
                    for(var n = 0, s = i.length; n < s; n++) {
                        var r = i[n], o = r.attachment, a = this.slotContainers[n];
                        if(o) {
                            var h = o.type;
                            if(h === spine.AttachmentType.region) {
                                if(o.rendererObject && (!r.currentSpriteName || r.currentSpriteName !== o.name)) {
                                    var l = o.rendererObject.name;
                                    if(void 0 !== r.currentSprite && (r.currentSprite.visible = !1), r.sprites = r.sprites || {}, void 0 !== r.sprites[l]) r.sprites[l].visible = !0; else {
                                        var c = this.createSprite(r, o);
                                        a.add(c)
                                    }
                                    r.currentSprite = r.sprites[l], r.currentSpriteName = l
                                }
                                var u = r.bone;
                                a.position.x = o.x * u.a + o.y * u.b + u.worldX, a.position.y = o.x * u.c + o.y * u.d + u.worldY, a.scale.x = u.getWorldScaleX(), a.scale.y = u.getWorldScaleY(), a.rotation = (u.getWorldRotationX() - o.rotation) * Math.PI / 180, (u.getWorldScaleY() < 0 || u.getWorldScaleX() < 0) && (a.scale.y = -a.scale.y, a.scale.x = -a.scale.x, a.rotation = -a.rotation), r.currentSprite.blendMode = r.blendMode, r.currentSprite.tint = PIXI.rgb2hex([r.r, r.g, r.b])
                            } else {
                                if(h !== spine.AttachmentType.weightedmesh && h !== spine.AttachmentType.weightedlinkedmesh) {
                                    a.visible = !1;
                                    continue
                                }
                                if(!r.currentMeshName || r.currentMeshName !== o.name) {
                                    var d = o.name;
                                    if(void 0 !== r.currentMesh && (r.currentMesh.visible = !1), r.meshes = r.meshes || {}, void 0 !== r.meshes[d]) r.meshes[d].visible = !0; else {
                                        var p = this.createMesh(r, o);
                                        a.add(p)
                                    }
                                    r.currentMesh = r.meshes[d], r.currentMeshName = d
                                }
                                o.computeWorldVertices(r.bone.skeleton.x, r.bone.skeleton.y, r, r.currentMesh.vertices)
                            }
                            a.visible = !0, a.alpha = r.a
                        } else a.visible = !1
                    }
                }
            }, i.prototype.destroy = function(t, i) {
                e.prototype.destroy.call(this, !0, i)
            }, i.prototype.autoUpdateTransform = function() {
                this.lastTime = this.lastTime || Date.now();
                var t = .001 * (Date.now() - this.lastTime);
                this.lastTime = Date.now(), this.update(t), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
            }, i.prototype.createSprite = function(t, e) {
                var i = e.rendererObject, n = i.page.rendererObject,
                    s = new PIXI.Rectangle(i.x, i.y, i.rotate ? i.height : i.width, i.rotate ? i.width : i.height),
                    r = new PIXI.Texture(n, s), o = new Phaser.Sprite(this.game, 0, 0, r),
                    a = i.rotate ? .5 * Math.PI : 0;
                if(o.scale.x = i.width / i.originalWidth * e.scaleX / this.imageScale, o.scale.y = i.height / i.originalHeight * e.scaleY / this.imageScale, o.rotation = a, o.anchor.x = (.5 * i.originalWidth - i.offsetX) / i.width, o.anchor.y = 1 - (.5 * i.originalHeight - i.offsetY) / i.height, o.alpha = e.a, i.rotate) {
                    var h = o.scale.x;
                    o.scale.x = o.scale.y, o.scale.y = h
                }
                return t.sprites = t.sprites || {}, t.sprites[i.name] = o, o
            }, i.prototype.createMesh = function(t, e) {
                var i = e.rendererObject, n = i.page.rendererObject, s = new PIXI.Texture(n), r = new PIXI.Strip(s);
                return r.drawMode = 1, r.canvasPadding = 1.5, r.vertices = new spine.Float32Array(e.uvs.length), r.uvs = e.uvs, r.indices = e.triangles, r.alpha = e.a, t.meshes = t.meshes || {}, t.meshes[e.name] = r, r
            }, i.prototype.setMixByName = function(t, e, i) {
                this.stateData.setMixByName(t, e, i)
            }, i.prototype.setAnimationByName = function(t, e, i) {
                void 0 === i && (i = !1);
                var n = this.state.data.skeletonData.findAnimation(e);
                return n ? this.state.setAnimation(t, n, i) : (console.warn("Animation not found: " + e), null)
            }, i.prototype.addAnimationByName = function(t, e, i, n) {
                void 0 === i && (i = !1), void 0 === n && (n = 0);
                var s = this.state.data.skeletonData.findAnimation(e);
                return s ? this.state.addAnimation(t, s, i, n) : (console.warn("Animation not found: " + e), null)
            }, i.prototype.setSkinByName = function(t) {
                var e = this.skeleton.data.findSkin(t);
                return e ? void this.skeleton.setSkin(e) : void console.warn("Skin not found: " + t)
            }, i.prototype.setSkin = function(t) {
                this.skeleton.setSkin(t)
            }, i.prototype.setToSetupPose = function() {
                this.skeleton.setToSetupPose()
            }, i.prototype.createCombinedSkin = function(t) {
                for(var e = [], i = 1; i < arguments.length; i++)e[i - 1] = arguments[i];
                if(0 === e.length)return void console.warn("Unable to combine skins when no skins are passed...");
                for(var n = new spine.Skin(t), s = 0; s < e.length; s++) {
                    var r = e[s], o = this.skeleton.data.findSkin(r);
                    if(!o)return void console.warn("Skin not found: " + r);
                    for(var a in o.attachments) {
                        var h = a.split(":"), l = h[0], c = h[1], u = o.attachments[a];
                        if(void 0 === l || void 0 === c)return void console.warn("something went wrong with reading the attachments index and/or name");
                        void 0 === n.getAttachment(l, c) ? n.addAttachment(l, c, u) : console.warn("Found double attachment for: " + r + ". Skipping")
                    }
                }
                return this.skeleton.data.skins.push(n), n
            }, i
        }(Phaser.Group);
        t.Spine = e
    }(Fabrique || (Fabrique = {}));
    var Fabrique;
    !function(t) {
        var e = function() {
            function t(t) {
                this.load = function(t, e, i) {
                    var n = this.game.make.image(0, 0, e);
                    t.rendererObject = n.texture.baseTexture
                }, this.unload = function(t) {
                    t.destroy()
                }, this.game = t
            }

            return t
        }();
        t.SpineTextureLoader = e
    }(Fabrique || (Fabrique = {}));
    var Localization = function() {
    };
    Localization.prototype.init = function() {
        this._strings = [], this._language = null, navigator && navigator.userAgent && (this._language = navigator.userAgent.match(/android.*\W(\w\w)-(\w\w)\W/i)) && (this._language = this._language[1]), !this._language && navigator && (navigator.languages ? this._language = navigator.languages[0] : navigator.language ? this._language = navigator.language : navigator.browserLanguage ? this._language = navigator.browserLanguage : navigator.systemLanguage ? this._language = navigator.systemLanguage : navigator.userLanguage && (this._language = navigator.userLanguage), this._language && (console.log("Truncating language: " + this._language), this._language = this._language.substr(0, 2))), this._language || (this._language = "en"), console.log("Language: " + this._language)
    }, Localization.prototype.registerString = function(t, e) {
        console.log("localization: registering string:", t), this._strings[t] = e
    }, Localization.prototype.registerStrings = function(t) {
        for(var e in t)this.registerString(e, t[e])
    }, Localization.prototype.getLanguage = function() {
        return this._language
    }, Localization.prototype.get = function(t, e) {
        var i = t;
        if(this._strings[t] && this._strings[t][this._language] && (i = this._strings[t][this._language]), e)for(var n in e)i = i.replace(n, e[n]);
        return i
    }, Localization.prototype.fitText = function(t, e, i) {
        if(t.defaultFontSize || (t.defaultFontSize = t.fontSize.replace(/\D/g, "")), t.fontSize = t.defaultFontSize + "pt", t.wordWrap && (e = t.wordWrapWidth), e > 0 && i > 0)for(var n = t.defaultFontSize; (t.width > e || t.height > i) && n > 4;)n -= 1, t.fontSize = n + "pt"
    };
    var localization = new Localization;
    localization.init();
    var Utils = function() {
    };
    Utils.prototype.getAdParameters = function(t) {
        var e = {};
        if(ad_dynamic_parameters && ad_dynamic_parameters.split("&").forEach(function(t) {
                e[t.split("=")[0]] = decodeURIComponent(t.split("=")[1])
            }), t) {
            var i = null;
            for(i in e)if("undefined" != typeof t[i])switch(t[i].type.toLowerCase()) {
                case"int":
                case"integer":
                    e[i] = parseInt(e[i]);
                    break;
                case"int[]":
                case"integer[]":
                    for(var n = e[i].split(","), s = 0; s < n.length; s++)n[s] = +n[s];
                    e[i] = n;
                    break;
                case"float":
                    e[i] = parseFloat(e[i]);
                    break;
                case"bool":
                case"boolean":
                    "true" == e[i].toLowerCase() ? e[i] = !0 : e[i] = !1
            }
            for(i in t)"undefined" == typeof e[i] && (e[i] = t[i]["default"])
        }
        return Utils.params = e, Utils.specs = t, e
    }, Utils.prototype.applyAdParameters = function(t) {
        var e = {};
        if(!ad_dynamic_parameters)return void console.log("[UTILS]: ad_dynamic_parameters was not found.");
        ad_dynamic_parameters.split("&").forEach(function(t) {
            e[t.split("=")[0]] = decodeURIComponent(t.split("=")[1])
        });
        for(var i in e) {
            var n = e[i], s = t;
            if(s = i == i.toUpperCase() ? window : t, s.hasOwnProperty(i)) {
                var r = s[i];
                r.constructor === Array ? (s[i] = [], n.split(",").forEach(function(t) {
                    s[i].push(utils.convertType(0, t))
                })) : s[i] = utils.convertType(r, n)
            } else console.log("[UTILS]: unable to find property:", i)
        }
    }, Utils.prototype.convertType = function(t, e) {
        return "boolean" == typeof t ? "true" == e || "1" == e : "number" == typeof t ? parseFloat(e) : e
    }, Utils.prototype.checkOverlap = function(t, e) {
        var i = t.getBounds(), n = e.getBounds();
        return Phaser.Rectangle.intersects(i, n)
    }, Utils.prototype.checkPointInside = function(t, e) {
        var i = new PIXI.Rectangle(t.x, t.y, 1, 1), n = e.getBounds();
        return Phaser.Rectangle.intersects(i, n)
    }, Utils.prototype.lineLength = function(t, e, i, n) {
        var s = Math.abs(i - t), r = Math.abs(n - e);
        return Math.sqrt(s * s + r * r)
    }, Utils.prototype.highlightRegion = function(t, e, i, n, s) {
        s = s || .4;
        var r = null;
        imageLoader.hasFrameName("mask.png") ? r = !1 : imageLoader.hasFrameName("mask_small.png") && (r = !0);
        var o = imageLoader.sprite(e, i, r ? "mask_small.png" : "mask.png");
        o.alpha = s, o.anchor.set(.5, .5);
        var a = n / 20;
        return r && (a *= 2), o.scale.setTo(a, a), o
    }, Utils.prototype.random = function(t, e) {
        return null === e && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1))
    }, Utils.prototype.shuffle = function(t) {
        for(var e, i, n = 0, s = [],
                r = t.length - 1; r >= 0; r--)i = t[r], e = this.random(n++), s[n - 1] = s[e], s[e] = i;
        return s
    }, Utils.prototype.arrayDistinct = function(t, e) {
        var i = [];
        return e.forEach(function(e) {
            t.indexOf(e) == -1 && i.push(e)
        }), i
    }, Utils.prototype.forceOrientation = function(t, e) {
        if(!t.device.desktop) {
            console.log("forcing orientation: " + e), t.scale.forceOrientation("landscape" == e, "landscape" != e);
            var i = this;
            t.scale.enterIncorrectOrientation.add(function() {
                i.handleIncorrectOrientation(t)
            }), t.scale.leaveIncorrectOrientation.add(function() {
                i.handleCorrectOrientation(t)
            })
        }
    }, Utils.prototype.handleIncorrectOrientation = function(t) {
        console.log("entered incorrect orientation"), document.getElementById("orientation").style.display = "block"
    }, Utils.prototype.handleCorrectOrientation = function() {
        console.log("resumed correct orientation"), document.getElementById("orientation").style.display = "none"
    }, Utils.prototype.parseXML = function(t) {
        if("undefined" != typeof window.DOMParser)return (new window.DOMParser).parseFromString(t, "text/xml");
        if("undefined" != typeof window.ActiveXObject && new window.ActiveXObject("Microsoft.XMLDOM")) {
            var e = new window.ActiveXObject("Microsoft.XMLDOM");
            return e.async = "false", e.loadXML(t), e
        }
        return null
    }, Utils.prototype.applyAdParameters = function(t) {
        var e = utils.getAdParameters();
        for(var i in e) {
            var n = e[i], s = t;
            s = i == i.toUpperCase() ? window : t, s.hasOwnProperty(i) ? "boolean" == typeof s[i] ? s[i] = "true" == n || "1" == n : s[i] = n : console.log("Ad params: unable to find property:", i)
        }
    }, Object.prototype.hasOwnProperty = function(t) {
        return "undefined" != typeof this[t]
    }, String.prototype.lpad = function(t, e) {
        for(var i = this; i.length < e;)i = t + i;
        return i
    }, String.prototype.isUpperCase = function(t) {
        return t == t.toUpperCase()
    }, Utils.prototype.lerp = function(t, e, i) {
        return t + i * (e - t)
    }, Utils.prototype.hermite = function(t, e, i) {
        return this.lerp(t, e, i * i * (3 - 2 * i))
    }, Utils.prototype.sinerp = function(t, e, i) {
        return this.lerp(t, e, Math.sin(i * Math.PI * .5))
    }, Number.prototype.mod = function(t) {
        return (this % t + t) % t
    };
    var utils = new Utils, embedded = {}, ImageLoader = function() {
    };
    ImageLoader.prototype.registerGame = function(t) {
        this._game = t, this._game.load.crossOrigin = "Anonymous", console.log("load.crossOrigin: ", this._game.load.crossOrigin)
    }, ImageLoader.prototype.convertPath = function(t) {
        if("chartboost" === ad_exchange && t.indexOf("images/crossinstall_" + ad_name) === -1) {
            var e = t.split("/");
            t = "images/crossinstall_" + ad_name + "_" + e[e.length - 1]
        }
        return t
    }, ImageLoader.prototype.registerBackgroundImage = function(t, e, i) {
        var n = {url: ImageLoader.prototype.convertPath(t), width: e, height: i, landscape: e > i};
        this._backgrounds.push(n)
    }, ImageLoader.prototype.preloadBackground = function() {
        var t = !1;
        this._game.width > this._game.height && (t = !0), this._backgrounds = Phaser.ArrayUtils.shuffle(this._backgrounds);
        for(var e = 0; e < this._backgrounds.length; e++)if(t == this._backgrounds[e].landscape)return console.log("Preloading background: " + this._backgrounds[e].url + "    landscape? " + this._backgrounds[e].landscape), void this.loadImage("background", this._backgrounds[e].url);
        console.log("No matching background found for preloading")
    }, ImageLoader.prototype.displayBackground = function() {
        return this._game.add.sprite(0, 0, "background")
    }, ImageLoader.prototype.loadImage = function(t, e) {
        return this._game.load.image(t, ImageLoader.prototype.convertPath(e))
    }, ImageLoader.prototype.sprite = function(t, e, i) {
        for(var n = 0; n < this._atlases.length; n++) {
            var s = this._game.cache.getFrameByName(this._atlases[n], i);
            if(void 0 !== s && null != s)return this._game.add.sprite(t, e, this._atlases[n], i)
        }
        return console.log("image_loader: warning: sprite not found in atlases; assuming it was loaded individually: " + i), this._game.add.sprite(t, e, i)
    }, ImageLoader.prototype.spriteMake = function(t, e, i) {
        for(var n = 0; n < this._atlases.length; n++) {
            var s = this._game.cache.getFrameByName(this._atlases[n], i);
            if(void 0 !== s && null != s)return this._game.make.sprite(t, e, this._atlases[n], i)
        }
        return this._game.make.sprite(t, e, i)
    }, ImageLoader.prototype.button = function(t, e, i, n, s) {
        console.log("CBBB"), console.log(n);
        for(var r = 0; r < this._atlases.length; r++) {
            var o = this._game.cache.getFrameByName(this._atlases[r], i);
            if(void 0 !== o && null != o)return console.log("key"), console.log(this._atlases[r]), this._game.add.button(t, e, this._atlases[r], i, n, s)
        }
        return console.log("image_loader: warning: button not found in atlases; assuming it was loaded individually: " + i), this._game.add.button(t, e, "", i, n, s)
    }, ImageLoader.prototype.hasFrameName = function(t) {
        for(var e = 0; e < this._atlases.length; e++) {
            var i = this._game.cache.getFrameByName(this._atlases[e], t);
            if(void 0 !== i && null != i)return !0
        }
        return !1
    }, ImageLoader.prototype.loadSpritesheet = function(t, e, i, n, s) {
        return this._game.load.spritesheet(t, e, i, n, s)
    }, ImageLoader.prototype.loadAtlasHash = function(t, e, i, n) {
        var s = this._game.load.atlasJSONHash(t, e, i, n);
        return this._atlases.push(t), console.log("Loaded atlas: " + t), s
    }, ImageLoader.prototype.loadAtlasArray = function(t, e, i, n) {
        var s = this._game.load.atlasJSONArray(t, ImageLoader.prototype.convertPath(e), i, n);
        return this._atlases.push(t), console.log("Loaded atlas: " + t), s
    }, ImageLoader.prototype.loadAtlas = function(t, e) {
        var i = this._game.load.atlas(t, e, null, embedded[t], Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);
        return this._atlases.push(t), console.log("Loaded atlas: " + t), i
    };
    var imageLoader = new ImageLoader;
    imageLoader._game = null, imageLoader._backgrounds = [], imageLoader._atlases = [], Phaser.Cache.prototype.addBitmapFontByAtlas = function(t, e, i, n, s, r) {
        var o = {url: null, data: null, font: null, base: this.getBaseTexture(i)};
        void 0 === s && (s = 0), void 0 === r && (r = 0), o.font = Phaser.LoaderParser.xmlBitmapFont(e, o.base, s, r), this._cache.bitmapFont[t] = o
    }, embedded.assets = {
        frames: {
            "animalIcon.png": [1, 1928, 83, 83, 83, 83, 0, 0],
            "Antena_dpwn.png": [1629, 72, 16, 34, 16, 34, 0, 0],
            "Antena_Sphere.png": [1629, 108, 16, 12, 16, 12, 0, 0],
            "background_2.png": [1, 1, 585, 178, 585, 178, 0, 0],
            "body.png": [922, 986, 60, 71, 60, 71, 0, 0],
            "body_2.png": [978, 1330, 161, 160, 161, 160, 0, 0],
            "bubble.png": [1493, 1904, 103, 112, 103, 112, 0, 0],
            "button.png": [459, 181, 125, 84, 125, 84, 0, 0],
            "CannonSmoke_01.png": [516, 1797, 185, 223, 322, 482, 65, 251],
            "CannonSmoke_02.png": [1, 1680, 250, 246, 322, 482, 37, 218],
            "CannonSmoke_03.png": [1, 1495, 262, 183, 322, 482, 27, 192],
            "CannonSmoke_04.png": [575, 1341, 276, 198, 322, 482, 24, 156],
            "CannonSmoke_05.png": [1, 1191, 283, 204, 322, 482, 21, 102],
            "CannonSmoke_06.png": [1, 981, 286, 208, 322, 482, 14, 45],
            "CannonSmoke_07.png": [289, 1169, 284, 202, 322, 482, 14, 18],
            "canon.png": [1148, 313, 460, 384, 460, 384, 0, 0],
            "canonPig_1.png": [1024, 1538, 108, 108, 108, 108, 0, 0],
            "canonPig_2.png": [1320, 1792, 108, 108, 108, 108, 0, 0],
            "canonPig_3.png": [1430, 1792, 107, 107, 107, 107, 0, 0],
            "canonPig_4.png": [427, 1058, 147, 109, 147, 109, 0, 0],
            "canonPig_5.png": [1385, 1678, 146, 112, 146, 112, 0, 0],
            "canonPig_6.png": [430, 927, 147, 129, 147, 129, 0, 0],
            "canonPig_7.png": [1204, 1904, 143, 118, 143, 118, 0, 0],
            "canonPig_8.png": [1349, 1902, 142, 121, 142, 121, 0, 0],
            "canonPig_9.png": [459, 267, 123, 116, 123, 116, 0, 0],
            "canonPig_10.png": [1515, 1171, 130, 107, 130, 107, 0, 0],
            "canonPig_11.png": [853, 1407, 114, 139, 114, 139, 0, 0],
            "canonPig_12.png": [1164, 1489, 111, 146, 111, 146, 0, 0],
            "coin_1.png": [939, 858, 48, 126, 200, 200, 76, 37],
            "coin_2.png": [1228, 1637, 85, 126, 200, 200, 57, 38],
            "coin_3.png": [1129, 1648, 97, 126, 200, 200, 51, 38],
            "coin_4.png": [1024, 1648, 103, 126, 200, 200, 48, 37],
            "coin_5.png": [1233, 1765, 85, 126, 200, 200, 57, 37],
            "coin_6.png": [1315, 1551, 68, 126, 200, 200, 66, 37],
            "coin_7.png": [1137, 1776, 94, 126, 200, 200, 51, 37],
            "coin_8.png": [1539, 1778, 104, 124, 200, 200, 46, 39],
            "coin_9.png": [1577, 1551, 68, 126, 200, 200, 66, 37],
            "coin_10.png": [922, 1059, 48, 126, 200, 200, 73, 37],
            "CTA_button_pink.png": [1, 1397, 273, 96, 273, 96, 0, 0],
            "diamond.png": [922, 1187, 45, 42, 45, 42, 0, 0],
            "explosion_01.png": [857, 1290, 119, 115, 300, 300, 91, 92],
            "explosion_02.png": [289, 981, 136, 136, 300, 300, 87, 84],
            "explosion_03.png": [1094, 1918, 108, 97, 300, 300, 102, 107],
            "explosion_04.png": [795, 1548, 227, 234, 300, 300, 37, 33],
            "explosion_05.png": [1539, 1679, 107, 97, 300, 300, 102, 107],
            "explosion_06.png": [1515, 1280, 119, 135, 300, 300, 94, 87],
            "explosion_07.png": [1141, 1353, 141, 134, 300, 300, 85, 87],
            "explosion_08.png": [993, 1784, 142, 132, 300, 300, 85, 85],
            "explosion_09.png": [1477, 1417, 156, 132, 300, 300, 85, 85],
            "explosion_10.png": [1515, 1026, 130, 143, 300, 300, 98, 74],
            "eye_close.png": [1610, 436, 31, 21, 31, 21, 0, 0],
            "eye_close_1.png": [1610, 358, 33, 22, 33, 22, 0, 0],
            "Eyee.png": [1610, 459, 31, 20, 31, 20, 0, 0],
            "face.png": [1610, 313, 37, 43, 37, 43, 0, 0],
            "floatingIsland.png": [784, 1797, 207, 202, 207, 202, 0, 0],
            "font.png": [253, 1705, 103, 278, 105, 280, 1, 1],
            "game_name.png": [580, 623, 411, 233, 411, 233, 0, 0],
            "hand.png": [993, 1918, 99, 104, 99, 104, 0, 0],
            "hat rim_2.png": [1558, 699, 50, 24, 50, 24, 0, 0],
            "hat_2.png": [989, 982, 151, 67, 151, 67, 0, 0],
            "heart.png": [1610, 673, 19, 21, 19, 21, 0, 0],
            "heart_2.png": [1610, 411, 31, 23, 31, 23, 0, 0],
            "house.png": [276, 1446, 267, 257, 267, 257, 0, 0],
            "houseDestroyed.png": [545, 1541, 248, 254, 267, 257, 8, 3],
            "island.png": [1148, 1, 479, 310, 479, 321, 0, 9],
            "left arm.png": [1610, 696, 19, 18, 19, 18, 0, 0],
            "left arm_2.png": [922, 1231, 44, 57, 44, 57, 0, 0],
            "Left Ear.png": [1629, 122, 16, 12, 16, 12, 0, 0],
            "left leg.png": [1610, 518, 28, 34, 28, 34, 0, 0],
            "left wing.png": [1610, 554, 26, 17, 26, 17, 0, 0],
            "magic wand.png": [1629, 1, 18, 49, 18, 49, 0, 0],
            "metalButtonRing.png": [1385, 1551, 190, 125, 190, 125, 0, 0],
            "mountainIcon.png": [86, 1928, 83, 83, 83, 83, 0, 0],
            "mouth.png": [1629, 52, 17, 18, 17, 18, 0, 0],
            "mouth_2.png": [1629, 151, 13, 15, 13, 15, 0, 0],
            "nose.png": [1610, 656, 20, 15, 20, 15, 0, 0],
            "parachute.png": [984, 1051, 156, 277, 167, 280, 4, 0],
            "parachuteDestroyed.png": [358, 1705, 156, 277, 167, 280, 4, 0],
            "pig.png": [993, 813, 151, 167, 190, 188, 31, 21],
            "pigDestroyed.png": [993, 623, 152, 188, 190, 188, 30, 0],
            "play now.png": [969, 1492, 193, 44, 193, 44, 0, 0],
            "pressedButton.png": [459, 385, 121, 73, 121, 73, 0, 0],
            "right arm.png": [1610, 633, 21, 21, 21, 21, 0, 0],
            "right arm_2.png": [333, 1119, 42, 41, 42, 41, 0, 0],
            "Right Ear.png": [1629, 136, 15, 13, 15, 13, 0, 0],
            "right hand_2.png": [1610, 382, 32, 27, 32, 27, 0, 0],
            "right leg.png": [1610, 604, 22, 27, 22, 27, 0, 0],
            "right wing.png": [1610, 573, 23, 29, 23, 29, 0, 0],
            "scoreLeft.png": [575, 1268, 280, 71, 280, 71, 0, 0],
            "scoreRight.png": [286, 1373, 275, 71, 275, 71, 0, 0],
            "shipIcon.png": [1558, 725, 87, 92, 87, 92, 0, 0],
            "sparkles (animate) copy.png": [1610, 481, 28, 35, 28, 35, 0, 0],
            "Spin to win gold and  construct on your islands__2.png": [580, 858, 357, 66, 357, 66, 0, 0],
            "star (animate).png": [289, 1119, 42, 44, 42, 44, 0, 0],
            "stipe.png": [459, 460, 119, 465, 119, 465, 0, 0],
            "tower.png": [703, 1797, 79, 204, 120, 205, 22, 1],
            "towerDestroyed.png": [1558, 819, 86, 205, 120, 205, 15, 0],
            "tree.png": [1284, 1353, 191, 196, 191, 196, 0, 0],
            "trees.png": [1, 798, 427, 181, 455, 181, 0, 0],
            "treesDestroyed.png": [1, 628, 455, 168, 455, 181, 0, 13],
            "tutorialBg.png": [1147, 699, 409, 154, 409, 160, 0, 0],
            "wheel.png": [580, 926, 340, 340, 340, 340, 0, 0],
            "wheelEndGlow.png": [1, 181, 456, 445, 456, 445, 0, 0],
            "wheelRotationLight.png": [588, 1, 558, 620, 558, 620, 0, 0],
            "wheelStatic.png": [1146, 855, 367, 496, 367, 496, 0, 0]
        },
        meta: {
            app: "http://www.codeandweb.com/texturepacker",
            image: "assets_v3.png",
            smartupdate: "$TexturePacker:SmartUpdate:419438e9b2a1e7fd1e0b862a5d21a255:0573fec76bd9ef3aef8b90e13a35c24a:a759b6bbc8381ac9c472b28f589ad0d6$"
        }
    }, embedded.cta = {
        skeleton: {hash: "FvqXAXdBF4DY8eiixAex6WFSdA0", spine: "3.5.41", width: 585, height: 508.13},
        bones: [{name: "root"}, {name: "back_22", parent: "root", x: -65.11, y: 106.29}, {
            name: "big_star",
            parent: "root",
            x: -116.94,
            y: -10.23
        }, {name: "body", parent: "root", length: 151.65, rotation: -84.7, x: -200, y: 173}, {
            name: "button",
            parent: "root",
            x: 1.99,
            y: -55.13
        }, {name: "head", parent: "body", length: 75.95, rotation: 174.7, x: 7.53, y: -3.88}, {
            name: "left_arm",
            parent: "body",
            length: 38.08,
            rotation: -36.6,
            x: 76.61,
            y: -56.2
        }, {name: "logo", parent: "root", x: 18.22, y: 275.35}, {
            name: "mouse",
            parent: "body",
            length: 9.22,
            rotation: -2.24,
            x: 70.9,
            y: 17.81
        }, {name: "play", parent: "button", y: 5.99}, {
            name: "right_arm",
            parent: "body",
            length: 39.41,
            rotation: 136.49,
            x: 69.29,
            y: 53.63
        }, {name: "star_2", parent: "root", x: 85.58, y: -95.53}, {
            name: "text",
            parent: "back_22",
            x: 63.56,
            y: -1.82
        }],
        slots: [{
            name: "background_2",
            bone: "back_22",
            attachment: "background_2"
        }, {
            name: "Spin to win gold and  construct on your islands__2",
            bone: "text",
            attachment: "Spin to win gold and  construct on your islands__2"
        }, {name: "right arm_2", bone: "right_arm", attachment: "right arm_2"}, {
            name: "head",
            bone: "head",
            attachment: "hat rim_2"
        }, {name: "body_2", bone: "body", attachment: "body_2"}, {
            name: "hat_2",
            bone: "head",
            attachment: "hat_2"
        }, {name: "right hand_2", bone: "right_arm", attachment: "right hand_2"}, {
            name: "left arm_2",
            bone: "left_arm",
            attachment: "left arm_2"
        }, {name: "mouth_2", bone: "mouse", attachment: "mouth_2"}, {
            name: "game_name",
            bone: "logo",
            attachment: "game_name"
        }, {name: "CTA_button_pink", bone: "button", attachment: "CTA_button_pink"}, {
            name: "play now",
            bone: "play",
            attachment: "play now"
        }, {
            name: "sparkles (animate) copy",
            bone: "star_2",
            attachment: "sparkles (animate) copy"
        }, {name: "star (animate)", bone: "big_star", attachment: "star (animate)"}],
        skins: {
            "default": {
                CTA_button_pink: {CTA_button_pink: {width: 273, height: 96}},
                "Spin to win gold and  construct on your islands__2": {
                    "Spin to win gold and  construct on your islands__2": {
                        x: 86.32,
                        y: 8.07,
                        width: 357,
                        height: 66
                    }
                },
                background_2: {background_2: {x: 67.69, y: 3.1, width: 585, height: 178}},
                body_2: {body_2: {x: 70.08, y: -5.16, rotation: 84.7, width: 161, height: 160}},
                game_name: {game_name: {x: -14.61, y: 3.65, width: 411, height: 233}},
                hat_2: {hat_2: {x: 10.85, y: 9.11, rotation: -87.55, width: 151, height: 67}},
                head: {"hat rim_2": {x: 4.08, y: -42.02, rotation: -90, width: 50, height: 24}},
                "left arm_2": {"left arm_2": {x: 4.2, y: 1.6, rotation: 120.46, width: 44, height: 57}},
                mouth_2: {mouth_2: {x: 1.91, y: -.98, rotation: 89.51, width: 13, height: 15}},
                "play now": {"play now": {width: 193, height: 44}},
                "right arm_2": {"right arm_2": {x: 11.46, y: .28, rotation: -47.28, width: 42, height: 41}},
                "right hand_2": {"right hand_2": {x: 26.04, y: 8.85, rotation: -47.28, width: 32, height: 27}},
                "sparkles (animate) copy": {"sparkles (animate) copy": {x: .49, y: .41, width: 28, height: 35}},
                "star (animate)": {"star (animate)": {x: 8.42, y: -.65, width: 42, height: 44}}
            }
        },
        animations: {
            start: {
                slots: {
                    "sparkles (animate) copy": {
                        color: [{time: .6667, color: "ffffff00"}, {
                            time: 1,
                            color: "ffffffff",
                            curve: "stepped"
                        }, {time: 1.1667, color: "ffffffff"}, {time: 1.4333, color: "ffffff00"}],
                        attachment: [{time: 0, name: null}, {time: .6667, name: "sparkles (animate) copy"}]
                    },
                    "star (animate)": {
                        color: [{time: .6667, color: "ffffff00"}, {
                            time: .8333,
                            color: "ffffffff"
                        }, {time: .9, color: "ffffffad"}, {time: 1.0333, color: "ffffffff"}, {
                            time: 1.4333,
                            color: "ffffff00"
                        }], attachment: [{time: 0, name: null}, {time: .6667, name: "star (animate)"}]
                    }
                },
                bones: {
                    button: {
                        scale: [{time: 0, x: 0, y: 0}, {time: .3333, x: 1.2, y: 1.2}, {
                            time: .4,
                            x: .8,
                            y: .8
                        }, {time: .5, x: 1.1, y: 1.1}, {time: .6333, x: 1, y: 1}]
                    },
                    back_22: {
                        translate: [{time: 0, x: 1305.94, y: 0}, {time: .6667, x: 0, y: 0}, {
                            time: .7333,
                            x: -46.3,
                            y: 0
                        }, {time: .8333, x: 22.2, y: 0}, {time: 1, x: 0, y: 0}],
                        scale: [{time: .6667, x: 1, y: 1}, {time: .7333, x: .8, y: 1.2}, {
                            time: .8333,
                            x: 1.1,
                            y: .9
                        }, {time: 1, x: 1, y: 1}]
                    },
                    logo: {
                        scale: [{time: 0, x: 0, y: 0}, {time: .2667, x: 1.2, y: 1.2}, {
                            time: .3333,
                            x: .8,
                            y: .8
                        }, {time: .4333, x: 1.1, y: 1.1}, {time: .7667, x: 1.02, y: .98}, {
                            time: 1.4333,
                            x: .98,
                            y: 1.02
                        }]
                    },
                    body: {
                        translate: [{time: 0, x: 0, y: 801.35, curve: "stepped"}, {
                            time: .4667,
                            x: 0,
                            y: 801.35
                        }, {time: .9667, x: 0, y: 0}, {time: 1.0667, x: 0, y: -29.5}, {
                            time: 1.2333,
                            x: 0,
                            y: 13.91
                        }, {time: 1.4333, x: 0, y: 0}],
                        scale: [{time: .9667, x: 1, y: 1}, {time: 1.0667, x: .8, y: 1.2}, {
                            time: 1.2333,
                            x: 1.1,
                            y: .9
                        }, {time: 1.4333, x: 1, y: 1}]
                    },
                    big_star: {
                        translate: [{time: .6667, x: -12.96, y: -29.56}, {
                            time: .7333,
                            x: -4.05,
                            y: -14.17
                        }, {time: .8, x: 10.13, y: -4.86}, {time: 1.4333, x: 170.91, y: -2.43}],
                        scale: [{time: .8333, x: 1, y: 1}, {time: 1.4333, x: .2, y: .2}]
                    },
                    star_2: {
                        translate: [{time: .6667, x: 50.22, y: 38.47}, {
                            time: .7667,
                            x: 42.23,
                            y: 19.77
                        }, {time: .8667, x: 34.23, y: 11.6}, {time: 1, x: 13.81, y: 3.98}, {
                            time: 1.4333,
                            x: -39.69,
                            y: 3.82
                        }]
                    }
                }
            },
            idle: {
                slots: {
                    "sparkles (animate) copy": {
                        color: [{
                            time: .1667,
                            color: "ffffff00",
                            curve: "stepped"
                        }, {time: .3333, color: "ffffff00"}, {
                            time: .6667,
                            color: "ffffffff",
                            curve: "stepped"
                        }, {time: 1, color: "ffffffff"}, {time: 1.3333, color: "ffffff00"}],
                        attachment: [{time: 0, name: null}, {time: .1667, name: "sparkles (animate) copy"}]
                    },
                    "star (animate)": {
                        color: [{time: .3333, color: "ffffff00"}, {
                            time: .7,
                            color: "ffffffff"
                        }, {time: 1.1, color: "ffffff00"}],
                        attachment: [{time: 0, name: null}, {time: .3333, name: "star (animate)"}]
                    }
                },
                bones: {
                    logo: {
                        scale: [{time: 0, x: .98, y: 1.02}, {time: .6667, x: 1.02, y: .98}, {
                            time: 1.3333,
                            x: .98,
                            y: 1.02
                        }]
                    },
                    body: {scale: [{time: 0, x: 1, y: 1}, {time: .6667, x: 1.03, y: 1.03}, {time: 1.3333, x: 1, y: 1}]},
                    play: {scale: [{time: .8333, x: 1, y: 1}, {time: 1, x: 1.1, y: .899}, {time: 1.1667, x: 1, y: 1}]},
                    right_arm: {rotate: [{time: 0, angle: 0}, {time: .6667, angle: -8.16}, {time: 1.3333, angle: 0}]},
                    left_arm: {rotate: [{time: 0, angle: 0}, {time: .6667, angle: -3.81}, {time: 1.3333, angle: 0}]},
                    head: {rotate: [{time: 0, angle: 0}, {time: .6667, angle: -4.39}, {time: 1.3333, angle: 0}]},
                    star_2: {
                        translate: [{time: .3333, x: 50.22, y: 38.47}, {
                            time: .6667,
                            x: 13.81,
                            y: 3.98
                        }, {time: .9333, x: -39.69, y: 3.82}, {time: 1.3333, x: -119.66, y: 4.63}]
                    },
                    big_star: {
                        translate: [{time: .3333, x: -12.96, y: -29.56}, {
                            time: .4,
                            x: -4.05,
                            y: -14.17
                        }, {time: .5, x: 20.94, y: -4.67}, {time: 1.1, x: 170.91, y: -2.43}],
                        scale: [{time: .5, x: 1, y: 1}, {time: 1.1, x: .2, y: .2}]
                    }
                }
            }
        }
    }, embedded.wheelPigSpine = {
        skeleton: {
            hash: "0wNaVnGzKRURp8CXl33fj+1A+H4",
            spine: "3.5.41",
            width: 83.5,
            height: 112.31
        },
        bones: [{name: "root"}, {
            name: "body",
            parent: "root",
            length: 36,
            rotation: 71.71,
            x: -29.41,
            y: 101.24
        }, {name: "antena", parent: "body", length: 25.29, rotation: -1.89, x: 54.56, y: 11.26}, {
            name: "antena_sphere",
            parent: "antena",
            rotation: -69.82,
            x: 23.03,
            y: -10.43
        }, {name: "left_arm", parent: "body", length: 12.01, rotation: -71.71, x: 12.92, y: -23.59}, {
            name: "arrow",
            parent: "left_arm",
            length: 21.12,
            rotation: 72.67,
            x: 8.87,
            y: 3
        }, {name: "eyes", parent: "body", x: 35.64, y: 3.8}, {
            name: "heart",
            parent: "body",
            x: 7.22,
            y: 10.97
        }, {name: "left_eaar", parent: "body", length: 7.52, rotation: -80.46, x: 45.16, y: -7.21}, {
            name: "left_leg",
            parent: "body",
            length: 18.95,
            rotation: 157.27,
            x: -9.12,
            y: -13.86
        }, {name: "left_wing", parent: "body", length: 14.76, rotation: -33.4, x: 42.39, y: -9.33}, {
            name: "mouse",
            parent: "body",
            x: 12.78,
            y: -5.87
        }, {name: "nouse", parent: "body", x: 24.45, y: -6.53}, {
            name: "right_ear",
            parent: "body",
            length: 5.72,
            rotation: 31.29,
            x: 41.28,
            y: 14.55
        }, {name: "right_leg", parent: "body", length: 23.67, rotation: 155.25, x: -5.3, y: 15.12}, {
            name: "rigt_arm",
            parent: "body",
            length: 21.59,
            rotation: 72.18,
            x: 20.27,
            y: 22.97
        }, {name: "rigt_wing", parent: "body", length: 15.19, rotation: 53.33, x: 35.14, y: 18.09}],
        slots: [{name: "magic wand2", bone: "arrow", attachment: "magic wand"}, {
            name: "right leg2",
            bone: "right_leg",
            attachment: "right leg"
        }, {name: "left wing2", bone: "left_wing", attachment: "left wing"}, {
            name: "right wing2",
            bone: "rigt_wing",
            attachment: "right wing"
        }, {name: "left arm2", bone: "left_arm", attachment: "left arm"}, {
            name: "left leg2",
            bone: "left_leg",
            attachment: "left leg"
        }, {name: "Antena_Sphere2", bone: "antena_sphere", attachment: "Antena_Sphere"}, {
            name: "Antena_dpwn2",
            bone: "antena",
            attachment: "Antena_dpwn"
        }, {name: "Left Ear2", bone: "left_eaar", attachment: "Left Ear"}, {
            name: "body2",
            bone: "body",
            attachment: "body"
        }, {name: "face2", bone: "nouse", attachment: "face"}, {
            name: "heart2",
            bone: "heart",
            attachment: "heart"
        }, {name: "mouth2", bone: "mouse", attachment: "mouth"}, {
            name: "right arm2",
            bone: "rigt_arm",
            attachment: "right arm"
        }, {name: "Eyee2", bone: "eyes", attachment: "Eyee"}, {
            name: "nose2",
            bone: "nouse",
            attachment: "nose"
        }, {name: "Right Ear2", bone: "right_ear", attachment: "Right Ear"}, {
            name: "eye_close",
            bone: "eyes"
        }, {name: "eye_close_1", bone: "eyes"}],
        skins: {
            "default": {
                Antena_Sphere2: {Antena_Sphere: {x: -2.17, y: 1.13, width: 16, height: 12}},
                Antena_dpwn2: {Antena_dpwn: {x: 10.77, y: -.37, rotation: -69.82, width: 16, height: 34}},
                Eyee2: {Eyee: {x: -1.92, y: -6.75, rotation: -71.71, width: 31, height: 20}},
                "Left Ear2": {"Left Ear": {x: 6.44, y: -2.12, rotation: 8.75, width: 16, height: 12}},
                "Right Ear2": {"Right Ear": {x: 5.4, y: 1.93, rotation: -102.99, width: 15, height: 13}},
                body2: {body: {x: 16.36, y: 6.41, rotation: -71.71, width: 60, height: 71}},
                eye_close: {eye_close: {x: -1.71, y: -7.2, rotation: 288, width: 31, height: 21}},
                eye_close_1: {eye_close_1: {x: -1.71, y: -7.2, rotation: 288, width: 33, height: 22}},
                face2: {face: {x: 1.37, y: 5.17, rotation: -71.71, width: 37, height: 43}},
                heart2: {heart: {x: 1.21, y: -2.3, rotation: -71.71, width: 19, height: 21}},
                "left arm2": {"left arm": {x: 4.55, y: 1.5, width: 19, height: 18}},
                "left leg2": {"left leg": {x: 1.84, y: -2.15, rotation: 131.02, width: 28, height: 34}},
                "left wing2": {"left wing": {x: 6.38, y: 1.17, rotation: -38.31, width: 26, height: 17}},
                "magic wand2": {"magic wand": {x: 11.73, y: -1.35, rotation: -72.67, width: 18, height: 49}},
                mouth2: {mouth: {x: 5.85, y: 1.71, rotation: -71.71, width: 17, height: 18}},
                nose2: {nose: {x: -.33, y: 2.75, rotation: -71.71, width: 20, height: 15}},
                "right arm2": {"right arm": {x: 7.97, y: 1.27, rotation: -143.89, width: 21, height: 21}},
                "right leg2": {"right leg": {x: 9.47, y: -1.24, rotation: 133.04, width: 22, height: 27}},
                "right wing2": {"right wing": {x: 9.95, y: 1.48, rotation: -125.04, width: 23, height: 29}}
            }
        },
        animations: {
            animation: {
                slots: {
                    eye_close: {
                        attachment: [{time: .5, name: "eye_close"}, {
                            time: .6,
                            name: null
                        }, {time: .6333, name: "eye_close"}, {time: .6667, name: null}]
                    }, eye_close_1: {attachment: [{time: .5333, name: "eye_close_1"}, {time: .6333, name: null}]}
                },
                bones: {
                    body: {
                        translate: [{time: 0, x: 0, y: 0}, {time: 1, x: 0, y: -8.44}, {
                            time: 2,
                            x: 0,
                            y: 0
                        }, {time: 3, x: 0, y: -8.44}, {time: 4, x: 0, y: 0}]
                    },
                    left_eaar: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: 12.52}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: 12.52
                        }, {time: 4, angle: 0}]
                    },
                    rigt_wing: {
                        rotate: [{time: 0, angle: 30.74}, {time: 1, angle: 0}, {
                            time: 2,
                            angle: 30.74
                        }, {time: 3, angle: 0}, {time: 4, angle: 30.74}]
                    },
                    right_ear: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: -10.96}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: -10.96
                        }, {time: 4, angle: 0}]
                    },
                    left_wing: {
                        rotate: [{time: 0, angle: -14.45}, {time: 1, angle: 6.51}, {
                            time: 2,
                            angle: -14.45
                        }, {time: 3, angle: 6.51}, {time: 4, angle: -14.45}]
                    },
                    mouse: {
                        translate: [{time: 0, x: 1.18, y: .54}, {time: 1, x: 2.31, y: .76}, {
                            time: 2,
                            x: 1.18,
                            y: .54
                        }, {time: 3, x: 2.31, y: .76}, {time: 4, x: 1.18, y: .54}]
                    },
                    rigt_arm: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: -6.17}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: -6.17
                        }, {time: 4, angle: 0}]
                    },
                    left_arm: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: 8.77}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: 8.77
                        }, {time: 4, angle: 0}]
                    },
                    right_leg: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: -8.53}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: -8.53
                        }, {time: 4, angle: 0}]
                    },
                    left_leg: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: 10.02}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: 10.02
                        }, {time: 4, angle: 0}]
                    },
                    antena: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: 6.56}, {time: 2, angle: 0}, {
                            time: 3,
                            angle: 6.56
                        }, {time: 4, angle: 0}]
                    },
                    antena_sphere: {
                        rotate: [{time: 0, angle: 0}, {time: 1, angle: 20.17}, {
                            time: 2,
                            angle: 0
                        }, {time: 3, angle: 20.17}, {time: 4, angle: 0}],
                        translate: [{time: 0, x: 0, y: 0}, {time: 1, x: 2.77, y: -.51}, {time: 2, x: 0, y: 0}, {
                            time: 3,
                            x: 2.77,
                            y: -.51
                        }, {time: 4, x: 0, y: 0}],
                        scale: [{time: 0, x: 1, y: 1}, {time: 1, x: 1.136, y: 1.136}, {time: 2, x: 1, y: 1}, {
                            time: 3,
                            x: 1.136,
                            y: 1.136
                        }, {time: 4, x: 1, y: 1}]
                    }
                }
            }
        }
    }, !function t(e, i, n) {
        function s(o, a) {
            if(!i[o]) {
                if(!e[o]) {
                    var h = "function" == typeof require && require;
                    if(!a && h)return h(o, !0);
                    if(r)return r(o, !0);
                    var l = new Error("Cannot find module '" + o + "'");
                    throw l.code = "MODULE_NOT_FOUND", l
                }
                var c = i[o] = {exports: {}};
                e[o][0].call(c.exports, function(t) {
                    var i = e[o][1][t];
                    return s(i ? i : t)
                }, c, c.exports, t, e, i, n)
            }
            return i[o].exports
        }

        for(var r = "function" == typeof require && require, o = 0; o < n.length; o++)s(n[o]);
        return s
    }({
        1: [function(t, e, i) {
            e.exports = {
                name: "Piggy Boom - Paradise island",
                "appstore-url": "https://itunes.apple.com/us/app/piggy-boom-paradise-island/id1129050711?mt=8",
                "googleplay-url": "https://play.google.com/store/apps/details?id=com.rafotech.piggyboom&hl=uk",
                extra_fonts: [],
                css_fonts: ["BAUHAUSB"],
                getapp_instead_of_title: !1,
                icon: "icon.jpg",
                phaser: "2.6.2/phaser-arcade-lite.js",
                libs: ["phaser-spine/phaser-spine-merged.js", "localization.js", "utils.js", "image_loader.js"]
            }
        }, {}],
        2: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            var a = t("display/layout-utils"), h = n(a), l = t("./states/preloader-state"), c = n(l),
                u = t("./states/game-state"), d = n(u), p = function(t) {
                    function e() {
                        s(this, e);
                        var t = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, "100%", "100%", Phaser.CANVAS, h["default"].CONTAINER_NAME, null));
                        return t.state.add("PreloaderState", c["default"], !1), t.state.add("GameState", d["default"], !1), t.state.start("PreloaderState"), t
                    }

                    return o(e, t), e
                }(Phaser.Game);
            new p
        }, {"./states/game-state": 17, "./states/preloader-state": 18, "display/layout-utils": 3}],
        3: [function(t, e, i) {
            "use strict";
            function n(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var s = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), r = function() {
                function t() {
                    throw n(this, t), new Error("AbstractClassError")
                }

                return s(t, null, [{
                    key: "getDevicePixelRatio", value: function() {
                        var e = 1;
                        return void 0 !== window.screen.systemXDPI && void 0 !== window.screen.logicalXDPI && window.screen.systemXDPI > window.screen.logicalXDPI ? e = window.screen.systemXDPI / window.screen.logicalXDPI : void 0 !== window.devicePixelRatio && (e = window.devicePixelRatio), e * t.RENDER_RESOLUTION
                    }
                }, {
                    key: "getHeaderHeight", value: function() {
                        return t.HEADER_ELEMENT.clientHeight * t.getDevicePixelRatio() * t.INVS
                    }
                }, {
                    key: "refreshViewDimmensions", value: function() {
                        t.CONTAINER = document.getElementById(t.CONTAINER_NAME), t.HEADER_ELEMENT = document.getElementById("ad_header"), t.VIEW_WIDTH = window.innerWidth * t.getDevicePixelRatio(), t.VIEW_HEIGHT = window.innerHeight * t.getDevicePixelRatio(), t.IS_LANDSCAPE ? (t.BASE_WIDTH = t.DEFAULT_BASE_WIDTH, t.BASE_HEIGHT = t.DEFAULT_BASE_HEIGHT) : (t.BASE_WIDTH = t.DEFAULT_BASE_HEIGHT, t.BASE_HEIGHT = t.DEFAULT_BASE_WIDTH);
                        var e = t.VIEW_WIDTH / t.BASE_WIDTH, i = t.VIEW_HEIGHT / t.BASE_HEIGHT;
                        t.S = Math.min(e, i), t.INVS = 1 / t.S, t.LEFT_OFFSET = -(t.VIEW_WIDTH / 2 - t.BASE_WIDTH / 2 * t.S) * t.INVS, t.RIGHT_OFFSET = -t.LEFT_OFFSET + t.BASE_WIDTH, t.TOP_OFFSET = -(t.VIEW_HEIGHT / 2 - t.BASE_HEIGHT / 2 * t.S) * t.INVS, t.BOTTOM_OFFSET = -t.TOP_OFFSET + t.BASE_HEIGHT, t.FULL_GAME_WIDTH = t.RIGHT_OFFSET - t.LEFT_OFFSET, t.FULL_GAME_HEIGHT = t.BOTTOM_OFFSET - t.TOP_OFFSET, t.ASPECT_RATIO = Math.round(t.VIEW_HEIGHT / t.VIEW_WIDTH * 100) / 100, t.fixCanvasSize(!0), t.__blockWrongOrientation()
                    }
                }, {
                    key: "__blockWrongOrientation", value: function() {
                        "live" === ad_state && (t.IS_LANDSCAPE && t.VIEW_HEIGHT > t.VIEW_WIDTH ? document.getElementById("orientation").style.display = "block" : t.IS_PORTRAIT && t.VIEW_WIDTH > t.VIEW_HEIGHT ? document.getElementById("orientation").style.display = "block" : document.getElementById("orientation").style.display = "none")
                    }
                }, {
                    key: "fixCanvasSize", value: function() {
                        var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        return e ? void setTimeout(function() {
                            t.fixCanvasSize(!1)
                        }, 100) : void window.scrollTo(0, 1)
                    }
                }, {
                    key: "centerIntoView", value: function(e) {
                        e.scale.set(t.S), e.x = t.VIEW_WIDTH / 2 - t.BASE_WIDTH / 2 * t.S, e.y = t.VIEW_HEIGHT / 2 - t.BASE_HEIGHT / 2 * t.S
                    }
                }, {
                    key: "fitIntoRect", value: function(t, e, i, n, s) {
                        var r = s ? s.width / t.scale.x : t.width / t.scale.x,
                            o = s ? s.height / t.scale.y : t.height / t.scale.y, a = e.width, h = e.height, l = a / r,
                            c = h / o, u = r / o, d = a / h, p = i ? c : l, f = i ? l : c, g = u >= d ? p : f,
                            m = r * g, y = o * g, v = 0, x = 0;
                        switch(n) {
                            case"left":
                            case"topLeft":
                            case"bottomLeft":
                                v = 0;
                                break;
                            case"right":
                            case"topRight":
                            case"bottomRight":
                                v = m - a;
                                break;
                            default:
                                v = .5 * (m - a)
                        }
                        switch(n) {
                            case"top":
                            case"topLeft":
                            case"topRight":
                                x = 0;
                                break;
                            case"bottom":
                            case"bottomLeft":
                            case"bottomRight":
                                x = y - h;
                                break;
                            default:
                                x = .5 * (y - h)
                        }
                        t.x = e.x - v, t.y = e.y - x, t.scale.set(g)
                    }
                }]), t
            }();
            r.RENDER_RESOLUTION = 1, r.CONTAINER_NAME = "creative", r.CONTAINER = document.getElementById(r.CONTAINER_NAME), r.DEFAULT_BASE_WIDTH = 960, r.DEFAULT_BASE_HEIGHT = 640, r.BASE_WIDTH = 960, r.BASE_HEIGHT = 640, r.ASPECT_RATIO = 0, r.S = 1, r.INVS = 1 / r.S, r.VIEW_WIDTH = 0, r.VIEW_HEIGHT = 0, r.LEFT_OFFSET = 0, r.RIGHT_OFFSET = 0, r.TOP_OFFSET = 0, r.BOTTOM_OFFSET = 0, r.IS_LANDSCAPE = "landscape" === ad_orientation, r.IS_PORTRAIT = !r.IS_LANDSCAPE, r.MODULE_NAME = "LayoutUtils", i["default"] = r
        }, {}],
        4: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = t("errors/error-base"), h = n(a), l = function(t) {
                function e(t) {
                    return s(this, e), t || (t = "You cannot make instance of this class."), r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t))
                }

                return o(e, t), e
            }(h["default"]);
            i["default"] = l
        }, {"errors/error-base": 5}],
        5: [function(t, e, i) {
            "use strict";
            function n(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function s(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function r(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var o = function(t) {
                function e(t) {
                    n(this, e);
                    var i = s(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
                    return i.name = i.constructor.name, i.message = t, "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(i, i.constructor) : i.stack = new Error(t).stack, i
                }

                return r(e, t), e
            }(Error);
            i["default"] = o
        }, {}],
        6: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var r = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), o = t("errors/abstract-class-error"), a = n(o), h = function() {
                function t() {
                    throw s(this, t), new a["default"]
                }

                return r(t, null, [{
                    key: "map", value: function(t, e, i, n, s, r, o, a) {
                        if(o && t < e)return n;
                        if(a && t > i)return s;
                        var h = (t - e) / (i - e), l = h * (s - n) + n;
                        return r ? Math.round(l) : l
                    }
                }, {
                    key: "LP", value: function(t, e) {
                        return "landscape" == ad_orientation ? t : e
                    }
                }]), t
            }();
            i["default"] = h, h.FONT_IS_LOADED = !1, h.VERBOSE = !0, h.WEB_ROOT = ad_webroot, h.lastInteraction = Date.now(), h.TOTAL_COLUMNS = 10, h.TOTAL_ROWS = 10, h.CELL_WIDTH = 50, h.CELL_HEIGHT = 50, h.CELL_GAP = 2, h.ITEM_CLICK_OFFSET = 40, h.DRAG_OFFSET = 50
        }, {"errors/abstract-class-error": 4}],
        7: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("../display/layout-utils"), l = n(h), c = function(t) {
                function e(t, i, n) {
                    var o = n.wheel;
                    s(this, e);
                    var a = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return a.wheel = o, a.init(), a
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                        var t = l["default"].FULL_GAME_WIDTH, e = LP(1, 1.5);
                        this.addStatic({w: t, sc: e}), this.addButtons({
                            w: t,
                            sc: e
                        }), this.x = l["default"].LEFT_OFFSET + l["default"].FULL_GAME_WIDTH / 2, this.y = Math.min(this.wheel.bottom - LP(20, 100), l["default"].FULL_GAME_HEIGHT - LP(80, 160)), this.scale.set(LP(1, 1.5))
                    }
                }, {
                    key: "addStatic", value: function(t) {
                        var e = (t.w, imageLoader.sprite(0, 7, "metalButtonRing.png"));
                        e.anchor.set(.5, 0), this.add(e)
                    }
                }, {
                    key: "addButtons", value: function(t) {
                        var e = (t.w, this.button = imageLoader.sprite(0, 0, "button.png"));
                        e.anchor.set(.5, 0), e.inputEnabled = !0, e.events.onInputDown.add(this.onButtonClicked, this), e.events.onInputUp.add(this.onButtonUp, this), this.add(e);
                        var i = this.pressedButton = imageLoader.sprite(0, 5, "pressedButton.png");
                        i.anchor.set(.5, 0), i.alpha = 0, this.add(i);
                        var n = this.hand = imageLoader.sprite(-15, 10, "hand.png");
                        this.add(n), this.idle()
                    }
                }, {
                    key: "onButtonUp", value: function() {
                        var t = this, e = 200;
                        this.game.add.tween(this.button).to({alpha: 1}, e).start(), this.game.add.tween(this.pressedButton).to({alpha: 0}, e).start(), this.game.add.tween(this.hand).to({y: 10}, e).start().onComplete.addOnce(function() {
                            return t.idle()
                        })
                    }
                }, {
                    key: "onButtonClicked", value: function() {
                        var t = 200;
                        this.game.add.tween(this.button).to({alpha: 0}, t).start(), this.game.add.tween(this.pressedButton).to({alpha: 1}, t).start(), this.game.tweens.remove(this.idleTw), this.game.add.tween(this.hand).to({y: 40}, t, null, !0), this.game.add.tween(this.hand).to({alpha: 0}, t, null, !0, 500), this.wheel.rotate()
                    }
                }, {
                    key: "idle", value: function() {
                        this.hand.reset(-15, 10), this.idleTw = this.game.add.tween(this.hand).to({y: 20}, 300, null, !0, 500, -1, !0)
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = c
        }, {"../display/layout-utils": 3}],
        8: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("../display/layout-utils"), l = n(h), c = function(t) {
                function e(t, i, n) {
                    var o = n.islandView, a = n.wheelView;
                    s(this, e);
                    var h = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return h.islandView = o, h.wheelView = a, h.init(), h
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                    }
                }, {
                    key: "showIsland", value: function() {
                        var t = this.islandView, e = this.wheelView, i = 1e3;
                        this.game.add.tween(this.parent).to({y: [this.parent.y - 400, this.parent.y]}, i, Phaser.Easing.Sinusoidal.InOut).start(), this.game.add.tween(t).to({x: l["default"].LEFT_OFFSET}, i, Phaser.Easing.Sinusoidal.InOut).start(), this.game.add.tween(e).to({x: e.x - 2 * l["default"].FULL_GAME_WIDTH}, i, Phaser.Easing.Sinusoidal.InOut).start()
                    }
                }, {
                    key: "shake", value: function() {
                        var t = this;
                        if(!this.shaked) {
                            this.shaked = !0;
                            var e = this.parent, i = e.x, n = e.y;
                            this.game.add.tween(e).to({
                                x: [i + 10, i - 10, i + 13, i + 3, i - 4, i],
                                y: [n + 10, n - 3, n - 10, n - 4, n + 6, n]
                            }, 100, null, !0, 0, 3).onComplete.add(function() {
                                return t.shaked = !1
                            })
                        }
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = c
        }, {"../display/layout-utils": 3}],
        9: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("../display/layout-utils"), l = n(h), c = t("../kernel/globals"), u = n(c), d = function(t) {
                function e(t, i) {
                    s(this, e);
                    var n = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return n.init(), n.y = l["default"].TOP_OFFSET + n.height - LP(90, 295), n.x = l["default"].FULL_GAME_WIDTH / 2, n.scale.set(LP(.7, 1)), n
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                        var t = this.pig = imageLoader.sprite(this.pigPos.x, this.pigPos.y, "canonPig_1.png"),
                            e = this.view = imageLoader.sprite(0, l["default"].FULL_GAME_HEIGHT + 20, "canon.png"),
                            i = this.explosion = imageLoader.sprite(0, 0, "explosion_01.png"),
                            n = this.canonSmoke = imageLoader.sprite(0, -e.height - 200, "CannonSmoke_01.png"),
                            s = this.stipe = imageLoader.sprite(0, 0, "stipe.png");
                        t.anchor.set(.5), e.scale.set(.7), e.anchor.set(.5, 1), i.anchor.set(.5), i.visible = !1, n.anchor.set(.5), n.visible = !1, s.anchor.set(.5, 0), s.scale.y = 0, s.width = t.width, t.addChild(s), e.addChild(n), this.add(t), this.add(e), this.add(i)
                    }
                }, {
                    key: "shootPigTo", value: function(t, e) {
                        var i = this, n = this.pig, s = this.stipe, r = this.explosion, o = t.worldPosition,
                            a = this.game.input.getLocalPosition(this, new Phaser.Point(o.x, o.y)),
                            h = {x: a.x + .2 * (a.x - n.x), y: a.y + .2 * (a.y - n.y)},
                            l = -Math.atan((a.x - n.x) / (a.y - n.y));
                        n.rotation = l, n.frameName = "canonPig_9.png", n.visible = !0, r.x = a.x, r.y = a.y;
                        var c = 500;
                        this.canonShootAnimation(l, function() {
                            i.game.add.tween(s.scale).to({y: [.7, .7, .2]}, c).start(), i.game.add.tween(n.scale).to({
                                x: .7,
                                y: .7
                            }, c).start(), i.game.add.tween(n).to(h, c).start().onComplete.add(function() {
                                i.pigShootAnimation.play(12, !1).onComplete.addOnce(function() {
                                    i.game.add.tween(s.scale).to({y: -.5}, c).start(), i.game.add.tween(n.scale).to({
                                        x: .5,
                                        y: .5
                                    }, c).start(), i.game.add.tween(n).to(a, c).start().onComplete.add(function() {
                                        s.scale.y = 0, r.visible = !0, n.visible = !1, e(), i.explosionAnimation.play(15, !1).onComplete.addOnce(function() {
                                            r.visible = !1, n.x = i.pigPos.x, n.y = i.pigPos.y, n.scale.set(1), u["default"].state = "idle"
                                        })
                                    })
                                })
                            })
                        })
                    }
                }, {
                    key: "canonShootAnimation", value: function(t, e) {
                        var i = this, n = this.view;
                        this.game.add.tween(n).to({rotation: t}, 200).start().onComplete.add(function() {
                            i.game.add.tween(n.scale).to({
                                x: n.scale.x + .3,
                                y: n.scale.y - .5
                            }, 150, Phaser.Easing.Circular.InOut, !0, 0, 0, !0).onComplete.add(function() {
                                e(), i.canonSmoke.visible = !0, i.canonSmokeAnimation.play(15, !1).onComplete.add(function() {
                                    return i.canonSmoke.visible = !1
                                }), i.game.add.tween(n.scale).to({
                                    x: n.scale.x + .1,
                                    y: n.scale.y - .1
                                }, 50, Phaser.Easing.Circular.InOut, !0, 0, 0, !0).onComplete.add(function() {
                                    i.game.add.tween(n).to({rotation: 0}, 200, null, !0, 500)
                                })
                            })
                        })
                    }
                }, {
                    key: "show", value: function() {
                        var t = this.view;
                        t.y += t.height, t.visible = !0, this.game.add.tween(t).to({y: t.y - t.height}).start()
                    }
                }, {
                    key: "showPig", value: function(t, e) {
                        var i = this.pig, n = t.worldPosition,
                            s = this.game.input.getLocalPosition(this, new Phaser.Point(n.x, n.y));
                        i.x = s.x, i.y = s.y, i.scale.set(0);
                        var r = 500;
                        this.game.add.tween(i).to({y: s.y - 200}, r).start(), this.game.add.tween(i.scale).to({
                            x: 1,
                            y: 1
                        }, r).start().onComplete.add(e)
                    }
                }, {
                    key: "tweenPigFromWheelToCanon", value: function(t) {
                        var e = this;
                        u["default"].state = "progress";
                        var i = this.pig;
                        this.pigRotateAnimation.play(15, !0), this.game.add.tween(i).to({
                            x: this.pigPos.x,
                            y: [i.y - LP(-200, 100), i.y + 100]
                        }, 1e3, Phaser.Easing.Sinusoidal.InOut).start().onComplete.add(function() {
                            e.pigRotateAnimation.stop(), e.pigLoadAnimation.play(15, !1), e.game.add.tween(i).to(e.pigPos, 1500).start().onComplete.add(function() {
                                u["default"].state = "ready", e.island.showIcons()
                            })
                        })
                    }
                }, {
                    key: "pigPos", get: function() {
                        return {x: 0, y: l["default"].FULL_GAME_HEIGHT}
                    }
                }, {
                    key: "pigShootAnimation", get: function() {
                        return this.pig.animations.add("shoot", Phaser.Animation.generateFrameNames("canonPig_", 9, 12, ".png"))
                    }
                }, {
                    key: "pigRotateAnimation", get: function() {
                        return this.pig.animations.add("rotate", Phaser.Animation.generateFrameNames("canonPig_", 1, 3, ".png"))
                    }
                }, {
                    key: "pigLoadAnimation", get: function() {
                        return this.pig.animations.add("load", Phaser.Animation.generateFrameNames("canonPig_", 4, 8, ".png"))
                    }
                }, {
                    key: "explosionAnimation", get: function() {
                        return this.explosion.animations.add("boom", Phaser.Animation.generateFrameNames("explosion_", 1, 10, ".png", 2))
                    }
                }, {
                    key: "canonSmokeAnimation", get: function() {
                        return this.canonSmoke.animations.add("canonSmoke", Phaser.Animation.generateFrameNames("CannonSmoke_0", 1, 7, ".png"))
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = d
        }, {"../display/layout-utils": 3, "../kernel/globals": 6}],
        10: [function(t, e, i) {
            "use strict";
            function n(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function s(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function r(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var o = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), a = function(t) {
                function e(t, i) {
                    n(this, e);
                    var r = s(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return r.init(), r
                }

                return r(e, t), o(e, [{
                    key: "init", value: function() {
                        var t = this.emitter = this.game.add.emitter(0, 0, 50);
                        t.makeParticles("assets", Phaser.Animation.generateFrameNames("coin_", 1, 10, ".png")), t.setScale(.2, 2, .2, 2, 3e3, Phaser.Easing.Exponential.In), t.setAlpha(1, 0, 4e3, Phaser.Easing.Quintic.In), t.minParticleSpeed.set(-450, -1500), t.maxParticleSpeed.set(450, 0), t.setRotation(-3e3, 3e3), t.gravity = 800, this.add(t)
                    }
                }, {
                    key: "emit", value: function(t) {
                        var e = this.emitter, i = t.worldPosition,
                            n = this.game.input.getLocalPosition(this, new Phaser.Point(i.x, i.y));
                        e.x = n.x, e.y = n.y, e.start(!0, 2e3, null, 50, 150)
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = a
        }, {}],
        11: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("./../display/layout-utils"), l = n(h), c = function(t) {
                function e(t, i) {
                    s(this, e);
                    var n = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return n.initCTA(), n.visible = !1, n
                }

                return o(e, t), a(e, [{
                    key: "initCTA", value: function() {
                        var t = this.game.add.graphics(0, 0);
                        t.beginFill(0, .75), t.drawRect(l["default"].LEFT_OFFSET, l["default"].TOP_OFFSET, l["default"].BASE_WIDTH + l["default"].RIGHT_OFFSET, l["default"].BASE_HEIGHT + l["default"].BOTTOM_OFFSET), t.endFill(), t.inputEnabled = !0, t.events.onInputDown.add(wrapper_click_go), this.add(t), this.spine = this.game.add.spine(l["default"].BASE_WIDTH / 2, l["default"].BASE_HEIGHT * LP(.75, .65), "cta"), this.add(this.spine)
                    }
                }, {
                    key: "show", value: function() {
                        var t = this;
                        this.visible || (this.visible = !0, wrapper_mark_cta(), this.spine.setAnimationByName(0, "start", !1), setTimeout(function() {
                            t.spine.setAnimationByName(0, "idle", !0)
                        }, 1500))
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = c
        }, {"./../display/layout-utils": 3}],
        12: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                    function t(t, e) {
                        for(var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }

                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(), h = t("../display/layout-utils"), l = n(h), c = t("../kernel/globals"), u = n(c), d = t("./params"),
                p = n(d), f = function(t) {
                    function e(t, i, n) {
                        var o = n.canon, a = n.coins, h = n.camera, c = n.cta, u = n.score;
                        s(this, e);
                        var d = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                        return d.canon = o, d.coins = a, d.camera = h, d.cta = c, d.score = u, d.init(), d.x = l["default"].FULL_GAME_WIDTH / 2 - 20, d.y = l["default"].TOP_OFFSET + l["default"].getHeaderHeight() + LP(100, 230), d.scale.set(LP(.7, 1)), d.idle(), d
                    }

                    return o(e, t), a(e, [{
                        key: "init", value: function() {
                            var t = this, e = this.trees = imageLoader.sprite(100, 230, "trees.png"),
                                i = this.treesDestroyed = imageLoader.sprite(100, 230, "treesDestroyed.png"),
                                n = this.island = imageLoader.sprite(24, 375, "island.png"),
                                s = this.parachute = imageLoader.sprite(-120, 0, "parachute.png"),
                                r = this.parachuteDestroyed = imageLoader.sprite(-120, 0, "parachuteDestroyed.png"),
                                o = this.house = imageLoader.sprite(80, 120, "house.png"),
                                a = this.houseDestroyed = imageLoader.sprite(80, 120, "houseDestroyed.png"),
                                h = this.tower = imageLoader.sprite(-160, 230, "tower.png"),
                                l = this.towerDestroyed = imageLoader.sprite(-160, 230, "towerDestroyed.png"),
                                c = this.pig = imageLoader.sprite(120, 280, "pig.png"),
                                d = this.pigDestroyed = imageLoader.sprite(120, 280, "pigDestroyed.png"),
                                p = this.animalIcon = imageLoader.sprite(200, 350, "animalIcon.png"),
                                f = this.mountainIcon = imageLoader.sprite(-20, 320, "mountainIcon.png"),
                                g = this.shipIcon = imageLoader.sprite(-60, -40, "shipIcon.png"),
                                m = ["destroyPig", "destroyIsland", "destroyParachute"];
                            [p, f, g].forEach(function(e, i) {
                                e.scale.set(0), e.inputEnabled = !0, e.events.onInputDown.add(function() {
                                    "progress" !== u["default"].state && (u["default"].state = "progress", t[m[i]](), t.checkEnd())
                                }, t)
                            }), [i, r, a, l, d].forEach(function(t) {
                                return t.alpha = 0
                            }), [e, i, n, s, r, o, a, h, l, c, d, p, f, g].forEach(function(e) {
                                return t.add(e)
                            }), this.setAll("anchor.x", .5), this.setAll("anchor.y", .5)
                        }
                    }, {
                        key: "destroyPig", value: function() {
                            var t = this;
                            this.hideIcon(this.animalIcon), this.canon.shootPigTo(this.pig, function() {
                                t.destroy(t.pig, t.pigDestroyed, t.animalIcon), t.coins.emit(t.pig)
                            })
                        }
                    }, {
                        key: "destroyParachute", value: function() {
                            var t = this;
                            this.hideIcon(this.shipIcon), this.canon.shootPigTo(this.parachute, function() {
                                t.destroy(t.parachute, t.parachuteDestroyed, t.shipIcon), t.coins.emit(t.parachute)
                            })
                        }
                    }, {
                        key: "destroyIsland", value: function() {
                            var t = this;
                            this.hideIcon(this.mountainIcon), this.canon.shootPigTo(this.tower, function() {
                                t.destroy(t.house, t.houseDestroyed), t.destroy(t.trees, t.treesDestroyed), t.destroy(t.tower, t.towerDestroyed), p["default"].ruins < 3 ? t.destroy(t.pig, t.pigDestroyed) : "", p["default"].ruins < 2 ? t.destroy(t.parachute, t.parachuteDestroyed) : "", t.coins.emit(t.tower)
                            })
                        }
                    }, {
                        key: "destroy", value: function(t, e) {
                            this.camera.shake(), this.score.addScore(), this.game.add.tween(t).to({alpha: 0}).start(), this.game.add.tween(e).to({alpha: 1}).start()
                        }
                    }, {
                        key: "hideIcon", value: function(t) {
                            this.game.add.tween(t.scale).to({
                                x: [1.2, 0],
                                y: [1.2, 0]
                            }, 300, null, !0).onComplete.add(function() {
                                return t.visible = !1
                            })
                        }
                    }, {
                        key: "checkEnd", value: function() {
                            var t = this.ruins = ++this.ruins || 1;
                            t >= p["default"].ruins && setTimeout(this.cta.show.bind(this.cta), 4e3)
                        }
                    }, {
                        key: "idle", value: function() {
                            var t = this.parachute, e = this.parachuteDestroyed;
                            this.game.add.tween(t).to({y: t.y + 10}, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 50, -1, !0), this.game.add.tween(e).to({y: e.y + 4}, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 50, -1, !0), this.game.add.tween(this).to({
                                x: this.x + 1,
                                y: this.y + 1
                            }, 3e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
                        }
                    }, {
                        key: "showIcons", value: function() {
                            for(var t = this, e = [this.mountainIcon, this.shipIcon, this.animalIcon],
                                    i = 0; i < Math.max(p["default"].ruins); i++) {
                                var n = e[i];
                                this.game.add.tween(n.scale).to({
                                    x: [1.6, 1.4],
                                    y: [1.6, 1.4]
                                }, 400, Phaser.Easing.Sinusoidal.InOut, !0, 300 * i)
                            }
                            setTimeout(function() {
                                return setInterval(function() {
                                    return t.idleIcons()
                                }, 3e3)
                            }, 500)
                        }
                    }, {
                        key: "idleIcons", value: function() {
                            for(var t = [this.mountainIcon, this.shipIcon, this.animalIcon],
                                    e = 0; e < Math.max(p["default"].ruins); e++) {
                                var i = t[e], n = i.width, s = i.height;
                                this.game.add.tween(i).to({
                                    width: [1.2 * n, n],
                                    height: [1.2 * s, s]
                                }, 400, Phaser.Easing.Sinusoidal.InOut, !0, 300 * e)
                            }
                        }
                    }]), e
                }(Phaser.Group);
            i["default"] = f
        }, {"../display/layout-utils": 3, "../kernel/globals": 6, "./params": 13}],
        13: [function(t, e, i) {
            "use strict";
            Object.defineProperty(i, "__esModule", {value: !0}), i["default"] = utils.getAdParameters({
                ctaOnIdleTime: {
                    type: "int",
                    "default": 30
                },
                ruins: {type: "int", "default": 3},
                tutorialOnIdleTime: {type: "int", "default": 5e3},
                tutorial: {type: "boolean", "default": !0}
            })
        }, {}],
        14: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("../display/layout-utils"), l = n(h), c = t("../kernel/globals"), u = n(c), d = function(t) {
                function e(t, i) {
                    s(this, e);
                    var n = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return n.init(), n.y = l["default"].TOP_OFFSET + l["default"].getHeaderHeight() + 20, n
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                        var t = imageLoader.sprite(20, 0, "scoreLeft.png");
                        this.add(t);
                        var e = {fill: "white", font: "30px " + u["default"].font},
                            i = this.game.make.text(t.x + 100, t.y + 14, 2, e);
                        i.stroke = "#000000", i.strokeThickness = 3, this.add(i);
                        for(var n = 0; n < 2; n++) {
                            var s = imageLoader.sprite(200 + 50 * n, t.y + 30, "diamond.png");
                            s.anchor.set(.5), this.add(s)
                        }
                        var r = imageLoader.sprite(l["default"].BASE_WIDTH - 20, 0, "scoreRight.png");
                        r.anchor.set(1, 0), this.add(r);
                        var o = (this.score = 7e3, this.scoreText = this.game.make.text(r.x - r.width / 2, r.y + 14, 6900, e));
                        o.stroke = "#000000", o.strokeThickness = 3, o.anchor.set(.5, 0), this.add(o)
                    }
                }, {
                    key: "addScore", value: function() {
                        this.score += 7e3
                    }
                }, {
                    key: "update", value: function() {
                        var t = +this.scoreText.text.replace(",", ""), e = this.score;
                        t >= e || (t = String(t + 100), this.scoreText.text = t.slice(0, -3) + "," + t.slice(-3))
                    }
                }]), e
            }(Phaser.Group);
            i["default"] = d
        }, {"../display/layout-utils": 3, "../kernel/globals": 6}],
        15: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                    function t(t, e) {
                        for(var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }

                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(), h = t("../display/layout-utils"), l = n(h), c = t("../kernel/globals"), u = n(c), d = t("./params"),
                p = n(d), f = function(t) {
                    function e(t, i, n, o) {
                        s(this, e);
                        var a = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                        return a.island = n, a.cta = o, a.init(), a.hide(), a
                    }

                    return o(e, t), a(e, [{
                        key: "init", value: function() {
                            var t = this, e = this.tutorialBg = imageLoader.sprite(0, 0, "tutorialBg.png");
                            e.x = l["default"].FULL_GAME_WIDTH - e.width / 2 - 10, e.y = l["default"].TOP_OFFSET + l["default"].FULL_GAME_HEIGHT - e.height / 2 - 10, e.anchor.set(.5), e.scale.set(0), this.add(e);
                            var i = this.tip = this.game.make.text(e.x, e.y, "Tap the bubbles\nto shoot", {
                                align: "center",
                                font: "30px " + u["default"].font,
                                fill: "#087998"
                            });
                            i.anchor.set(.5), i.alpha = 0, this.add(i);
                            for(var n = ["animalIcon", "mountainIcon", "shipIcon"], s = 0; s < n.length; s++) {
                                var r = n[s];
                                this.island[r].events.onInputDown.add(function() {
                                    return t.hide()
                                })
                            }
                        }
                    }, {
                        key: "show", value: function() {
                            var t = this;
                            this.hidden && (this.hidden = !1, this.shows = !0, this.parent.bringToTop(this), this.game.add.tween(this.tutorialBg.scale).to({
                                x: .8,
                                y: .8
                            }, 300, Phaser.Easing.Back.Out, !0).onComplete.add(function() {
                                t.game.add.tween(t.tip).to({alpha: 1}, 100, null, !0), t.idle()
                            }))
                        }
                    }, {
                        key: "hide", value: function() {
                            this.hidden || (this.hidden = !0, this.game.tweens.remove(this.tw1), this.game.tweens.remove(this.tw2), this.game.add.tween(this.tutorialBg.scale).to({
                                x: 0,
                                y: 0
                            }, 300, Phaser.Easing.Back.Out, !0), this.game.add.tween(this.tip).to({alpha: 0}, 100, null, !0))
                        }
                    }, {
                        key: "idle", value: function() {
                            this.tutorialBg.scale.set(.8), this.tw1 = this.game.add.tween(this.tutorialBg.scale).to({
                                x: .87,
                                y: .87
                            }, 900, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.tip.scale.set(1), this.tw2 = this.game.add.tween(this.tip.scale).to({
                                x: 1.1,
                                y: 1.1
                            }, 900, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
                        }
                    }, {
                        key: "update", value: function() {
                            return this.cta.visible ? this.hide() : "ready" === u["default"].state ? this.show() : this.shows && Date.now() - u["default"].lastInteraction > p["default"].tutorialOnIdleTime ? this.show() : void 0
                        }
                    }]), e
                }(Phaser.Group);
            i["default"] = f
        }, {"../display/layout-utils": 3, "../kernel/globals": 6, "./params": 13}],
        16: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                function t(t, e) {
                    for(var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }

                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(), h = t("../display/layout-utils"), l = n(h), c = t("../kernel/globals"), u = (n(c), function(t) {
                function e(t, i, n) {
                    var o = n.camera, a = n.canon;
                    s(this, e);
                    var h = r(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    return h.camera = o, h.canon = a, h.init(), h
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                        var t = l["default"].FULL_GAME_WIDTH, e = l["default"].FULL_GAME_HEIGHT, i = LP(1, 1.5);
                        this.addWheel({w: t, h: e, sc: i}), this.addStatic({
                            w: t,
                            h: e,
                            sc: i
                        }), this.x = l["default"].LEFT_OFFSET, this.y = l["default"].TOP_OFFSET + l["default"].getHeaderHeight() + LP(0, 50)
                    }
                }, {
                    key: "addStatic", value: function(t) {
                        var e = t.w, i = (t.h, t.sc), n = imageLoader.sprite(-71, 300, "tree.png");
                        this.add(n), this.sendToBack(n);
                        var s = imageLoader.sprite(e / 2, 6, "wheelStatic.png");
                        s.anchor.set(.5, 0), s.scale.set(i), this.add(s);
                        var r = imageLoader.sprite(LP(184, 200) + e / 2, LP(135, 50), "bubble.png");
                        this.add(r);
                        var o = imageLoader.sprite(LP(234 + e / 2, 150 + e / 2), LP(303, 700), "floatingIsland.png");
                        this.add(o);
                        var a = this.game.add.spine(LP(250, 90), LP(380, 300), "wheelPigSpine");
                        a.scale.set(1.5), a.setAnimationByName(0, "animation", !0), this.add(a)
                    }
                }, {
                    key: "addWheel", value: function(t) {
                        var e = t.w, i = (t.h, t.sc),
                            n = this.wheel = imageLoader.sprite(e / 2, LP(320, 475), "wheel.png");
                        n.anchor.set(.5), n.scale.set(i), this.add(n);
                        var s = this.wheelEndGlow = imageLoader.sprite(n.x, n.y, "wheelEndGlow.png");
                        s.scale.set(0), s.anchor.set(.5), this.add(s);
                        var r = this.wheelRotationLight = imageLoader.sprite(0, 0, "wheelRotationLight.png");
                        r.scale.set(.7), r.anchor.set(.5), r.alpha = 0, n.addChild(r)
                    }
                }, {
                    key: "rotate", value: function(t) {
                        var i = this;
                        if(!(this.rotates >= 1 || this.ended)) {
                            this.rotates = ++this.rotates || 0;
                            var n = 1500;
                            this.game.add.tween(this.wheelRotationLight).to({alpha: [0, 0, 0, 0, 0, 0]}, n).start(), this.game.add.tween(this.wheel).to({angle: 2973}, n, e.interpolation, !0, 1, 0, !1).onComplete.add(function() {
                                t ? t() : "", setTimeout(function() {
                                    i.ended || (i.ended = !0, i.wheelEndGlowTween(function() {
                                        i.canon.showPig(i.wheel, function() {
                                            i.camera.showIsland(), i.canon.show(), i.canon.tweenPigFromWheelToCanon(i.wheel)
                                        })
                                    }))
                                }, 2e3)
                            })
                        }
                    }
                }, {
                    key: "wheelEndGlowTween", value: function(t) {
                        var e = this.wheel;
                        this.game.add.tween(this.wheelEndGlow).to({
                            width: e.width,
                            height: e.height
                        }, 400).start().onComplete.add(t)
                    }
                }], [{
                    key: "interpolation", value: function(t) {
                        return 1 - Math.pow(2, -10 * t)
                    }
                }]), e
            }(Phaser.Group));
            i["default"] = u
        }, {"../display/layout-utils": 3, "../kernel/globals": 6}],
        17: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                    function t(t, e) {
                        for(var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }

                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(), h = t("kernel/globals"), l = n(h), c = t("display/layout-utils"), u = n(c), d = t("../objects/wheel"),
                p = n(d), f = t("../objects/button"), g = n(f), m = t("../objects/island"), y = n(m),
                v = t("../objects/canon"), x = n(v), _ = t("../objects/coins"), b = n(_), w = t("../objects/camera"),
                T = n(w), P = t("../objects/score"), C = n(P), S = t("../objects/cta"), I = n(S),
                O = t("../objects/params"), A = n(O), M = t("../objects/tutorial"), k = n(M), E = function(t) {
                    function e() {
                        return s(this, e), r(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
                    }

                    return o(e, t), a(e, [{
                        key: "create", value: function() {
                            this.game.time.desiredFps = 60, this.initObjects()
                        }
                    }, {
                        key: "initObjects", value: function() {
                            var t = this;
                            u["default"].refreshViewDimmensions(), this.bg = imageLoader.displayBackground();
                            var e = l["default"].game = this.game, i = this.view = this.game.add.group(),
                                n = this.wheelView = e.add.group(), s = this.islandView = e.add.group();
                            s.x = 2 * u["default"].FULL_GAME_WIDTH, i.add(n), i.add(s);
                            var r = new C["default"](e, i), o = this.cta = new I["default"](e, i),
                                a = new T["default"](e, i, {islandView: s, wheelView: n}), h = new b["default"](e, i),
                                c = new x["default"](e, s), d = new p["default"](e, n, {camera: a, canon: c}),
                                f = new g["default"](e, n, {wheel: d}),
                                m = new y["default"](e, s, {canon: c, coins: h, camera: a, cta: o, score: r});
                            A["default"].tutorial ? new k["default"](e, s, m, o) : "", c.island = m, s.bringToTop(c), d.rotate(f.idle.bind(f)), this.game.input.onDown.add(function() {
                                l["default"].lastInteraction = Date.now(), wrapper_mark_interaction()
                            }), this.game.scale.onSizeChange.add(function(e) {
                                return t.onResize(e)
                            }), this.onResize(null), wrapper_hide_splash()
                        }
                    }, {
                        key: "onResize", value: function() {
                            u["default"].refreshViewDimmensions(), u["default"].fitIntoRect(this.bg, {
                                x: 0,
                                y: 0,
                                width: u["default"].VIEW_WIDTH,
                                height: u["default"].VIEW_HEIGHT
                            }, !0, "middleCenter"), u["default"].centerIntoView(this.view)
                        }
                    }, {
                        key: "update", value: function() {
                            l["default"].lastInteraction + 1e3 * A["default"].ctaOnIdleTime < Date.now() && this.cta.show()
                        }
                    }]), e
                }(Phaser.State);
            i["default"] = E
        }, {
            "../objects/button": 7,
            "../objects/camera": 8,
            "../objects/canon": 9,
            "../objects/coins": 10,
            "../objects/cta": 11,
            "../objects/island": 12,
            "../objects/params": 13,
            "../objects/score": 14,
            "../objects/tutorial": 15,
            "../objects/wheel": 16,
            "display/layout-utils": 3,
            "kernel/globals": 6
        }],
        18: [function(t, e, i) {
            "use strict";
            function n(t) {
                return t && t.__esModule ? t : {"default": t}
            }

            function s(t, e) {
                if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function r(t, e) {
                if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }

            function o(t, e) {
                if("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            Object.defineProperty(i, "__esModule", {value: !0});
            var a = function() {
                    function t(t, e) {
                        for(var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }

                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(), h = t("kernel/globals"), l = n(h), c = t("display/layout-utils"), u = n(c),
                d = t("../../creative.json");
            l["default"].font = "BAUHAUSB", window.WebFontConfig = {
                active: function() {
                    l["default"].FONT_IS_LOADED = !0
                }, custom: {families: d.css_fonts, urls: []}
            };
            var p = function(t) {
                function e() {
                    return s(this, e), r(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments))
                }

                return o(e, t), a(e, [{
                    key: "init", value: function() {
                        var t = this;
                        this.stage.backgroundColor = "#010101", this.stage.disableVisibilityChange = !0, this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.game.scale.setResizeCallback(function(e) {
                            var i = t.game.device.pixelRatio * u["default"].RENDER_RESOLUTION;
                            e.setGameSize(window.innerWidth * i, window.innerHeight * i), e.setUserScale(1 / i, 1 / i)
                        }), this.game.scale.onSizeChange.add(function(e) {
                            return t.game.state.callbackContext.resize()
                        }), this.scale.refresh(), u["default"].refreshViewDimmensions()
                    }
                }, {
                    key: "preload", value: function() {
                        this.game.add.plugin(Fabrique.Plugins.Spine), this.game.load.script("webfont", "https://cdn.unityads.unity3d.com/playables/piggy_ios/webfont.js");
                        var t = l["default"].WEB_ROOT + "/";
                        imageLoader.registerGame(this.game), imageLoader.registerBackgroundImage(t + "landscape.jpg", 960, 640), imageLoader.registerBackgroundImage(t + "portrait.jpg", 640, 960), imageLoader.preloadBackground(), imageLoader.loadAtlas("assets", l["default"].WEB_ROOT + "/assets_v3.png");
                        var e = ["wheelPigSpine", "cta"], i = l["default"].WEB_ROOT + "/assets_v3.png",
                            n = "assets";
                        this.game.load.spine(e, i, n)
                    }
                }, {
                    key: "create", value: function() {
                        wrapper_preload_complete()
                    }
                }, {
                    key: "loadUpdate", value: function() {
                        wrapper_load_progress(this.game.load.progress)
                    }
                }, {
                    key: "update", value: function() {
                        "ready" === ad_state && l["default"].FONT_IS_LOADED && (ad_state = "live", this.state.start("GameState"))
                    }
                }]), e
            }(Phaser.State);
            i["default"] = p
        }, {"../../creative.json": 1, "display/layout-utils": 3, "kernel/globals": 6}]
    }, {}, [2]), console.log("wrapper - start"), genlog("funnel", "wrapper");
    var ad_state = null, time_wrapper_start = (new Date).getTime(), time_mraid_ready = null, time_mraid_viewable = null,
        time_app_preload_complete = null, time_app_start = null, close_button_time_remaining = null,
        close_button_showing = !1, close_button_timeout_id = null, advertisingLabels = {CN: ""}, ageRatingImages = {
            "0+": "age0.png",
            "6+": "age6.png",
            "12+": "age12.png",
            "16+": "age16.png",
            "18+": "age18.png"
        }, body_width = 960, body_height = 640, isSplashHidden = !1;
    if(null === ad_getapp_instead_of_title)var ad_getapp_instead_of_title = !1;
    "undefined" == typeof ad_expandable && (ad_expandable = !1), "undefined" == typeof ad_close_position && (ad_close_position = "right"), "undefined" == typeof ad_close_countdown && (ad_close_countdown = !0), "undefined" != typeof ad_advertising_label_lang && "%LABEL_LANG%" !== ad_advertising_label_lang || (ad_advertising_label_lang = ""), "undefined" != typeof ad_show_age_ratings && "%AGE_RATING%" !== ad_show_age_ratings || (ad_show_age_ratings = "");
    var query_params = null;
    query_params = "undefined" == typeof dev_params ? {} : dev_params, location.search.substr(1).split("&").forEach(function(t) {
        query_params[t.split("=")[0]] = decodeURIComponent(t.split("=")[1])
    });
    var hadFirstInteraction = !1, hadSecondInteraction = !1, hadThirdInteraction = !1;
    localization.registerString("Mini game loading, please wait...", {
        en: "Mini game loading...",
        ar: "     ...",
        bg: "-  , , ...",
        zh: "",
        cs: "Probh natn minihry, prosm ekejte...",
        da: "Mini spil loader, vent venligst...",
        nl: "Mini-game is aan het laden, even geduld...",
        fi: "Minipeli ladataan; ole hyv ja odota...",
        fr: "Chargement du mini-jeu, merci de patienter...",
        de: "Mini-Spiel wird geladen. Bitte warten ...",
        el: "  ,  ... ",
        he: "- ,  ...",
        hu: "Krem vrjon, a mini jtk betltse folyamatban...",
        id: "Memuat mini game, silakan tunggu...",
        it: "Mini gioco in caricamento, attendere prego...",
        ja: "...",
        ko: "  ,  ...",
        ms: "Permainan mini sedang dimuat turun, sila tunggu sebentar...",
        no: "Minispill laster, vennligst vent...",
        pl: "Zaczekaj, trwa wczytywanie minigry...",
        pt: "Minijogo carregando, aguarde",
        ro: "Mini-jocul se ncarc, v rugm s ateptai...",
        ru: " , , ...",
        sr: "Mini igrica se uitava, molimo saekajte...",
        sk: "Minihra sa natava, akajte prosm...",
        es: "Cargando minijuego, por favor espere...",
        sv: "Minispelet laddas, vnta...",
        tl: "Nagloload ang mini game, pakihintay...",
        th: " ...",
        tr: "Mini oyun ykleniyor, ltfen bekle...",
        uk: "- ,  , ...",
        vi: "Tr chi ang ti, vui lng ch..."
    });
    var bgNumShadows = 30, mraid_wrapper_handling_error = !1;
    window.onerror = function(t, e, i, n, s) {
        if(!mraid_wrapper_handling_error) {
            mraid_wrapper_handling_error = !0;
            var r = t + ", url=" + e + ", line=" + i;
            n && (r += ", column=" + n), s && (r += ", error=" + JSON.stringify(s)), log_remote("onerror", r), mraid_wrapper_handling_error = !1
        }
    }, console.log("wrapper - html writing...");
    var header_markup_left = "", header_markup_right = "";
    "none" == ad_close_position ? (header_markup_left = '', header_markup_right = "") : "left" == ad_close_position ? (header_markup_left = '<div id="close_timer" class="close_timer_left" style="display:none"></div><div id="close_zone" class="close_zone_left" style="display:none"><div class="close-button"></div></div>', header_markup_right = '') : (header_markup_left = '', header_markup_right = '<div id="close_timer" class="close_timer_right" style="display:none"></div><div id="close_zone" class="close_zone_right" style="display:none"><div class="close-button"></div></div>');
    var fullscreen_html = null;
    fullscreen_html = ad_getapp_instead_of_title ? '<div id="ad_header">' + header_markup_left + '<a href="' + ad_click_dest + '" style=""><div id="ad_title"><div style="background-color:#589B5F;">- Get the App -</div></a></div></div><div id="orientation"></div>' : '<div id="ad_header">' + header_markup_left + '<div id="ad_title">' + ad_title + getAdvertisingLabel() + getAgeRating() + "</div>" + header_markup_right + '</div><div id="orientation"></div>', ad_has_custom_load_screen || (fullscreen_html += '<div id="splash"><div id="splash_icon_wrap"><a href="' + ad_click_dest + '"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAMAAABlApw1AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA25pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2MGU4MTI2MC1iMzc2LWI0NDEtODI0Mi00NWQwOWNmZWE3YzkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RjA0MjRGMjBGRjI5MTFFNjk1OTQ5RDg3Mzk3MzhCNzAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RjA0MjRGMUZGRjI5MTFFNjk1OTQ5RDg3Mzk3MzhCNzAiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKFdpbmRvd3MpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RjkzRUJDMjFBRkIzMTFFNkJENDZFRjYxMUY4Nzk3OTEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RjkzRUJDMjJBRkIzMTFFNkJENDZFRjYxMUY4Nzk3OTEiLz4gPC9yZGY6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" id="splash_icon"/></a></div><div id="splash_wait" lang="' + localization.getLanguage() + '">' + localization.get("Mini game loading, please wait...") + '</div><div id="splash_loading"><div id="splash_loading_bar"></div><div id="splash_loading_bar_full"></div></div><div id="splash_footer"><div id="splash_footer_logo"></div></div></div>'), ad_expandable ? document.write('<div id="ad_banner"><img src="' + ad_expandable_banner + '" width="' + ad_expandable_banner_width + '" height="' + ad_expandable_banner_height + '" onclick="javascript:wrapper_expand();"></img></div><div id="ad_expanded" style="display:none">' + fullscreen_html + "/div>") : document.write(fullscreen_html), console.log("wrapper - html written"), query_params.dev_nomraid ? (console.log("dev_nomraid showAd"), showAd()) : "ready" != mraid.getState() ? (console.log("MRAID Ad: adding event listener for ready"), mraid.addEventListener("ready", function() {
        setupMraid("ready")
    })) : (console.log("MRAID default ready"), setupMraid("default")), console.log("wrapper - end");</script>
    <div id="creative"></div>
</div>
